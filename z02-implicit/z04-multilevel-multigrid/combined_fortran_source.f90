
        program mains ! ann filter and simple code
            !        if(.true.) then ! Sn quadrature on unit sphere
                    if(.false.) then ! Sn quadrature on unit sphere
                       call file_generator4octant_sn_quadrature
                    else if(.false.) then ! voronoi grid to triangles
                       call main32
                    else if(.true.) then! solver example...
                       call main7
                    else if(.false.) then! solver example...
            !           call cty_filter_orig ! linear cty element filters
            ! all the filters: linear, quadratic etc cty filters
                       call main4
                    else if(.false.) then
                       call set_up_cty_filter_quadratic_and_higher_fem
            !           call main4 ! linear DG element filters
                    endif
                    stop 2992
                    end program mains
            ! 
            ! 
            ! 
            ! 
                    subroutine main32 ! voronoi grid to triangles testing
                    implicit none
            ! integers representing the length of arrays...
            ! nx=no of nodes across, ny=no of nodes up. 
            !        integer, parameter :: nx=11,ny=11, nonods=nx*ny, totele=(nx-1)*(ny-1)
                    integer, parameter :: nx=128,ny=128, max_voronoi_cells=10000, max_connect=70
                    integer, parameter :: nx2=2*nx,ny2=2*ny
            ! mesh_functional: This subdoutine calculates the quality if the triangle mesh mesh_functional from 
            ! a grid gof pixes of different color defined by color(i,j)=colour of pixel (integer) and 
            ! the grid or image has dimensions (nx,ny) - number of cells across and down respectively. 
            ! xc,yc: It calculates the centres of mass of the Voronoi cells (xc(icell),yc(icell)) in which icell 
            ! is the cell number. 
            ! number_voronoi_cells: It calculates the number of Voronoi cells number_voronoi_cells. 
            ! dx, dy: are the dimensions of the cells. 
            ! desired_edge_length is the desired edge length of the triangles. 
            ! max_voronoi_cells contains the maximum number of Voronoi cells in the image. 
            ! max_connect is the maximum number of Voronoi cells surrounding (next too) a given Voronoi cell. 
            ! voronoi_cell_connect(icell, jj)= the jj^th index to a aurrounding Voronoi cell of cell icell. 
            ! voronoi_cell_connect(icell, jj) contains a non-zero only up to the number jj of surrounding 
            ! Voronoi cells otherwise it contains 0. 
                      real xc(max_voronoi_cells), yc(max_voronoi_cells)
                      real mesh_functional
                      integer voronoi_cell_connect(max_voronoi_cells,max_connect)
                      integer number_voronoi_cells
                      real dx, dy, desired_edge_length
                      integer color(nx,ny),color2(2*nx,2*ny)
            ! Local variables
                      integer i,j,ii,jj,nnx,nny,icolor,ivor, imax, iconnect
            
                      dx=1.0
                      dy=1.0
                      desired_edge_length=4.0
                      nnx=4
                      nny=4
                      color=0 
                      do jj=1,nny
                      do ii=1,nnx
                         icolor=ii + (jj-1)*nnx
                         do j=1,ny
                         do i=1,nx  
                            if(1 + (i-1)/(nx/nnx) == ii) then
                            if(1 + (j-1)/(ny/nny) == jj) then
                               color(i,j)=icolor
                            endif 
                            endif 
                         end do
                         end do
                      end do
                      end do
            ! 
                    open(3, file='example.txt')
                    do j=1,ny
                       read(3,*) (color(i,j),i=1,nx)
                    end do
                    close(3)
                    imax=maxval(color)
                      do j=1,ny
                      do i=1,nx 
                         if(color(i,j)==0) color(i,j)=imax 
                      end do
                      end do
            
            !          if(minval(color)==0) then
            !             stop 292
            !          endif
            ! 
                      do j=1,ny
                         print *,'j,color(:,j):',j,':',color(:,j)
                      end do
                      do j=1,ny
                      do i=1,nx 
                         do jj=1,2
                         do ii=1,2
                            color2((i-1)*2+ii,(j-1)*2+jj) = color(i,j)
                         end do
                         end do
                      end do
                      end do
            ! 
                      call voronoi_cell_functional_and_pts(xc,yc, mesh_functional, &
                                                         voronoi_cell_connect, number_voronoi_cells, &
                                                         color2, dx, dy, desired_edge_length, &
                                                         nx2,ny2, max_voronoi_cells, max_connect ) 
            !                                             color, dx, dy, desired_edge_length, &
            !                                             nx,ny, max_voronoi_cells, max_connect ) 
                      print *,'just outside voronoi_cell_functional_and_pts'
            ! 
            ! 
                   if(.true.) then
                      open(3, file='mesh_data.txt')
                      write(3,*) mesh_functional
                      write(3,*) number_voronoi_cells
                      do ivor=1,number_voronoi_cells
                         write(3,*) ivor,xc(ivor),yc(ivor)
                         imax=0
                         do iconnect=max_connect,1,-1
                            if(voronoi_cell_connect(ivor,iconnect)==0) imax=iconnect
                         end do
                         write(3,*) imax
                         write(3,*) (voronoi_cell_connect(ivor,iconnect),iconnect=1,imax-1)
                      end do
                   endif
                   if(.false.) then
                      do ivor=1,number_voronoi_cells
                         print *,'ivor,xc(ivor),yc(ivor):',ivor,xc(ivor),yc(ivor)
                         imax=0
                         do iconnect=max_connect,1,-1
                            if(voronoi_cell_connect(ivor,iconnect)==0) imax=iconnect
                         end do
                         print *,'voronoi_cell_connect(ivor,:):', &
                             (voronoi_cell_connect(ivor,iconnect),iconnect=1,imax-1)
                      end do
                    endif
                    stop 32
                    end subroutine main32
            ! 
            ! 
            ! 
            ! 
            !        programsubroutine main ! ann filter and simple code
                    subroutine main7 ! ann filter and simple code
                    implicit none
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
                    
            ! local variables...
            ! 2d:
            ! nx=no of nodes across, ny=no of nodes up. 
            !        integer, parameter :: nx=11,ny=11, nonods=nx*ny, totele=(nx-1)*(ny-1)
            !        integer, parameter :: nx=1025,ny=1025, nonods=nx*ny, totele=(nx-1)*(ny-1)
                    integer, parameter :: nx=513,ny=513, nonods=nx*ny, totele=(nx-1)*(ny-1)
            !        integer, parameter :: nx=257,ny=257, nonods=nx*ny, totele=(nx-1)*(ny-1)
            !        integer, parameter :: nx=129,ny=129, nonods=nx*ny, totele=(nx-1)*(ny-1)
            !        integer, parameter :: nx=5,ny=5, nonods=nx*ny, totele=(nx-1)*(ny-1)
            !        integer, parameter :: nx=65,ny=65, nonods=nx*ny, totele=(nx-1)*(ny-1)
            !        integer, parameter :: nx=33,ny=33, nonods=nx*ny, totele=(nx-1)*(ny-1)
                    integer, parameter :: nloc=4,sngi=3, ngi=9, ndim=2, &
                                          nface=4, max_face_list_no=2
                    integer, parameter :: ntime = 10
                    real, parameter :: dt=0.1 
            ! example of node ordering...
            !      7-----8-----9
            !      !     !     !
            !      !     !     !        
            !      4-----5-----6
            !      !     !     !
            !      !     !     !        
            !      1-----2-----3
                    real b(nonods), ml(nonods)
                    real k(nonods), sig(nonods), s(nonods), t_new(nonods), t_old(nonods)
                    real u(ndim,nonods)
                    real x_all(ndim,nloc*totele)
                    integer fina(nonods+1) 
                    integer ndglno(nloc*totele)
            ! filters for ann:
                    integer, allocatable :: cola(:), cola_no_bc(:), fina_no_bc(:)
                    integer, allocatable :: ion_boundary(:), map2_no_bc_nodes(:), fin_sfc_nonods(:)
                    integer, allocatable :: ncurve_whichd(:,:), ncurve_space_fill_curve_numbering(:,:)
                    integer, allocatable :: super_sfc_node_ordering_inverse(:)
                    integer, allocatable :: full_super_sfc_node_ordering_inverse(:)
                    integer, allocatable :: fina_sfc_all_un(:,:), cola_sfc_all_un(:,:)
                    integer, allocatable :: ncola_sfc_all_un(:)
                    integer, allocatable :: add_ncurve_space_fill_curve_numbering(:,:)
                    real, allocatable :: a(:), a_no_bc(:), b_no_bc(:), a_filter(:), relax(:), relax_down(:)
                    real, allocatable :: ml_no_bc(:), psi(:), psi_no_bc(:), psi_no_bc_guess(:)
                    real, allocatable :: a_sfc(:,:,:), b_sfc(:,:), ml_sfc(:,:), max_psi_no_bc(:)
                    real, allocatable :: a_sfc_all_un(:,:)
                    integer npoly,ele_type, ncola
                    integer i,j, count
                    integer its,nits, ncurve, graph_trim, iuse_starting_node, icurve, nonods_no_bc
                    integer max_nlevel, max_nonods_sfc_all_grids, nlevel, inod_no_bc, inod, inod_new
                    integer inod_sfc_all, ncola_no_bc, nonods_sfc_all_grids
                    integer iscale_matrices, i_jacobi_on_finest_sfc, i_jacobi_full_matrix
                    integer nfilt_size_sfc, max_ncola_sfc_all_un
                    integer full_super_nonods, super_nonods, ndim_hilbert, max_add_ncurve
                    integer n_add_ncurve, add_sfc, vcycle, fcycle, top_level, ilevel
                    integer isweep, istart, ifinish, istep
                    real relax_keep_off
                    real dx,dy, xstart,xfinish,xmid, sx, xpt,ypt, rr
                    logical optimal_relax
            ! 
                    ncola=9*nonods ! this is the maximum size of ncola it will be smaller. 
                    allocate(a(ncola),a_filter(ncola))
                    allocate(cola(ncola))
            ! 
                    print *,'here in main'
            !        stop 23
                    dx=1.0/real(nx-1)
                    dy=1.0/real(ny-1)
            ! 
                    call set_up_grid_problem(t_old, t_new, x_all, ndglno, fina, cola, &
                                             dx, dy, ncola, nx, ny, nloc, ndim)
            
                    npoly=1
                    ele_type=1
            !        k=0.0; sig=0.0; s=0.0; u(1,:)=1.0; u(2,:)=1.0
                    k=1.0; sig=0.0; s=0.0; u(1,:)=0.0; u(2,:)=0.0
            
                    s=0.0
                    xstart  = 0.5 - 0.5/8.0
                    xfinish = 0.5 + 0.5/8.0
                    xmid=0.5
                    do j=2,ny-1 ! miss out boundary nodes.
                    do i=2,nx-1
                       inod=(j-1)*nx+i
                       xpt = real(i-1)*dx + 0.0*dx
                       ypt = real(j-1)*dy + 0.0*dy
            ! scale in x-direction
                       if((xpt<xstart).or.(xpt>xfinish)) then
                          sx=0.0
                       else
                          if(xpt<xmid) then
                             sx=(xpt-xstart)/(xmid-xstart)
                          else
                             sx=(xfinish-xpt)/(xfinish-xmid)
                          endif
                       endif
            ! scale in y-direction
                       if((ypt<xstart).or.(ypt>xfinish)) then
                          s(inod)=0.0
                       else
                          if(ypt<xmid) then
                             s(inod)=sx*(ypt-xstart)/(xmid-xstart)
                          else
                             s(inod)=sx*(xfinish-ypt)/(xfinish-xmid)
                          endif
                       endif
                    end do
                    end do
            !        s(nonods/2)=1.0
            ! in python:
            ! a, b = u2r.get_fe_matrix_eqn(x_all, u, k, sig, s, fina,cola, ncola, ndglno, nonods,totele,nloc, ndim, ele_type)
            ! ml = the lumped mass 
                    call get_fe_matrix_eqn(a,b, ml, k, sig, s, u, x_all, &
                                           fina,cola, ndglno,  &
                                           ele_type, ndim, totele,nloc, ncola,nonods) 
            
            ! Remove all the boundary nodes.
                    allocate(ion_boundary(nonods))
                    ion_boundary=1
                    nonods_no_bc=0
                    do j=2,ny-1 ! miss out boundary nodes.
                    do i=2,nx-1
                       inod=(j-1)*nx+i
                       ion_boundary(inod)=0
                       nonods_no_bc=nonods_no_bc+1
                    end do
                    end do
                    print *,'1-nx,ny,nonods,nonods_no_bc:',nx,ny,nonods,nonods_no_bc
            ! 
                    allocate(map2_no_bc_nodes(nonods))
                    allocate(b_no_bc(nonods_no_bc),ml_no_bc(nonods_no_bc)) 
                    allocate(a_no_bc(ncola))
                    allocate(fina_no_bc(nonods_no_bc+1),cola_no_bc(ncola))
                    call remove_bc_nodes_a_b(a_no_bc, b_no_bc, ml_no_bc, fina_no_bc, cola_no_bc, ncola_no_bc, &
                               map2_no_bc_nodes, a, b, ml, fina, cola,ion_boundary, nonods_no_bc, ncola, nonods)
            ! 
            !        call testing2331
                  if(.false.) then
                    print *,'nonods,nonods_no_bc:',nonods,nonods_no_bc
                    print *,'fina_no_bc:',fina_no_bc
                    do inod_no_bc=1,nonods_no_bc
                       print *,'inod_no_bc,nonods_no_bc:',inod_no_bc,nonods_no_bc
                       do count = fina_no_bc(inod_no_bc), fina_no_bc(inod_no_bc+1)-1 
                          print *,'count, cola_no_bc(count), a_no_bc(count):', &
                                   count, cola_no_bc(count), a_no_bc(count)
                       end do
                    end do
                  endif
            !        nfilt_size_sfc=27
            !        nfilt_size_sfc=129!9
                    nfilt_size_sfc=0 ! =0 for sparse matrix storage on each multi-grid level (no approx of multi-grid matrix)
            ! form 2 SFCs...
            !        relax_keep_off=0.7 ! works -how much of the not found value to add into the diagonal of the sfc matrix a_sfc
            ! relax_keep_off=0.0 (dont add any - more stable); relax_keep_off=1.0 (more accurate). =0.5 compromise. 
            !        relax_keep_off=0.5 ! works for hard problem =0.9 not work, =0.7 works, =0.0 works
            !        relax_keep_off=0.75 ! works for hard problem =0.9 not work, =0.8 not work, =0.75 works, =0.0 works
                    relax_keep_off=0.8 ! works for hard problem =0.9 not work, =0.8 not work, =0.75 works, =0.0 works
            !        relax_keep_off=0.5
            !        relax_keep_off=0.85
            !        relax_keep_off=0.999
            !        relax_keep_off=0.75
            ! need less relaxation the greater the filter width of the sfc. 
                    if(nfilt_size_sfc==1) relax_keep_off=0.6
                    if(nfilt_size_sfc==3) relax_keep_off=0.8
                    if(nfilt_size_sfc==5) relax_keep_off=0.93
                    if(nfilt_size_sfc==7) relax_keep_off=0.97
                    if(nfilt_size_sfc.ge.9) relax_keep_off=0.999
            !        if(nfilt_size_sfc.ge.25) relax_keep_off=0.97
            !        if(nfilt_size_sfc.ge.41) relax_keep_off=0.999
            !        relax_keep_off=0.999
            !        relax_keep_off=0.9
            !        ncurve = 2
            !        ncurve = 10
                    add_sfc = 0 ! add some more sfcs to form matrix.
                    ncurve = 1
                    graph_trim = -10
                    if(add_sfc.ne.0) graph_trim = 4 ! seems the best option for using SFC as matrices
            !        if(nfilt_size_sfc==0) graph_trim = 5 ! seems the best option for using SFC as matrices
            !        iuse_starting_node = 0 ! ie no starting node
                    iuse_starting_node = -1 ! use the rapid within subroutine mehtod
                    allocate( ncurve_whichd(nonods_no_bc,ncurve) )
                    allocate( ncurve_space_fill_curve_numbering(nonods_no_bc,ncurve) )
                    print *,'going into ncurve_python_subdomain_space_filling_curve'
            !        call ncurve_python_subdomain_space_filling_curve( ncurve_whichd,  &
                    call ncurve_python_subdomain_space_filling_curve_stub( ncurve_whichd,  &
                          ncurve_space_fill_curve_numbering,  cola_no_bc,fina_no_bc, iuse_starting_node, &
                          graph_trim, ncurve, nonods_no_bc,ncola_no_bc)
                    print *,'just out of ncurve_python_subdomain_space_filling_curve'
                  if(add_sfc.ne.0) then
                    max_add_ncurve=12
                    allocate( add_ncurve_space_fill_curve_numbering(nonods_no_bc,max_add_ncurve) )
                    call add_sfc_for_matrix(add_ncurve_space_fill_curve_numbering, &
                          n_add_ncurve, &
                          ncurve_space_fill_curve_numbering,  cola_no_bc,fina_no_bc, &
                          ncurve, nonods_no_bc,ncola_no_bc, max_add_ncurve)
                  endif ! if(add_sfc.ne.0) then
            ! 
                    if(.false.) then ! test SFC ordering...
                       print *,'here******'
                       allocate(super_sfc_node_ordering_inverse(2*ncurve*nonods_no_bc))
                       call combine_sfcs(super_sfc_node_ordering_inverse, super_nonods, &
                                     ncurve_space_fill_curve_numbering,nonods_no_bc,ncurve)
                       print *,'super_nonods=',super_nonods
                       print *,'super_sfc_node_ordering_inverse(1:super_nonods):', &
                                super_sfc_node_ordering_inverse(1:super_nonods)
            ! 
                       ndim_hilbert=2
                       call length_full_super_sfc(full_super_nonods, super_nonods, ndim_hilbert)
                       print *,'full_super_nonods=',full_super_nonods
                       allocate(full_super_sfc_node_ordering_inverse(full_super_nonods))
            ! 
                       call full_combine_sfcs(full_super_sfc_node_ordering_inverse, &
                             super_sfc_node_ordering_inverse, super_nonods, full_super_nonods) 
                        print *,'full_super_nonods, super_nonods, ndim_hilbert:', &
                                 full_super_nonods, super_nonods, ndim_hilbert 
                        print *,'full_super_sfc_node_ordering_inverse:', &
                                 full_super_sfc_node_ordering_inverse
                        stop 29219
                    endif
            ! 
            ! form 1d matrixes and vectors based on no_bc ordering on each grid level...
                    max_nonods_sfc_all_grids=5*nonods_no_bc
                    if(nfilt_size_sfc==0) then ! use sparse structure to stor matrices on each multi-grid level.
                       max_ncola_sfc_all_un=5*ncola_no_bc
                       allocate(a_sfc_all_un(max_ncola_sfc_all_un,ncurve))
                       allocate(fina_sfc_all_un(max_nonods_sfc_all_grids+1,ncurve))
                       allocate(cola_sfc_all_un(max_ncola_sfc_all_un,ncurve))
                       allocate(ncola_sfc_all_un(ncurve))
                       print *,'max_ncola_sfc_all_un,ncola_no_bc:',max_ncola_sfc_all_un,ncola_no_bc
                    else
                       allocate(a_sfc(nfilt_size_sfc,max_nonods_sfc_all_grids,ncurve)) 
                    endif
                    allocate(b_sfc(max_nonods_sfc_all_grids,ncurve))
                    allocate(ml_sfc(max_nonods_sfc_all_grids,ncurve))
                    max_nlevel=100
                    allocate(fin_sfc_nonods(max_nlevel+1))
                    do icurve=1,ncurve
                       if(nfilt_size_sfc==0) then
            !           if(.false.) then
                          call best_sfc_mapping_to_sfc_matrix_unstructured( &
                                 a_sfc_all_un(:,icurve), fina_sfc_all_un(:,icurve), &
                                 cola_sfc_all_un(:,icurve), ncola_sfc_all_un(icurve), &
                                 b_sfc(:,icurve), ml_sfc(:,icurve), &
                                 fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                 a_no_bc, b_no_bc, ml_no_bc,  &
                                 fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), ncola_no_bc, &
                                 nonods_no_bc, max_nonods_sfc_all_grids, &
                                 max_ncola_sfc_all_un, max_nlevel) 
                           print *,'nlevel:',nlevel
                           print *,'nonods_no_bc, nonods_sfc_all_grids:',nonods_no_bc, nonods_sfc_all_grids
                           print *,'nonods_sfc_all_grids/nonods_no_bc:',real(nonods_sfc_all_grids)/real(nonods_no_bc)
                           print *,'ncola_no_bc, ncola_sfc_all_un(icurve):',ncola_no_bc, ncola_sfc_all_un(icurve)
                           print *,'ncola_sfc_all_un(icurve)/ncola_no_bc:',real(ncola_sfc_all_un(icurve))/real(ncola_no_bc)
                           print *,'ncola_no_bc/nonods_no_bc:',real(ncola_no_bc)/real(nonods_no_bc)
                           print *,'ncola_sfc_all_un(icurve)/nonods_sfc_all_grids:', &
                                    real(ncola_sfc_all_un(icurve))/real(nonods_sfc_all_grids)
                           rr=0.0
                           do ilevel=nlevel,1,-1
                              rr=rr + real( fin_sfc_nonods(nlevel+1) - fin_sfc_nonods(ilevel) )
                           end do
                           print *,'work for simplified f-net:',real(nonods_sfc_all_grids)
                           print *,'work for BunnyNet:',rr
                           print *,'BunnyNet/simplied:',rr/real(nonods_sfc_all_grids)
            !               stop 2919
                       else if(nfilt_size_sfc==3) then
            !           if(.false.) then
                          call best_sfc_mapping_to_sfc_matrix_3(a_sfc(:,:,icurve), b_sfc(:,icurve), ml_sfc(:,icurve), &
                                 fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                 a_no_bc, b_no_bc, ml_no_bc, relax_keep_off, &
                                 fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), ncola_no_bc, &
                                 nonods_no_bc, max_nonods_sfc_all_grids, max_nlevel, &
                                 nfilt_size_sfc) 
                       else
                          call best_sfc_mapping_to_sfc_matrix_n(a_sfc(:,:,icurve), b_sfc(:,icurve), ml_sfc(:,icurve), &
                                 fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                 a_no_bc, b_no_bc, ml_no_bc, relax_keep_off, &
                                 fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), ncola_no_bc, &
                                 nonods_no_bc, max_nonods_sfc_all_grids, max_nlevel, &
                                 nfilt_size_sfc) 
                       endif
                    end do
                    print *,'max_nonods_sfc_all_grids,nonods_sfc_all_grids:', &
                             max_nonods_sfc_all_grids,nonods_sfc_all_grids
            ! 
                  iscale_matrices=0 ! default=0 (no scaling) - scale matrices by lumped mass matrix
                  i_jacobi_on_finest_sfc=0 ! default=0 - Jacobi on finest sfc matrix. 
                  i_jacobi_full_matrix=1 ! defaul=1 - Jacobi on full matirx
            ! 
            !      iscale_matrices=0 ! default=0 (no scaling) - scale matrices by lumped mass matrix
            !      i_jacobi_on_finest_sfc=0 ! default=0 - Jacobi on finest sfc matrix. 
            !      i_jacobi_full_matrix=1 ! defaul=1 - Jacobi on full matirx
                  if(iscale_matrices==1) then
            ! Scale all the eqns suitable for solver...
                    do inod_no_bc=1,nonods_no_bc
                       b_no_bc(inod_no_bc) = b_no_bc(inod_no_bc) / ml_no_bc(inod_no_bc)
                       do count = fina_no_bc(inod_no_bc), fina_no_bc(inod_no_bc+1)-1 
                          a_no_bc(count) = a_no_bc(count) / ml_no_bc(inod_no_bc)
                       end do
                    end do
            ! ...scale different levels of the SFC grids...
                    do icurve=1,ncurve
                       do inod_sfc_all=1,nonods_sfc_all_grids
                          b_sfc(inod_sfc_all,icurve) = b_sfc(inod_sfc_all,icurve)   / ml_sfc(inod_sfc_all,icurve)
                          if(nfilt_size_sfc.ne.0) then
                             a_sfc(:,inod_sfc_all,icurve)=a_sfc(:,inod_sfc_all,icurve) / ml_sfc(inod_sfc_all,icurve)
                          else
                             do count = fina_sfc_all_un(inod_sfc_all,icurve), fina_sfc_all_un(inod_sfc_all+1,icurve)-1
                                a_sfc_all_un(count,icurve) = a_sfc_all_un(count,icurve) / ml_sfc(inod_sfc_all,icurve)
                             end do
                          endif
            !              print *,'icurve,inod_sfc_all,a_sfc(:,inod_sfc_all,icurve):', &
            !                       icurve,inod_sfc_all,a_sfc(:,inod_sfc_all,icurve)
            !              print *,'sum(a_sfc(:,inod_sfc_all,icurve)):', &
            !                       sum(a_sfc(:,inod_sfc_all,icurve))
                       end do
                    end do
                  endif
            !      print *,'minval(a_sfc(2,1:nonods_sfc_all_grids,:)):',minval(a_sfc(2,1:nonods_sfc_all_grids,:))
                  print *,'minval(ml_sfc(1:nonods_sfc_all_grids,:)):',minval(ml_sfc(1:nonods_sfc_all_grids,:))
                  print *,'minval(ml_sfc(1:nonods_sfc_all_grids,1)):',minval(ml_sfc(1:nonods_sfc_all_grids,1))
            !      print *,'minval(ml_sfc(1:nonods_sfc_all_grids,2)):',minval(ml_sfc(1:nonods_sfc_all_grids,2))
            !      print *,'maxval(a_sfc(2,1:nonods_sfc_all_grids,:)):',maxval(a_sfc(2,1:nonods_sfc_all_grids,:))
                  print *,'maxval(ml_sfc(1:nonods_sfc_all_grids,:)):',maxval(ml_sfc(1:nonods_sfc_all_grids,:))
            ! 
            !      print *,'minval(a_sfc(2,1:nonods_no_bc,:)):',minval(a_sfc(2,1:nonods_no_bc,:))
                  print *,'minval(ml_sfc(1:nonods_no_bc,:)):',minval(ml_sfc(1:nonods_no_bc,:))
            !      print *,'maxval(a_sfc(2,1:nonods_no_bc,:)):',maxval(a_sfc(2,1:nonods_no_bc,:))
                  print *,'maxval(ml_sfc(1:nonods_no_bc,:)):',maxval(ml_sfc(1:nonods_no_bc,:))
            !
                  print *,'minval(ml),maxval(ml):',minval(ml),maxval(ml)
            !      stop 828
            
            ! makse diagonal bigger to help convergence 
            ! e.g. add a bit of mass to help convergence or just make diagonal bigger
            !      a_sfc(2,1:nonods_sfc_all_grids,:)=a_sfc(2,1:nonods_sfc_all_grids,:) + 0.5*ml_sfc(1:nonods_sfc_all_grids,:) ! 0.5 works for 200 elements across
            !      a_sfc(2,1:nonods_sfc_all_grids,:)=a_sfc(2,1:nonods_sfc_all_grids,:) + 0.3*ml_sfc(1:nonods_sfc_all_grids,:) ! 0.3 works for 200 elements across
            !      a_sfc(2,1:nonods_sfc_all_grids,:)=a_sfc(2,1:nonods_sfc_all_grids,:) + 0.25*ml_sfc(1:nonods_sfc_all_grids,:) ! 0.25 does not work for 200 elements across
            !      a_sfc(2,:,:)=a_sfc(2,:,:) + 0.2*ml_sfc(:,:) ! 0.2 does not work for 200 elements across
            !      a_sfc(2,:,:)=a_sfc(2,:,:)*1.1 ! 1.1 does not work for 200 elements across
            !      a_sfc(2,:,:)=a_sfc(2,:,:)*2.0 ! 1.1 works for 200 elements across
            
            ! solve the system a_no_bc*psi_no_bc = b_no_bc
                    allocate(psi_no_bc(nonods_no_bc), psi_no_bc_guess(nonods_no_bc))
            !        nits=2
                    nits=2500
                    allocate(relax(nlevel))
                    allocate(relax_down(nlevel))
            !        relax(:)=0.6 ! works slightly rough
            !        relax(:)=0.7 ! too rough
            !        relax(:)=0.5
            !        relax(:)=1.35 !optimal
            !        relax(1)=1.35
                    relax(:)=1.35
            !        relax(1)=1.4
            !        relax(:)=1.
            !        relax(1)=1.
                    relax_down(:)=1.0
                    optimal_relax=.true.
                    psi_no_bc=0.0
                    vcycle = 0
            !        fcycle = 1 ! nice new method
                    fcycle = 0
                    allocate(max_psi_no_bc(nits))
                    do its=1,nits
            ! 
                      if(optimal_relax) then ! optimised relaxation method
                       if(2*(its/2) == its) then
            !           if((2*(its/2) == its).or.(3*(its/3) == its)) then
            !              relax(:)=1.7 
                          relax(:)=1.9 ! the best with 1.
                          relax(1)=2.1 ! the best with 1.
                          relax(:)=relax(:)*0.99
            !              relax(:)=relax(:)*0.97 ! works for 129x129 not work for 513x513
            !              relax(:)=relax(:)*0.95 ! not work for 513x513
            !              relax(:)=relax(:)*0.93 ! oscillatory for 513x513
                          if(iuse_starting_node==-1) relax(:)=relax(:)*0.9 ! reduce if we are using rapid SFC generation.
            !              relax(:)=relax(:)*0.8
                       else
                          relax(:)=1.0
                       endif
                       if(96*(its/96) == -its) then
            !           if(48*(its/48) == its) then
                          relax(:)=1.0
                       endif
                      endif
            ! 
                           
            !           do icurve=2,2
                       do icurve=1,ncurve
                          psi_no_bc_guess=psi_no_bc
                          if(nfilt_size_sfc==0) then ! sparse matrix soln (no approx of multi-grid matrices)
            !              if(.false.) then
                            if(vcycle==1) then
                             relax(:)=1.0
                             relax_down(:)=relax(:) 
                             call sfc_solver_it_unstructured_vcycle(psi_no_bc, psi_no_bc_guess, a_sfc_all_un(:,icurve), &
                                             fina_sfc_all_un(:,icurve), cola_sfc_all_un(:,icurve), &
                                             ncola_sfc_all_un(icurve), fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, relax_down, &
                                             fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix)  
                            else if(fcycle==1) then
            !                 do isweep=2,2 ! orginal method
                             do isweep=1,2
                             istart=nlevel-1
                             ifinish=1
                             istep=-1
                             if(isweep==1) then
                                istart=2
                                ifinish=nlevel-1
                                istep=1
                             endif
                             do top_level=nlevel-1,1,-1
            !           if(2*((top_level+its)/2) == top_level+its) then
                       if(2*((top_level)/2) == top_level) then
            !           if((2*(its/2) == its).or.(3*(its/3) == its)) then
            !              relax(:)=1.7 
                          relax(:)=1.9 ! the best with 1.
                          relax(1)=2.1 ! the best with 1.
                          relax(:)=relax(:)*0.99
            !              relax(:)=relax(:)*0.95
                       else
                          relax(:)=1.0
                       endif
                       if(4*(its/4) == -its) then
            !           if(48*(its/48) == its) then
                          relax(:)=1.0
                       endif
            !                 top_level=1
            !                 relax(:)=1.0
            !                 relax_down(:)=relax(:) 
                             psi_no_bc_guess=psi_no_bc
                             call sfc_solver_it_unstructured_fcycle(psi_no_bc, psi_no_bc_guess, a_sfc_all_un(:,icurve), &
                                             fina_sfc_all_un(:,icurve), cola_sfc_all_un(:,icurve), &
                                             ncola_sfc_all_un(icurve), fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix, &
                                             top_level)
                             end do
                             end do
                            else 
                             call sfc_solver_it_unstructured(psi_no_bc, psi_no_bc_guess, a_sfc_all_un(:,icurve), &
                                             fina_sfc_all_un(:,icurve), cola_sfc_all_un(:,icurve), &
                                             ncola_sfc_all_un(icurve), fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix)
                            endif  
                          else if(nfilt_size_sfc==3) then
            !              if(.false.) then
                             call sfc_solver_it_3(psi_no_bc, psi_no_bc_guess, a_sfc(:,:,icurve), fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix, &
                                             nfilt_size_sfc)  
                          else
                             call sfc_solver_it_n(psi_no_bc, psi_no_bc_guess, a_sfc(:,:,icurve), fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, ncurve_space_fill_curve_numbering(:,icurve), &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix, &
                                             nfilt_size_sfc)  
                          endif
                       end do
                       max_psi_no_bc(its)=maxval(psi_no_bc)
                       print *,'its,relax(1),max_psi_no_bc(its):',its,relax(1),max_psi_no_bc(its)
                    end do ! do its=1,nits
            ! 
                    open(4, file='sfc-its-error.csv')
            !        do its=1,nits
                    do its=1,min(300,nits)
            !        do its=1,min(2000,nits)
                       write(4,*) real(its), abs( max_psi_no_bc(nits) - max_psi_no_bc(its) )
                    end do
            ! map to original ordering psi_no_bc
                    allocate(psi(nonods))
                    psi=0.0
                    do inod=1,nonods
                      inod_new = map2_no_bc_nodes(inod)
                       if(inod_new.ne.0) psi(inod) = psi_no_bc(inod_new) ! not a b.c. node. 
                    end do
            ! print the soln...
                  if(.false.) then
                    do j=1,ny
                       print *,'j,psi:',j,(psi(inod),inod=(j-1)*nx+1,(j-1)*nx+nx)
                    end do
                  endif
                    open(3, file='sfc-2d-1d.csv')
                    j=ny/2 
                    do i=1,nx
                       inod=(j-1)*nx+i 
                       write(3,*) real(i-1)*dx, psi(inod)
                    end do
                    close(3)
            ! 
                    stop 1928
                    end subroutine main7
            ! 
            ! 
            ! 
            ! The python interface is:
            ! full_super_nonods = length_full_super_sfc(super_nonods, ndim_hilbert)
                    subroutine length_full_super_sfc(full_super_nonods, super_nonods, ndim_hilbert)
                    implicit none
                    integer, intent( in ) :: super_nonods, ndim_hilbert
                    integer, intent( out ) :: full_super_nonods
            ! Local variables...
                    integer ii,nx
            ! 
                    if(ndim_hilbert==1) then ! 1d curve trivial outcomes...
                       full_super_nonods=super_nonods
                    else ! 2d or 3D Hilbert curve
                       do ii=0,100
                          nx=2**ii
                          full_super_nonods=nx**ndim_hilbert
                          if(full_super_nonods.ge.super_nonods) exit
                       end do
                    endif
                    return 
                    end subroutine length_full_super_sfc
            ! 
            ! 
            ! 
            ! The python interface is:
            ! full_super_sfc_node_ordering_inverse = full_combine_sfcs( &
            !                 super_sfc_node_ordering_inverse, super_nonods, full_super_nonods)
                    subroutine full_combine_sfcs(full_super_sfc_node_ordering_inverse, &
                             super_sfc_node_ordering_inverse, super_nonods, full_super_nonods) 
            ! calculate the full_super_sfc_node_ordering_inverse from super_sfc_node_ordering_inverse 
            ! and the lengths of these variables super_nonods, full_super_nonods
            ! It does this by tracing the super_sfc_node_ordering_inverse forwards then backwards 
            ! filling in full_super_sfc_node_ordering_inverse until full_super_nonods are used up. 
                    implicit none
                    integer, intent( in ) :: super_nonods, full_super_nonods
                    integer, intent( in ) :: super_sfc_node_ordering_inverse(super_nonods)
                    integer, intent( out ) :: full_super_sfc_node_ordering_inverse(full_super_nonods)
            ! local variables...
                    integer iforward_backward, istart, ifinish, istep, ifull_super_nod, isuper_nod
                    logical done
                    ifull_super_nod=0
                    do iforward_backward=1,1000
                       if( 2*(iforward_backward/2) == iforward_backward) then
                          istart=super_nonods-1
                          ifinish=1
                          istep=-1
                       else
                          istart=1
                          ifinish=super_nonods
                          istep=1
                       endif
            !              print *,'istart=',istart
                       done=.false.
                       do isuper_nod=istart, ifinish, istep
                          ifull_super_nod=ifull_super_nod+1
                          full_super_sfc_node_ordering_inverse(ifull_super_nod) &
                             =super_sfc_node_ordering_inverse(isuper_nod)
                          if(ifull_super_nod==full_super_nonods) then
                            done=.true.
                            exit
                         endif
                       end do
                       if(done) exit
                    end do
            !            print *,'full_super_nonods, super_nonods, ndim_hilbert:', &
            !                     full_super_nonods, super_nonods, ndim_hilbert 
            !            print *,'full_super_sfc_node_ordering_inverse:', &
            !                     full_super_sfc_node_ordering_inverse
                    return 
                    end subroutine full_combine_sfcs
            ! 
            ! 
            ! The python interface is: 
            ! super_sfc_node_ordering_inverse, super_nonods = combine_sfcs( &
            !                         sfc_node_ordering,nonods,ncurve) 
                    subroutine combine_sfcs(super_sfc_node_ordering_inverse, super_nonods, &
                                     sfc_node_ordering,nonods,ncurve)
            ! this subroutine combines SFCs and with ncurve of them. 
            ! sfc_node_ordering(fem node number)=i_sfc_order. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
                    implicit none
                    integer, intent( in ) :: nonods,ncurve
                    integer, intent( in ) :: sfc_node_ordering(nonods,ncurve)
                    integer, intent( out ) :: super_sfc_node_ordering_inverse(2*ncurve*nonods)
                    integer, intent( out ) :: super_nonods
            ! local variables...
                    integer, allocatable :: sfc_node_ordering_inverse(:,:)
                    integer, allocatable :: connect_start_sfc(:,:),connect_finish_sfc(:,:)
                    integer icurve,jcurve, inod,inod_sfc
                    integer inod_icurve,inod_jcurve, inod_jcurve_sfc
                    integer isuper_nod_sfc
            ! 
                    allocate(sfc_node_ordering_inverse(nonods,ncurve))
                    allocate(connect_start_sfc(ncurve,ncurve),connect_finish_sfc(ncurve,ncurve))
                    do icurve=1,ncurve
                       do inod=1,nonods
                          inod_sfc = sfc_node_ordering(inod,icurve) 
                          sfc_node_ordering_inverse(inod_sfc,icurve) = inod
                       end do 
                    end do 
            ! 
            ! Limited brute force search for the best ordering in terms of path length minimum.
            ! Just switch around from the start and finish. 
                    icurve=1
                    super_sfc_node_ordering_inverse(1:nonods)=sfc_node_ordering_inverse(1:nonods,icurve)
                    isuper_nod_sfc=nonods
                    jcurve=icurve+1
                    do inod_sfc=nonods-1,1,-1 ! trace back to node 1 of next SFC... 
                       inod_icurve = sfc_node_ordering_inverse(inod_sfc,icurve)
                       inod_jcurve_sfc = sfc_node_ordering(inod_icurve,jcurve)
                       isuper_nod_sfc = isuper_nod_sfc + 1
                       super_sfc_node_ordering_inverse(isuper_nod_sfc)=inod_icurve
                       if(inod_jcurve_sfc==1) exit
                    end do
            ! 
            ! for second SFC...
                    icurve=2
                    do inod_sfc=2,nonods ! trace forward from SFC node 1... 
                       inod_icurve = sfc_node_ordering_inverse(inod_sfc,icurve)
                       isuper_nod_sfc = isuper_nod_sfc + 1
                       super_sfc_node_ordering_inverse(isuper_nod_sfc)=inod_icurve
                    end do
            ! now trace back to node 1 of next SFC.
                    if(ncurve==3) then
                       jcurve=icurve+1 
                       do inod_sfc=nonods-1,1,-1 ! trace back to node 1 of next SFC... 
                          inod_icurve = sfc_node_ordering_inverse(inod_sfc,icurve)
                          inod_jcurve_sfc = sfc_node_ordering(inod_icurve,jcurve)
                          isuper_nod_sfc = isuper_nod_sfc + 1
                          super_sfc_node_ordering_inverse(isuper_nod_sfc)=inod_icurve
                          if(inod_jcurve_sfc==1) exit
                       end do
            ! for second SFC...
                       icurve=3
                       do inod_sfc=2,nonods ! trace back to node 1 of next SFC... 
                          inod_icurve = sfc_node_ordering_inverse(inod_sfc,icurve)
                          isuper_nod_sfc = isuper_nod_sfc + 1
                          super_sfc_node_ordering_inverse(isuper_nod_sfc)=inod_icurve
                       end do
                    endif ! if(ncurve==3) then
                    super_nonods=isuper_nod_sfc
            ! 
                    return
                    end subroutine combine_sfcs
            ! 
            ! 
            ! 
            ! 
            ! The python interface is called from python with:
            !     xc,yc, mesh_functional, voronoi_cell_connect, number_voronoi_cells = voronoi_cell_functional_and_pts(
            !                                             color, dx, dy, desired_edge_length, &
            !                                             nx,ny, max_voronoi_cells, max_connect ) 
                      subroutine voronoi_cell_functional_and_pts(xc,yc, mesh_functional, &
                                                         voronoi_cell_connect, number_voronoi_cells, &
                                                         color, dx, dy, desired_edge_length, &
                                                         nx,ny, max_voronoi_cells, max_connect ) 
                      implicit none
            ! mesh_functional: This subdoutine calculates the quality if the triangle mesh mesh_functional from 
            ! a grid gof pixes of different color defined by color(i,j)=colour of pixel (integer) and 
            ! the grid or image has dimensions (nx,ny) - number of cells across and down respectively. 
            ! xc,yc: It calculates the centres of mass of the Voronoi cells (xc(icell),yc(icell)) in which icell 
            ! is the cell number. 
            ! number_voronoi_cells: It calculates the number of Voronoi cells number_voronoi_cells. 
            ! dx, dy: are the dimensions of the cells. 
            ! desired_edge_length is the desired edge length of the triangles. 
            ! max_voronoi_cells contains the maximum number of Voronoi cells in the image. 
            ! max_connect is the maximum number of Voronoi cells surrounding (next too) a given Voronoi cell. 
            ! voronoi_cell_connect(icell, jj)= the jj^th index to a aurrounding Voronoi cell of cell icell. 
            ! voronoi_cell_connect(icell, jj) contains a non-zero only up to the number jj of surrounding 
            ! Voronoi cells otherwise it contains 0. 
                      integer, intent(in) :: nx,ny, max_voronoi_cells, max_connect
                      real, intent(out) :: xc(max_voronoi_cells), yc(max_voronoi_cells)
                      real, intent(out) :: mesh_functional
                      integer, intent(out) :: voronoi_cell_connect(max_voronoi_cells,max_connect)
                      integer, intent(out) :: number_voronoi_cells
                      real, intent(in) :: dx, dy, desired_edge_length
                      integer, intent(in) :: color(nx,ny)
            ! Local variables
                      integer, allocatable :: mark_centre_extend(:,:), mark_voronoi_no_all_extend(:,:)
                      integer, allocatable :: color_extend(:,:), color2_extend(:,:), boundary_extend(:,:)
                      integer, allocatable :: xy_count(:), voronoi_cell_color(:) 
                      integer i,j, ii,jj, idiff2_color, iswitch, idiff_bound, iconnect, imax, ivor
                      integer idiff_color, idiff_mark, imax_mark, jvoronoi, ivoronoi, its,nits
            ! 
                      allocate(color_extend(0:nx+1,0:ny+1), color2_extend(0:nx+1,0:ny+1))
                      allocate(mark_centre_extend(0:nx+1,0:ny+1))
                      allocate(mark_voronoi_no_all_extend(0:nx+1,0:ny+1))
                      allocate(boundary_extend(0:nx+1,0:ny+1))
                      allocate(voronoi_cell_color(max_voronoi_cells))
            ! extend the values to produce borders...
                      call extend_2_borders(color_extend,color,nx,ny) 
            ! 
            ! indicator of the boundaries
                      boundary_extend(:,:)=1 
                      boundary_extend(1:nx,1:ny)=0 
            ! 
                      nits=2*max(nx,ny)
            ! 
            ! Shrink the Voronoi cell colours to a single point. 
                      color2_extend(:,:)=0
                      mark_centre_extend(:,:)=0
                      number_voronoi_cells=0
                      do its=1,nits
                         do i=1,nx
                         do j=1,ny 
                            if(color2_extend(i,j)==0) then ! define color2_extend(i,j)
                               idiff_color =0 
                               idiff_bound =0
                               idiff2_color=0 
                               iswitch=0
                               do jj=-1,1
                               do ii=-1,1
                                  idiff_color  = idiff_color &
                                    + (1-boundary_extend(i+ii,j+jj))*min(1, abs( color_extend(i,j)-color_extend(i+ii,j+jj) )  )
                                  idiff_bound = idiff_bound + boundary_extend(i+ii,j+jj)
                                  if( (1-boundary_extend(i+ii,j+jj))*(its-color2_extend(i+ii,j+jj)) == 1 ) then
                                     if( ii*jj .ne. 0 ) then
                                     if( color_extend(i,j)-color_extend(i+ii,j+jj) == 0 ) then
                                        iswitch=1
                                     endif
                                     endif
                                  endif
                                  idiff2_color = idiff2_color + (1-boundary_extend(i+ii,j+jj))*min(1, color2_extend(i+ii,j+jj) )
                               end do
                               end do
                               if(its==1) then
                                  if(idiff_color.ge.1) color2_extend(i,j)=1
                               else 
                                  if(iswitch==1) color2_extend(i,j)=its
                               endif
                               if(color2_extend(i,j).ne.0) then
            ! is color issolated then if so its a centre of a Voronoi cell. 
                                  if(idiff2_color+idiff_bound==8) then ! cell surrounded by claimed cells
                                     number_voronoi_cells=number_voronoi_cells+1
                                     mark_centre_extend(i,j)=number_voronoi_cells
                                     voronoi_cell_color(number_voronoi_cells)=color_extend(i,j)
                                  endif
                               endif ! if(color2_extend(i,j).ne.0) then
                            endif ! if(color2_extend(i,j).ne.0) then
                         end do
                         end do
                         call extend_2_borders_only( color2_extend, color2_extend, nx,ny) 
                      end do
                   if(.true.) then
                      print *,'number_voronoi_cells:',number_voronoi_cells
            ! 
                      print *,'color_extend:'
                      do j=0,ny+1
                         print *,'j,color_extend(:,j):',j,':',color_extend(:,j)
                      end do
            !
                      print *,'color2_extend:'
                      do j=0,ny+1
                         print *,'j,color2_extend(:,j):',j,':',color2_extend(:,j)
                      end do
            ! 
                      print *,'mark_centre_extend:'
                      do j=1,ny
                         print *,'j,mark_centre_extend(:,j):',j,':',mark_centre_extend(:,j)
                      end do
                   endif
            !          stop 292
            ! 
            ! Grow the cells from their centre.  mark_voronoi_no_all(i,j) = voronoi cell number for cell (i,j). 
                      mark_voronoi_no_all_extend(:,:)=mark_centre_extend(:,:)
                      do its=1,nits
                         do j=1,ny 
                         do i=1,nx
                            if(mark_voronoi_no_all_extend(i,j)==0) then ! define mark_voronoi_no_all_extend(i,j)
                               idiff_color=0 
            !                   idiff_mark=0 
                               imax_mark=0 
                               do jj=-1,1
                               do ii=-1,1
                                  idiff_color  = idiff_color + min(1, abs( color_extend(i,j)-color_extend(i+ii,j+jj) )  )
            !                      idiff_mark = idiff_mark &
            !                       + abs( mark_voronoi_no_all_extend(i,j)-mark_voronoi_no_all_extend(i+ii,j+jj) )
                                  if(color_extend(i,j)-color_extend(i+ii,j+jj)==0) imax_mark = &
                                         max(imax_mark, mark_voronoi_no_all_extend(i+ii,j+jj))
            !                      imax_mark = max(imax_mark, mark_voronoi_no_all(i+ii,j+jj))
                               end do
                               end do
            ! Have at least one color of the same colour next to cell (i,j) i.e. idiff_color.le.7
                               if(idiff_color.le.7) then
                                  mark_voronoi_no_all_extend(i,j)=imax_mark
                               endif
                            endif ! if(mark_voronoi_no_all_extend(i,j)==0) then
                         end do
                         end do
                         call extend_2_borders_only( mark_voronoi_no_all_extend, mark_voronoi_no_all_extend, nx,ny) 
                      end do
            ! 
                   if(.true.) then
                      print *,'dx,dy:',dx,dy
            ! 
                      print *,'mark_voronoi_no_all_extend:'
                      do j=1,ny
                         print *,'j,mark_voronoi_no_all_extend(:,j):',j,':',mark_voronoi_no_all_extend(:,j)
                      end do
            !          stop 2821
                   endif
            ! 
            ! Work out real centre of mass of each voronoi cell.
                    print *,'here0'
                      allocate(xy_count(number_voronoi_cells))
                      xc(1:number_voronoi_cells)=0.0
                      yc(1:number_voronoi_cells)=0.0
                      xy_count=0
                      do j=1,ny 
                      do i=1,nx
            !             print *,'i,j:',i,j
                         ivoronoi = mark_voronoi_no_all_extend(i,j) 
                         xc(ivoronoi)=xc(ivoronoi)+ dx*real(i-1) + 0.5*dx
                         yc(ivoronoi)=yc(ivoronoi)+ dy*real(j-1) + 0.5*dy
                         xy_count(ivoronoi)=xy_count(ivoronoi)+1
                      end do
                      end do
                      xc(1:number_voronoi_cells)=xc(1:number_voronoi_cells)/real( xy_count(1:number_voronoi_cells) )
                      yc(1:number_voronoi_cells)=yc(1:number_voronoi_cells)/real( xy_count(1:number_voronoi_cells) )
                      print *,'here1'
            ! 
            ! Make a connectivity list...
                      voronoi_cell_connect=0 
                      do j=1,ny 
                      do i=1,nx
                         do jj=-1,1
                         do ii=-1,1
                            if(abs( mark_voronoi_no_all_extend(i,j)-mark_voronoi_no_all_extend(i+ii,j+jj) )>0) then ! add to connectivity list
                               call put_in_connect_for_voronoi_cell( &
                                         voronoi_cell_connect(mark_voronoi_no_all_extend(i,j),:), &
                                         mark_voronoi_no_all_extend(i+ii,j+jj), max_connect) 
                            endif
                         end do
                         end do
                      end do
                      end do
                      print *,'here2'
            ! 
            ! Calculate the functional mesh_functional which says what the quality of the mesh is. 
                      mesh_functional=0.0
                      do ivoronoi=1,number_voronoi_cells
                         do jj=1,max_connect
                            jvoronoi=voronoi_cell_connect(ivoronoi,jj)
                            if(jvoronoi==0) exit
                            if(jvoronoi.ne.ivoronoi) then
                               mesh_functional = mesh_functional &
                               + (sqrt((xc(jvoronoi)-xc(ivoronoi))**2 + (yc(jvoronoi)-yc(ivoronoi))**2) &
                                    - desired_edge_length)**2
                            endif
                         end do
                      end do
                      mesh_functional = mesh_functional / real(number_voronoi_cells)
                      print *,'here3'
                      do ivor=1,number_voronoi_cells
                         print *,'ivor,xc(ivor),yc(ivor):',ivor,xc(ivor),yc(ivor)
                         imax=0
                         do iconnect=max_connect,1,-1
                            if(voronoi_cell_connect(ivor,iconnect)==0) imax=iconnect
                         end do
                         print *,'voronoi_cell_connect(ivor,:):', &
                             (voronoi_cell_connect(ivor,iconnect),iconnect=1,imax-1)
                      end do
                      print *,'here4'
                      return
                      end subroutine voronoi_cell_functional_and_pts
            ! 
            ! 
            ! 
            ! 
                      subroutine extend_2_borders(color_extend,color,nx,ny) 
            ! extend the values to produce borders...
            ! if only_boundaries==0 then update the interior else only update the boundaries
                      integer, intent(in) :: nx,ny
                      integer, intent(in) :: color(nx,ny)
                      integer, intent(out) :: color_extend(0:nx+1,0:ny+1)
            ! 
                      color_extend(1:nx,1:ny)=color(1:nx,1:ny)
            ! 4 boundaries...
                      color_extend(0,1:ny)=color(1,1:ny)
                      color_extend(nx+1,1:ny)=color(nx,1:ny)
                      color_extend(1:nx,0)=color(1:nx,1)
                      color_extend(1:nx,ny+1)=color(1:nx,ny)
            ! 4 corners...
                      color_extend(0,0)=color(1,1)
                      color_extend(nx+1,ny+1)=color(nx,ny)
                      color_extend(nx+1,0)=color(nx,1)
                      color_extend(0,ny+1)=color(1,ny)
                      return
                      end subroutine extend_2_borders
            ! 
            ! 
            ! 
                      subroutine extend_2_borders_only(color_extend,color,nx,ny) 
            ! extend the values to produce borders only...
            ! if only_boundaries==0 then update the interior else only update the boundaries
                      integer, intent(in) :: nx,ny
                      integer, intent(in) :: color(0:nx+1,0:ny+1)
                      integer, intent(out) :: color_extend(0:nx+1,0:ny+1)
            ! 
            ! 4 boundaries...
                      color_extend(0,1:ny)=color(1,1:ny)
                      color_extend(nx+1,1:ny)=color(nx,1:ny)
                      color_extend(1:nx,0)=color(1:nx,1)
                      color_extend(1:nx,ny+1)=color(1:nx,ny)
            ! 4 corners...
                      color_extend(0,0)=color(1,1)
                      color_extend(nx+1,ny+1)=color(nx,ny)
                      color_extend(nx+1,0)=color(nx,1)
                      color_extend(0,ny+1)=color(1,ny)
                      return
                      end subroutine extend_2_borders_only
            ! 
            ! 
            ! 
            ! 
                     subroutine put_in_connect_for_voronoi_cell(voronoi_cell_connect, &
                                  mark_voronoi_no_nab, max_connect) 
            ! Insert mark_voronoi_no_nab into the list voronoi_cell_connect if its not already in it. 
                     implicit none
                     integer, intent(in) :: max_connect
                     integer, intent(in) :: mark_voronoi_no_nab
                     integer, intent(out) :: voronoi_cell_connect(max_connect)
            ! local variables...
            !         logical found
                     integer i,ikeep
            ! 
            !         found = .false.
                     ikeep=0
                     do i=1,max_connect
                        if(voronoi_cell_connect(i)==0) then
                           ikeep=i
                           exit
                        endif
                        if(voronoi_cell_connect(i)==mark_voronoi_no_nab) then ! found this cell already in list
            !               found=.true.
                           exit
                        endif
                     end do
                     if(ikeep.ne.0) then
                        voronoi_cell_connect(ikeep)=mark_voronoi_no_nab
                     endif
            
                     return
                     end subroutine put_in_connect_for_voronoi_cell
            ! 
            ! 
            !           
            ! 
                      subroutine ncurve_python_subdomain_space_filling_curve_stub( ncurve_whichd,  &
                       ncurve_space_fill_curve_numbering,  cola,fina, iuse_starting_node, &
                       graph_trim, ncurve, nonods,ncola)
            ! *******************************************************************************************************
            ! This subroutine uses nested disection of the domain into subdomains in order to form 
            ! a space filling curve: space_fill_curve_numbering. whichd contains the subdomain ordering.
            ! It also form ncurve space filling curves and puts them in ncurve_space_fill_curve_numbering(nod,icurve)
            ! in which nod is the node number (original) and icurve is the space filling curve number.
            ! If iuse_starting_node>0 then use the starting node from the end of the previous space filling curve. 
            ! abs(graph_trim) is the graph trimming option for >1 space filling curve numbers. 
            ! abs(graph_trim)>3 and <9 are use all the graph trimming (original method).
            ! if graph_trim<0 use a matrix a and set to large values the graph weights we want to discoursage going through.
            !          no_trim=.false.; trimmed_graph_for_decomposition_only=.false.; trimmed_graph_for_reorder_only=.false.
            !          duplicate=.false.; got_a_matrix=.false.
            !          if(abs(graph_trim)==0).or.(abs(graph_trim)==10)) no_trim=.true.
            !          if((abs(graph_trim)==1).or.(abs(graph_trim)==2)) then
            !             trimmed_graph_for_decomposition_only=.true.
            !             if(abs(graph_trim)==1) duplicate=.true.
            !          endif
            !          if(abs(graph_trim)==3) trimmed_graph_for_reorder_only=.true.
            ! abs(trim_graph)=0 or abs(graph_trip)10 dont trim graph. 
            ! graph_trim=1 then extended cola to duplicate connections and mimick greater weights for domain decomp only.
            ! graph_trim=2 trim graph only for domain decomposition
            ! graph_trim=3 trim graph only for re-ordering optimization (no as good) 
            ! graph_trim>=4 trim graph for decomposition and reordering. 
            ! *******************************************************************************************************
                      implicit none
                      INTEGER, INTENT(IN) :: iuse_starting_node, graph_trim, ncurve, nonods,ncola
                      INTEGER, INTENT(out) :: ncurve_whichd(nonods,ncurve)
                      INTEGER, INTENT(out) :: ncurve_space_fill_curve_numbering(nonods,ncurve)
                      INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                      print *,'should not be running it like this stopping'
                      print *,'call the subroutine ncurve_python_subdomain_space_filling_curve '
                      print *,'and not ncurve_python_subdomain_space_filling_curve_stub'
                      stop 3921
                      return
                      end subroutine ncurve_python_subdomain_space_filling_curve_stub
            ! 
            ! 
            ! 
            ! The python interface is:
            !    add_ncurve_space_fill_curve_numbering, n_add_ncurve = add_sfc_for_matrix(
            !           ncurve_space_fill_curve_numbering,  cola,fina,  &
            !           ncurve, nonods,ncola, max_add_ncurve)
                      subroutine add_sfc_for_matrix(add_ncurve_space_fill_curve_numbering, &
                       n_add_ncurve, &
                       ncurve_space_fill_curve_numbering,  cola,fina,  &
                       ncurve, nonods,ncola, max_add_ncurve)
            ! *******************************************************************************************************
            ! This subroutine uses the SFCs to form the matricies and adds more SFCs to make up for 
            ! lack of variables within the matrix a. 
            ! It also form ncurve space filling curves and puts them in ncurve_space_fill_curve_numbering(nod,icurve)
            ! in which nod is the node number (original) and icurve is the space filling curve number.
            ! If iuse_starting_node>0 then use the starting node from the end of the previous space filling curve. 
            ! abs(graph_trim) is the graph trimming option for >1 space filling curve numbers. 
            ! abs(graph_trim)>3 and <9 are use all the graph trimming (original method).
            ! if graph_trim<0 use a matrix a and set to large values the graph weights we want to discoursage going through.
            !          no_trim=.false.; trimmed_graph_for_decomposition_only=.false.; trimmed_graph_for_reorder_only=.false.
            !          duplicate=.false.; got_a_matrix=.false.
            !          if(abs(graph_trim)==0).or.(abs(graph_trim)==10)) no_trim=.true.
            !          if((abs(graph_trim)==1).or.(abs(graph_trim)==2)) then
            !             trimmed_graph_for_decomposition_only=.true.
            !             if(abs(graph_trim)==1) duplicate=.true.
            !          endif
            !          if(abs(graph_trim)==3) trimmed_graph_for_reorder_only=.true.
            ! abs(trim_graph)=0 or abs(graph_trip)10 dont trim graph. 
            ! graph_trim=1 then extended cola to duplicate connections and mimick greater weights for domain decomp only.
            ! graph_trim=2 trim graph only for domain decomposition
            ! graph_trim=3 trim graph only for re-ordering optimization (no as good) 
            ! graph_trim>=4 trim graph for decomposition and reordering. 
            ! *******************************************************************************************************
                      implicit none
                      INTEGER, INTENT(in) :: max_add_ncurve
                      INTEGER, INTENT(IN) :: ncurve, nonods,ncola
                      INTEGER, INTENT(in) :: ncurve_space_fill_curve_numbering(nonods,ncurve)
                      INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                      INTEGER, INTENT(out) :: add_ncurve_space_fill_curve_numbering(nonods,max_add_ncurve)
                      INTEGER, INTENT(out) :: n_add_ncurve
            ! Local variables
                      integer, allocatable :: sfc_node_ordering_inverse(:,:),which_sfc_cola(:)
                      integer icurve,inod,inod_sfc,nfilter,jnod,jnod_sfc,count,jnod_look
                      integer acc_sfc,count2,inod2
                      print *,'inside add_sfc_for_matrix'
            ! ncurve_space_fill_curve_numbering(nod) = new node numbering from current node number nod.
                      allocate(sfc_node_ordering_inverse(nonods,ncurve))
                      allocate(which_sfc_cola(ncola))
                      do icurve=1,ncurve
                         do inod=1,nonods
                            inod_sfc = ncurve_space_fill_curve_numbering(inod,icurve) 
                            sfc_node_ordering_inverse(inod_sfc,icurve) = inod
                         end do 
                      end do
            ! 
                      nfilter=3
                      which_sfc_cola(:)=0
                      do icurve=1,ncurve
                         do inod_sfc=1,nonods
                            inod = sfc_node_ordering_inverse(inod_sfc,icurve)
                            do jnod_sfc=max(1,inod_sfc - nfilter/2), min(nonods,inod_sfc + nfilter/2)
                               jnod = sfc_node_ordering_inverse(jnod_sfc,icurve)
                               do count=fina(inod),fina(inod+1)-1
                                  jnod_look = cola(count)
                                  if(jnod==jnod_look) then
                                     if(which_sfc_cola(count)==0) then
                                        which_sfc_cola(count)=icurve
                                        do count2=fina(jnod),fina(jnod+1)-1 ! label the transpose...
                                           inod2=cola(count2)
                                           if(inod==inod2) which_sfc_cola(count2)=icurve
                                        end do
                                     endif
                                  endif
                               end do
                            end do ! do jnod_sfc=max(1,inod_sfc - nfilter/2), min(nonods,inod_sfc + nfilter/2)
                         end do ! do inod_sfc=1,nonods
                      end do ! do icurve=1,ncurve
            ! 
            ! do some counting...
                      print *,'nonods,ncola,nfilter=',nonods,ncola,nfilter
                      do icurve=0,ncurve
                         acc_sfc=0
                         do count=1,ncola
                            if(which_sfc_cola(count)==icurve) acc_sfc=acc_sfc+1
                         end do
                         print *,'icurve,acc_sfc:',icurve,acc_sfc
                      end do
            ! 
            ! Add some more SFC curves...
                      print *,'max_add_ncurve:',max_add_ncurve
                      add_ncurve_space_fill_curve_numbering(:,:)=0 
                      do icurve=1,max_add_ncurve
                         print *,'*** icurve=',icurve
                         acc_sfc=0
                         do inod=1,nonods
                            do count=fina(inod),fina(inod+1)-1
                               jnod = cola(count)
                               if(which_sfc_cola(count)==0) then 
            ! try to make inod and jnod two consecutuve nodes in the sfc. 
                                  inod_sfc = add_ncurve_space_fill_curve_numbering(inod,icurve) 
                                  jnod_sfc = add_ncurve_space_fill_curve_numbering(jnod,icurve) 
                                  if((inod_sfc==0).and.(jnod_sfc==0)) then ! make both on SFC...
                                     acc_sfc = acc_sfc + 1
                                     add_ncurve_space_fill_curve_numbering(inod,icurve)=acc_sfc
                                     acc_sfc = acc_sfc + 1
                                     add_ncurve_space_fill_curve_numbering(jnod,icurve)=acc_sfc
                                     which_sfc_cola(count)=-icurve
                                     do count2=fina(jnod),fina(jnod+1)-1 ! label the transpose...
                                        inod2=cola(count2)
                                        if(inod==inod2) which_sfc_cola(count2)=-icurve
                                     end do
                                  endif ! if(jnod_sfc==0) then
                               endif ! if(which_sfc_cola(count)==0) then 
                            end do ! do count=fina(inod),fina(inod+1)-1
                         end do ! do inod=1,nonods
                         print *,'nonods,acc_sfc:',nonods,acc_sfc
                         if(acc_sfc==0) then
                            n_add_ncurve=icurve-1
                            exit
                         endif
            ! fill in the rest of the SFC...
                         do inod=1,nonods
                            if(add_ncurve_space_fill_curve_numbering(inod,icurve)==0) then
                               acc_sfc = acc_sfc + 1
                               add_ncurve_space_fill_curve_numbering(inod,icurve)=acc_sfc
                            endif
                         end do
                         print *,'should be the same ::: nonods,acc_sfc:',nonods,acc_sfc
                      end do ! do icurve=1,max_add_ncurve
                      print *,'n_add_ncurve=',n_add_ncurve
                      
                      stop 3923
                      return
                      end subroutine add_sfc_for_matrix
            !  
            ! 
            ! 
            ! 
                    subroutine remove_bc_nodes_a_b(a_no_bc, b_no_bc, ml_no_bc, fina_no_bc, cola_no_bc, ncola_no_bc, &
                               map2_no_bc_nodes, a, b, ml, fina, cola,ion_boundary, nonods_no_bc, ncola, nonods) 
            ! this subroutine takes away the b.c.s from the matrix eqns and forms 
                    integer, intent( in ) :: nonods_no_bc, ncola, nonods
                    integer, intent( out ) :: ncola_no_bc
                    real, intent( out ) :: a_no_bc(ncola), b_no_bc(nonods_no_bc), ml_no_bc(nonods_no_bc)
                    integer, intent( out ) :: fina_no_bc(nonods_no_bc+1), cola_no_bc(ncola)
                    integer, intent( out ) :: map2_no_bc_nodes(nonods)
                    real, intent( in ) :: a(ncola), b(nonods), ml(nonods)
                    integer, intent( in ) :: fina(nonods+1), cola(ncola), ion_boundary(nonods)
            ! local variables...
                    integer inod,inod_new, jcol,jcol_new, count,count2
            !  
                    map2_no_bc_nodes=0
                    inod_new=0
                    do inod=1,nonods
                       if(ion_boundary(inod)==0) then ! not on boundary of domain
                          inod_new=inod_new+1
                          map2_no_bc_nodes(inod)=inod_new
                       endif
                    end do
                    print *,'inod_new:',inod_new
            ! Take away boundary nodes...
                    count2=0
                    do inod=1,nonods
                       inod_new=map2_no_bc_nodes(inod)
                       if(inod_new.ne.0) then
                          b_no_bc(inod_new)=b(inod)
                          ml_no_bc(inod_new)=ml(inod)
                          fina_no_bc(inod_new)=count2+1
                          do count=fina(inod),fina(inod+1)-1
                             jcol=cola(count)
                             jcol_new=map2_no_bc_nodes(jcol)
                             if(jcol_new.ne.0) then
                                count2=count2+1
                                a_no_bc(count2)=a(count)
                                cola_no_bc(count2)=jcol_new
                             endif
                          end do
                       endif
                    end do
                    ncola_no_bc=count2
                    fina_no_bc(nonods_no_bc+1)=ncola_no_bc+1
                    return 
                    end subroutine remove_bc_nodes_a_b
            ! 
            ! 
            ! 
            ! 
            ! python interface: 
            ! filt_nxnx, filt_nnx, ml = filters_for_structured_mesh_dg(dx,ndim,nloc)
                    subroutine main4
                    implicit none
            ! this subroutine calculates filters for the 2D rectangular element and 
            ! the 3D hex element of dimensions dx.
            ! filt_nxnx is the filter for the diffusion/Laplacian operator. 
            ! filt_nnx is the filter for the derivatives in the x,y and z-directions. 
            ! ml contains the mass associated with the local nodes. 
            ! nloc=no of nodes per element
            ! ndim=no of dimensions 
            ! dx is the dimensions of the element - width, length, height. 
            ! For the arrays:
            ! filt_nxnx(3,3,1+(ndim-2)*2, nloc)
            ! filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
            ! The 3,3 is the dimensions of the filter in 2D. It needs to be a 3x3 array.
            ! NDIM is the number of dimensions ndim=2 in our case but will change to3 soon.
            ! nloc is the number of local noes in an element. So we produce a filter for each local node of an element - 4 in our case.
            ! nsign=1 or 2 and is 1 is we have a positive sign of the component of interest (idim that goes into
            ! the ndim part of the array) of the velocity. Its 2 if the component is negative. 
                    integer, parameter :: nsign=2,nloc=8,ndim=3 ! 3D
            !        integer, parameter :: nsign=2,nloc=4,ndim=2 ! 2D
                    real dx(ndim)
                    real filt_nxnx(3,3,1+(ndim-2)*2, nloc)
                    real filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
                    real ml(nloc)
            ! python interface: 
            ! filt_nxnx, filt_nnx, ml = filters_for_structured_mesh_dg(dx,ndim,nloc)
            ! local variables...
                    integer i,j,k,idim,isign,iloc
            ! 
                    dx=1.0
                    call filters_for_structured_mesh_dg(filt_nxnx, filt_nnx, ml, dx,ndim,nloc)
            
                    print *,'diffusion:'
                    do iloc=1,nloc
                       do k=1,1+2*(ndim-2)
                       do j=3,1,-1
                          print *,'j,iloc,filt_nxnx(:,j,k,iloc):',j,iloc,filt_nxnx(:,j,k,iloc)
                       end do
                       end do
                       print *,' '
                    end do
            ! 
            !        print *,' '
                    print *,'advection:'
                    do iloc=1,nloc
                    do isign=1,nsign
                    do idim =1,ndim
                       print *,' '
                       do k=1,1+2*(ndim-2)
                       do j=3,1,-1
                   print *,'j,idim,isign,iloc:',j,idim,isign,iloc 
                   print *,'filt_nnx(:,j,k,idim,isign,iloc):',filt_nnx(:,j,k,idim,isign,iloc)
                       end do
                       end do
                    end do
                    end do
                    end do
            
            
            !        print *,'filt_nxnx:',filt_nxnx
            !        print *,'filt_nnx:',filt_nnx
                    print *,'ml:',ml
                    stop 2829
                    end subroutine main4
            ! 
            ! 
            ! 
            !        programsubroutine main ! ann filter and simple code
                    subroutine main3 ! ann filter and simple code
                    implicit none
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
                    
            ! local variables...
            ! 2d:
            ! nx=no of nodes across, ny=no of nodes up. 
                    integer, parameter :: nx=11,ny=11, nonods=nx*ny, totele=(nx-1)*(ny-1)
                    integer, parameter :: nloc=4,sngi=3, ngi=9, ndim=2, &
                                          nface=4, max_face_list_no=2
                    integer, parameter :: ntime = 10
                    real, parameter :: dx=1.0, dy=1.0, dt=0.1 
            ! example of node ordering...
            !      7-----8-----9
            !      !     !     !
            !      !     !     !        
            !      4-----5-----6
            !      !     !     !
            !      !     !     !        
            !      1-----2-----3
                    real b(nonods), ml(nonods)
                    real k(ndim,nonods), sig(nonods), s(nonods), t_new(nonods), t_old(nonods)
                    real u(ndim,nonods)
                    real x_all(ndim,nloc*totele)
                    integer fina(nonods+1) 
                    integer ndglno(nloc*totele)
            ! filters for ann:
                    integer, allocatable :: cola(:) 
                    real, allocatable :: a(:),a_filter(:) 
                    integer npoly,ele_type, iloc,count, ncola
                    integer enx_i, eny_j, ele, i,j, ii,jj, iii,jjj, inod, jnod, itime
            ! 
                    ncola=9*nonods ! this is the maximum size of ncola it will be smaller. 
                    allocate(a(ncola),a_filter(ncola))
                    allocate(cola(ncola))
            ! 
                    print *,'here in main'
                    stop 23
            ! 
                    call set_up_grid_problem(t_old, t_new, x_all, ndglno, fina, cola, &
                                             dx, dy, ncola, nx, ny, nloc, ndim)
            
                    npoly=1
                    ele_type=1
                    k(:,:)=0.0; sig=0.0; s=0.0; u(1,:)=1.0; u(2,:)=1.0
            !        do inod=1,nonods
            !           if(
            !        end do
            ! in python:
            ! a, b = u2r.get_fe_matrix_eqn(x_all, u, k, sig, s, fina,cola, ncola, ndglno, nonods,totele,nloc, ndim, ele_type)
            ! ml = the lumped mass 
                    call get_fe_matrix_eqn(a,b, ml, k, sig, s, u, x_all, &
                                           fina,cola, ndglno,  &
                                           ele_type, ndim, totele,nloc, ncola,nonods) 
            ! this subroutine finds the matrix eqns A T=b - that is it forms matrix a and vector b and the soln vector is T 
            ! in python:
            ! a_filter = get_filter_matrix( a, ml, dt, fina,cola, ncola,nonods)
            ! This subroutine finds the matrix eqns a_filter = -M_L^{-1} ( -M_L + dt* A). 
            ! Time stepping can be realised with T^{n+1} = a_filter * T^n 
                    call get_filter_matrix(a_filter, a, ml, dt,  &
                                           fina,cola, ncola,nonods)
            
            ! in python:
            ! t_new = time_step_filter_matrix( t_old, a_filter, fina,cola, ncola,nonods)
                    do itime=1,ntime
            ! set bcs...
                       do j=1,ny
                       do i=1,nx
                          inod=(j-1)*nx+i
                          if((i==1).or.(i==nx)) t_old(inod)=0.0
                          if((j==1).or.(j==ny)) t_old(inod)=0.0
                       end do
                       end do
            
                       call time_step_filter_matrix(t_new, t_old, a_filter,   &
                                                    fina,cola, ncola, nonods)
                       t_old=t_new
                    end do
                    do j=ny,1,-1
                       print *,'j,t_new( (j-1)*nx+1: (j-1)*nx +nx):',j
                       print *,t_new( (j-1)*nx+1: (j-1)*nx +nx)
                    end do
                    stop 2922
                    end subroutine main3
            ! 
            ! 
            ! 
            ! 
                    subroutine cty_filter_orig ! ann filter and simple code
                    implicit none
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
                    
            ! local variables...
            ! 2d:
                    integer, parameter :: totele=1,nloc=4,snloc=2,sngi=3, ngi=9, ndim=2, &
                                          nface=4, max_face_list_no=2
            ! 3d:
            !        integer, parameter :: totele=1,nloc=8,snloc=4,sngi=9, ngi=27, ndim=3, &
            !                              nface=6, max_face_list_no=4
                    real :: n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi)
                    real :: face_sn(sngi,snloc,nface), face_sn2(sngi,snloc,max_face_list_no)
                    real :: face_snlx(sngi,ndim-1,snloc,nface), face_sweigh(sngi,nface) 
            ! local variables...
                    real, allocatable :: nx(:,:,:),detwei(:),inv_jac(:,:,:)
                    real, allocatable :: nxnx(:,:,:), nnx(:,:,:)
                    real, allocatable :: nxnx_all_dim(:,:,:,:)
            ! filters for ann:
                    real, allocatable :: afilt_nxnx(:,:,:,:),  afilt_nnx(:,:,:,:)
                    real, allocatable :: afilt_nxnx_all_dim(:,:,:,:,:)
                    real, allocatable :: x_loc(:,:), x_all(:,:)
                    integer npoly,ele_type,ele, iloc,jloc,idim
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k, gi, jdim
                    real rnorm
            
                    allocate(nx(ngi,ndim,nloc),detwei(ngi),inv_jac(ngi,ndim,ndim))
                    allocate(nxnx(ndim,nloc,nloc),nnx(ndim,nloc,nloc))
                    allocate(x_loc(ndim,nloc)) 
                    allocate(nxnx_all_dim(ndim,ndim,nloc,nloc))
            
            !         stop 3382
                    npoly=1
                    ele_type=1
            
            ! form the shape functions...
                    print *,'going into get_shape_funs_with_faces'
                    call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
            
                    allocate(x_all(ndim,totele*nloc)) 
            ! 
                    if(ndim==2) then
                      x_all(:,1)=(/-1.0,-1.0/)
                      x_all(:,2)=(/+1.0,-1.0/)
                      x_all(:,3)=(/-1.0,+1.0/)
                      x_all(:,4)=(/+1.0,+1.0/)
                    endif
                    if(ndim==3) then
                      x_all(:,1)=(/-1.0,-1.0,-1.0/)
                      x_all(:,2)=(/+1.0,-1.0,-1.0/)
                      x_all(:,3)=(/-1.0,+1.0,-1.0/)
                      x_all(:,4)=(/+1.0,+1.0,-1.0/)
            ! 2nd layer...
                      x_all(:,5)=(/-1.0,-1.0,+1.0/)
                      x_all(:,6)=(/+1.0,-1.0,+1.0/)
                      x_all(:,7)=(/-1.0,+1.0,+1.0/)
                      x_all(:,8)=(/+1.0,+1.0,+1.0/)
                    endif
            
            ! obtain 
            ! for filters...
                    do ele = 1, totele ! VOLUME integral
                         x_loc(:,:) = x_all(:,(ele-1)*nloc+1:ele*nloc)
                         call det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, INV_JAC )
            
                         nxnx=0.0
                         nnx=0.0
                         nxnx_all_dim=0.0
                         do iloc=1,nloc
                         do jloc=1,nloc
                               do idim=1,ndim
                      nxnx(idim,iloc,jloc) = sum( nx(:,idim,iloc)*nx(:,idim,jloc)*detwei(:) )
                      nnx(idim,iloc,jloc)  = sum( n(:,iloc)*nx(:,idim,jloc)*detwei(:) )
                                  do jdim=1,ndim
                      nxnx_all_dim(idim,jdim,iloc,jloc) = sum( nx(:,idim,iloc)*nx(:,jdim,jloc)*detwei(:) )
                                  end do
                               end do
            !                   do idim=1,1
            !                      nxnx(iloc,jloc) = nxnx(iloc,jloc) + sum( nx(:,idim,iloc)*nx(:,idim,jloc)*detwei(:) )
            !                   end do
                         end do
                         end do
                    end do
            ! 
            ! now calculate filters:
                    print *,'detwei:',detwei
                    print *,'weight:',weight
                    print *,' '
                    do gi=1,ngi
                      print *,'gi,idim,n(gi,:):',gi,n(gi,:)
                    end do
                    print *,' '
                    do idim=1,1!ndim
                    do gi=1,1!ngi
            !          if(idim==1) print *,'gi,idim,n(gi,:):',gi,idim,n(gi,:)
                      print *,'gi,idim,nlx(gi,idim,:):',gi,idim,nlx(gi,idim,:)
                      iloc=1
            !          print *,'iloc,nnx(idim,iloc,:):',iloc,nnx(idim,iloc,:)
                    end do
                    end do
                    print *,' '
                    do idim=1,1!ndim
                    do gi=1,1!ngi
            !          if(idim==1) print *,'gi,idim,n(gi,:):',gi,idim,n(gi,:)
            !          print *,'gi,idim,nlx(gi,idim,:):',gi,idim,nlx(gi,idim,:)
                      iloc=1
                      print *,'iloc,nnx(idim,iloc,:):',iloc,nnx(idim,iloc,:)
                    end do
                    print *,' '
                    end do
            !        stop 211
            !        do iloc=1,nloc
            !          print *,'iloc,nnx(1,iloc,:):',iloc,nnx(1,iloc,:)
            !        end do
                    allocate(afilt_nxnx(ndim,3,3,1+2*(ndim-2)), afilt_nnx(ndim,3,3,1+2*(ndim-2)) )
                    allocate(afilt_nxnx_all_dim(ndim,ndim,3,3,1+2*(ndim-2)))
                    afilt_nxnx=0.0
                    afilt_nnx =0.0
                    afilt_nxnx_all_dim=0.0
                    do iiblock=1,2
                    do jjblock=1,2
                    do kkblock=1,ndim-1
                       do ifil=1,2
                       do jfil=1,2
                       do kfil=1,ndim-1
            !              do iidim2=1,2
            !              do jjdim2=1,2
            !              do kkdim2=1,ndim-1
                             iloc=1 + (2-iiblock) +(2-jjblock)*2   + (ndim-2)*(2-kkblock)*4
            !                 jloc=iiblock +(jjblock-1)*2   + (kkblock-1)*4
                             jloc=ifil +(jfil-1)*2   + (kfil-1)*4
            !                 jloc=iidim2 +(jjdim2-1)*2 + (kkdim2-1)*4
                             i=ifil + (iiblock-1)*1
                             j=jfil + (jjblock-1)*1
                             k=kfil + (kkblock-1)*1
                             afilt_nxnx(:,i,j,k)  = afilt_nxnx(:,i,j,k)  + nxnx(:,iloc,jloc)
                             afilt_nnx(:,i,j,k) = afilt_nnx(:,i,j,k) + nnx(:,iloc,jloc)
                             afilt_nxnx_all_dim(:,:,i,j,k) = afilt_nxnx_all_dim(:,:,i,j,k)  &
                                                           + nxnx_all_dim(:,:,iloc,jloc)
            !              end do
            !              end do
            !              end do
                       end do
                       end do
                       end do
                    end do
                    end do
                    end do
            ! 
                    do idim=1,ndim
                       print *,'idim=',idim
                       do jloc=1,nloc
                          print *,'jloc,nxnx(idim,:,jloc):',jloc,nxnx(idim,:,jloc)
                       end do
                    end do
            ! 
                    do idim=1,ndim
                       print *,'idim=',idim
                       do k=1,1+2*(ndim-2)
                       do j=1,3
                          print *,'k,j,afilt_nxnx(idim,:,j,k):',k,j,afilt_nxnx(idim,:,j,k)
                       end do
                       end do
                    end do
            ! 
                    do idim=1,ndim
                    do jdim=1,ndim
                       print *,'idim,jdim=',idim,jdim
                       do k=1,1+2*(ndim-2)
                       do j=1,3
                          print *,'k,j,afilt_nxnx_all_dim(idim,jdim,:,j,k):',k,j,afilt_nxnx_all_dim(idim,jdim,:,j,k)
                       end do
                       end do
                    end do
                    end do
            !
            ! get rid of small values - round off error is an issue here. 
                    do idim=1,ndim
                       do k=1,1+2*(ndim-2)
                       do j=1,3
                       do i=1,3
                         if( abs( afilt_nnx(idim,i,j,k))<7.e-5) afilt_nnx(idim,i,j,k)=0.0
                       end do
                       end do
                       end do
                    end do
            ! 
                    do idim=1,ndim
                       print *,' '
                       do k=1,1+2*(ndim-2)
                       do j=1,3
                   print *,'idim,k,j,afilt_nnx(idim,:,j,k):',idim,k,j,afilt_nnx(idim,:,j,k)
                       end do
                       end do
                    end do
            ! 
            ! normalise
                    print *,' '
                    print *,'normalised filter for diffusion (pre-multiplied by 1/dx^2):'
                    do idim=1,ndim
                       print *,'idim=',idim
                       if(ndim==2) rnorm=4.0/afilt_nxnx(idim,2,2,1)
                       if(ndim==3) rnorm=6.0/afilt_nxnx(idim,2,2,2)
                       do k=1,1+2*(ndim-2)
                       do j=1,3
                          print *,'k,j,afilt_nxnx(idim,:,j,k):',k,j,afilt_nxnx(idim,:,j,k)*rnorm
                       end do
                       end do
                       print *,'sum( abs(afilt_nxnx(idim,:,:,1:1+(ndim-2)*2))*rnorm ):',  &
                                sum( abs(afilt_nxnx(idim,:,:,1:1+(ndim-2)*2))*rnorm )
                    end do ! do idim=1,ndim
            ! 
                    print *,' '
                    print *,'normalised filter for advection (pre-multiplied by 1/dx):'
                    do idim=1,ndim
                       if(ndim==2) rnorm=1.0/sum(abs(afilt_nnx(idim,:,:,1)))
                       if(ndim==3) rnorm=1.0/sum(abs(afilt_nnx(idim,:,:,:)))
                       do k=1,1+2*(ndim-2)
                       do j=1,3
                          print *,'idim,k,j,afilt_nnx(idim,:,j,k):', &
                                   idim,k,j,afilt_nnx(idim,:,j,k)*rnorm
                       end do
                       end do
                       print *,' '
                    end do
                    stop 382
                    end subroutine cty_filter_orig
            ! 
            ! 
            ! 
            ! 
                    subroutine set_up_cty_filter_quadratic_and_higher_fem
                    implicit none
            ! ann filter and simple code. 
            ! nacross= no of nodes across in a rectangle. 
            ! ndim=number of dimensions=1 or 2 or 3. 
            ! iall_basis_funs=1 then output all the basis functions associated with the linear combination. 
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
            ! dxele_dim(idim)=length of element in idim direction. 
                    integer nacross, ndim, iall_basis_funs 
                    real, allocatable :: dxele_dim(:)  
            ! 
            !        nacross=2 ! linear
                    nacross=3 ! quadratic
            !        nacross=5 ! cubic
            !        nacross=7 ! 
                    ndim=2
                    iall_basis_funs=0 
            !        iall_basis_funs=1 
                    allocate(dxele_dim(ndim))
                    dxele_dim(:)=2.0!2.0 ! dimensions 2 is the default for linear elements. 
            !        dxele_dim(:)=1.0 ! dimensions 2 is the default for linear elements. 
                    dxele_dim(:)=1.0*real(nacross-1) ! dimensions 2 is the default. 
            !        dxele_dim(:)=1.0*real(nacross-1) ! dimensions 2 is the default. 
            !        dxele_dim(:)=1.0 ! dimensions 2 is the default. 
            
                    call cty_filter_quadratic_and_higher_fem(nacross, ndim, iall_basis_funs, dxele_dim)
            
                    end subroutine set_up_cty_filter_quadratic_and_higher_fem
            ! 
            ! 
            ! 
            ! 
                    subroutine cty_filter_quadratic_and_higher_fem(nacross, ndim, iall_basis_funs, dxele_dim)
                    implicit none
            ! ann filter and simple code. 
            ! nacross= no of nodes across in a rectangle. 
            ! ndim=number of dimensions=1 or 2 or 3. 
            ! iall_basis_funs=1 then output all the basis functions associated with the linear combination. 
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
            ! dxele_dim(idim)=length of element in idim direction. 
                    integer, intent( in ) :: nacross, ndim, iall_basis_funs      
                    real, intent( in ) :: dxele_dim(ndim)    
            ! local variables...
                    integer totele,nloc,snloc,sngi, ngi, nface, max_face_list_no
            ! 2d linear:
            !        integer, parameter :: totele=1,nloc=4,snloc=2,sngi=3, ngi=9, ndim=2, &
            !                              nface=4, max_face_list_no=2
            ! 2d quadratic:
            !        integer, parameter :: totele=1,nloc=9,snloc=3,sngi=4, ngi=16, ndim=2, &
            !                              nface=4, max_face_list_no=2
            ! 2d cubic:
            !        integer, parameter :: totele=1,nloc=16,snloc=4,sngi=5, ngi=25, ndim=2, &
            !                              nface=4, max_face_list_no=2
            ! 3d linear:
            !        integer, parameter :: totele=1,nloc=8,snloc=4,sngi=9, ngi=27, ndim=3, &
            !                              nface=6, max_face_list_no=4
            ! 3d quadratic:
            !        integer, parameter :: totele=1,nloc=27,snloc=9,sngi=16, ngi=64, ndim=3, &
            !                              nface=6, max_face_list_no=4
            ! 3d cubic:
            !        integer, parameter :: totele=1,nloc=64,snloc=16,sngi=25, ngi=125, ndim=3, &
            !                              nface=6, max_face_list_no=4
                    real, allocatable :: n(:,:), nlx(:,:,:), weight(:)
                    real, allocatable :: face_sn(:,:,:), face_sn2(:,:,:)
                    real, allocatable :: face_snlx(:,:,:,:), face_sweigh(:,:) 
            ! local variables...
                    real, allocatable :: nx(:,:,:),detwei(:),inv_jac(:,:,:), jac_inv(:,:,:)
                    real, allocatable :: nxnx_all(:,:,:), nxnx(:,:,:), nnx(:,:,:), nxn(:,:,:), nn(:,:)
            ! filters for ann:
                    real, allocatable :: afilt_nxnx_all(:,:,:,:,:), afilt_nxnx(:,:,:,:,:), afilt_nnx(:,:,:,:,:)
                    real, allocatable :: afilt_resid_tran_nnx(:,:,:,:)
                    real, allocatable :: afilt_nxn(:,:,:,:,:), afilt_nn(:,:,:,:)
                    real, allocatable :: full_filt_nxnx_all(:,:,:,:,:,:,:) 
                    real, allocatable :: full_filt_nxnx(:,:,:,:,:,:,:) 
                    real, allocatable :: full_filt_nnx(:,:,:,:,:,:,:) 
                    real, allocatable :: full_filt_nxn(:,:,:,:,:,:,:) 
                    real, allocatable ::  full_filt_nn(:,:,:,:,:,:) 
                    real, allocatable :: afilt_nxnx_all_mid(:,:,:,:) 
                    real, allocatable :: afilt_nxnx_mid(:,:,:,:) 
                    real, allocatable ::  afilt_nnx_mid(:,:,:,:)
                    real, allocatable ::  afilt_nxn_mid(:,:,:,:)
                    real, allocatable ::   afilt_nn_mid(:,:,:)
                    real, allocatable :: x_loc(:,:), x_all(:,:), rsum_afilt_nxnx_overi(:)
                    real, allocatable :: rcoef_mean(:), NODPOS(:),QUAPOS(:)
                    integer npoly,ele_type,ele, iloc,jloc,idim,jdim
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k, gi
                    integer nfilt_width, ifilt_mid
                    integer iacross, jacross, kacross
                    integer i2,j2,k2, ifil2,jfil2,kfil2
                    integer idis,jdis,kdis, ifil_dis, jfil_dis, kfil_dis 
                    integer ifil2_dis, jfil2_dis, kfil2_dis 
                    integer istart,ifinish, jstart,jfinish, kstart,kfinish 
                    integer jrang,krang, k1,k3, ibase,nbase_print, iibase
                    integer IPOLY, IQADRA, nloc2, NDNOD, jswitch, kswitch
                    logical NDIFF, diff, use_base1_resid 
                    real LXGP, jac, tran_value
                    real SPECFU ! a function
                    CHARACTER CHARA*240
                    CHARACTER str_trim1*240
                    CHARACTER str_trim2*240
                    CHARACTER str_trim3*240
            ! 
                    real rnorm
            ! 
            ! 2d quadratic:
                    totele=1
                    nloc=nacross**ndim
                    snloc=nacross**(ndim-1)
                    ngi=(nacross+1)**ndim
                    sngi=(nacross+1)**(ndim-1)
            !        ndim=2
                    nface=2*ndim
                    max_face_list_no=2**(ndim-1)
            
            !        nacross=int( (real(nloc))**(1./real(ndim)) +0.1 )
                    nfilt_width = 2*(nacross-1)+1 ! width of the filter
            ! 
                    allocate(n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi) )
                    allocate(face_sn(sngi,snloc,nface), face_sn2(sngi,snloc,max_face_list_no) )
                    allocate(face_snlx(sngi,ndim-1,snloc,nface), face_sweigh(sngi,nface) )
            ! 
                    allocate(nx(ngi,ndim,nloc),detwei(ngi),inv_jac(ngi,ndim,ndim))
                    allocate(jac_inv(ndim,ndim,ngi))
                    allocate(nxnx_all(ndim*ndim,nloc,nloc),nxnx(ndim,nloc,nloc),nnx(ndim,nloc,nloc))
                    allocate(nxn(ndim,nloc,nloc), nn(nloc,nloc))
                    allocate(x_loc(ndim,nloc)) 
                    allocate(rsum_afilt_nxnx_overi(nfilt_width))
            ! 
            !         stop 3382
                    npoly=1
                    ele_type=1
            
            ! form the shape functions...
                    if(ndim==1) then
                       allocate(NODPOS(nloc),QUAPOS(ngi))
                       IPOLY=1 ! Legendra
                       IQADRA=1
                       nloc2=2 ! BUG HERE**************
                       CALL GTROOT(IPOLY,IQADRA,WEIGHT,NODPOS,QUAPOS,NGI,nloc2)
                       do iloc=1,nloc ! UNIFORM SPACING 
                          NODPOS(iloc)=(real(iloc-1)/real(nloc-1))*2.0 - 1.0
                       end do
            !       IPOLY=2 ! Cheb..
                       NDIFF=.false.
                       DIFF=.true.
                       idim=1
                       NDNOD=nloc
                       print *,'just starting initial set up'
            
                       do gi=1,ngi! Was loop 1000
                      ! 
                          LXGP=QUAPOS(gi)
                      ! NB If TRUE in function RGPTWE then return the Gauss-pt weight
                      ! else return the Gauss-pt.
                      ! 
                          do iloc=1,nloc! Was loop 12000
                         !
                             N(gi,ILOC) = &
                              SPECFU(NDIFF,LXGP,iloc,NDNOD,IPOLY,NODPOS)
                         !
                             NLX(gi,idim,ILOC) = &
                              SPECFU(DIFF, LXGP,iloc,NDNOD,IPOLY,NODPOS)
                          end do ! Was loop 12000
                       end do ! Was loop 1000
                    else
                       print *,'going into get_shape_funs_with_faces'
                       call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                    endif
            ! 
                    jswitch=min(1,max(0,ndim-1)) ! switch on 2D parts (needed for 3d)
                    kswitch=min(1,max(0,ndim-2)) ! switch on 3D.
            
                    allocate(x_all(ndim,totele*nloc)) 
            ! 
                    
                    do kacross=1,(nacross-1)*kswitch + 1
                      do jacross=1,(nacross-1)*jswitch + 1
                         do iacross=1,nacross
                            iloc = (kacross-1)*nacross*nacross + (jacross-1)*nacross + iacross 
            ! dxele_dim(idim) contain the dimensions of the element...
            !                x_all(1,iloc)=-1.0 + 2.*real(iacross-1)/real(nacross-1) 
                            x_all(1,iloc)=-0.5*dxele_dim(1) + dxele_dim(1)*real(iacross-1)/real(nacross-1) 
              if(ndim.ge.2) x_all(2,iloc)=-0.5*dxele_dim(2) + dxele_dim(2)*real(jacross-1)/real(nacross-1)
                if(ndim==3) x_all(3,iloc)=-0.5*dxele_dim(3) + dxele_dim(3)*real(kacross-1)/real(nacross-1)
            !                print *,'iloc,x_all(1,iloc):',iloc,x_all(1,iloc)
                         end do
                       end do
                    end do
            !         stop 2924
            
            ! obtain 
            ! for filters...
                    do ele = 1, totele ! VOLUME integral
                         x_loc(:,:) = x_all(:,(ele-1)*nloc+1:ele*nloc)
                         if(ndim==1) then
                            idim=1
                            do gi=1,ngi
                               jac = sum(nlx(gi,idim,:)*x_loc(idim,:))
                               jac_inv(idim,idim,gi)=1.0/jac 
                            end do
                            detwei(:) = weight(:)*(1./jac_inv(idim,idim,:))
                            nx(:,:,:)=0.0
                            do gi=1,ngi
                               do iloc=1,nloc
                                  nx(gi,idim,iloc) = nx(gi,idim,iloc)+ nlx(gi,idim,iloc)*jac_inv(idim,idim,gi)
                               end do
                            end do
                         else
                            call det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, INV_JAC )
                         endif
            
                         nxnx_all=0.0
                         nxnx=0.0
                         nnx=0.0
                         nxn=0.0
                         nn=0.0
                         do iloc=1,nloc
                         do jloc=1,nloc
                               do idim=1,ndim
                                  do jdim=1,ndim
                      nxnx_all(idim+(jdim-1)*ndim,iloc,jloc) = sum( nx(:,idim,iloc)*nx(:,jdim,jloc)*detwei(:) )
                                  end do
                      nxnx(idim,iloc,jloc) = sum( nx(:,idim,iloc)*nx(:,idim,jloc)*detwei(:) )
                      nnx(idim,iloc,jloc)  = sum( n(:,iloc)*nx(:,idim,jloc)*detwei(:) )
                      nxn(idim,iloc,jloc)  = sum( nx(:,idim,iloc)*n(:,jloc)*detwei(:) )
                               end do
                      nn(iloc,jloc)  = sum( n(:,iloc)*n(:,jloc)*detwei(:) )
            !                   do idim=1,1
            !                      nxnx(iloc,jloc) = nxnx(iloc,jloc) + sum( nx(:,idim,iloc)*nx(:,idim,jloc)*detwei(:) )
            !                   end do
                         end do
                         end do
                    end do
            ! 
            ! now calculate filters:
                    print *,'detwei:',detwei
                    print *,'weight:',weight
                    print *,' '
                    do gi=1,ngi
                      print *,'gi,idim,n(gi,:):',gi,n(gi,:)
                    end do
                    print *,' '
                    do idim=1,1!ndim
                    do gi=1,1!ngi
            !          if(idim==1) print *,'gi,idim,n(gi,:):',gi,idim,n(gi,:)
                      print *,'gi,idim,nlx(gi,idim,:):',gi,idim,nlx(gi,idim,:)
                      iloc=1
            !          print *,'iloc,nnx(idim,iloc,:):',iloc,nnx(idim,iloc,:)
                    end do
                    end do
                    print *,' '
                    do idim=1,1!ndim
                    do gi=1,1!ngi
            !          if(idim==1) print *,'gi,idim,n(gi,:):',gi,idim,n(gi,:)
            !          print *,'gi,idim,nlx(gi,idim,:):',gi,idim,nlx(gi,idim,:)
                      iloc=1
                      print *,'iloc,nnx(idim,iloc,:):',iloc,nnx(idim,iloc,:)
                    end do
                    print *,' '
                    end do
            !        stop 211
            !        do iloc=1,nloc
            !          print *,'iloc,nnx(1,iloc,:):',iloc,nnx(1,iloc,:)
            !        end do
            !        print *,'nacross:',nacross
            !        print *,'rcoef_mean:',rcoef_mean
            !        print *,'nfilt_width,nfilt_width/2:',nfilt_width,nfilt_width/2
            !        stop 2921
                    istart= -nfilt_width/2
                    ifinish= nfilt_width/2
                    jstart= 0+jswitch*istart
                    jfinish=0+jswitch*ifinish
            ! 
                    kstart=   0+kswitch*istart
                    kfinish=  0+kswitch*ifinish 
                    allocate(full_filt_nxnx_all(ndim*ndim, 2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish, &
                                                           2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish ) )
                    allocate(full_filt_nxnx(ndim, 2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish, &
                                                  2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish ) )
                    allocate( full_filt_nnx(ndim, 2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish, &
                                                  2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish ) )
                    allocate( full_filt_nxn(ndim, 2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish, &
                                                  2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish ) )
                    allocate( full_filt_nn(2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish, &
                                           2*istart:2*ifinish, 2*jstart:2*jfinish, 2*kstart:2*kfinish ) )
            !        allocate(index_nxnx(ndim, nacross,nacross,nacross, nacross,nacross,nacross) )
            !        allocate( index_nnx(ndim, nacross,nacross,nacross, nacross,nacross,nacross) )
            !        print *,'nacross=',nacross
            !        stop 29112
                    print *,'here1'
                    full_filt_nxnx_all=0.0
                    full_filt_nxnx    =0.0
                    full_filt_nnx     =0.0
                    full_filt_nxn     =0.0
                    full_filt_nn      =0.0
                    do kkblock=1,2*kswitch + 1*(1-kswitch)
                    do jjblock=1,2*jswitch + 1*(1-jswitch)
                    do iiblock=1,2
                       do k=1,nacross*kswitch + 1*(1-kswitch)
                       do j=1,nacross*jswitch + 1*(1-jswitch)
                       do i=1,nacross
                          do k2=1,nacross*kswitch + 1*(1-kswitch)
                          do j2=1,nacross*jswitch + 1*(1-jswitch)
                          do i2=1,nacross
                             iloc=i  +(j -1)*nacross + (k -1)*nacross*nacross
                             jloc=i2 +(j2-1)*nacross + (k2-1)*nacross*nacross
            !                 print *,'iiblock,jjblock,kkblock:',iiblock,jjblock,kkblock
            !                 print *,'i,j,k   :',i,j,k
            !                 print *,'i2,j2,k2:',i2,j2,k2
            !                 print *,'iloc,jloc:',iloc,jloc
            ! 
                             ifil  = i  -1 + (iiblock-2)*(nfilt_width/2)
                             jfil  =(j  -1 + (jjblock-2)*(nfilt_width/2))*jswitch
                             kfil  =(k  -1 + (kkblock-2)*(nfilt_width/2))*kswitch
            ! 
                             ifil2 = i2 -1 + (iiblock-2)*(nfilt_width/2)
                             jfil2 =(j2 -1 + (jjblock-2)*(nfilt_width/2))*jswitch
                             kfil2 =(k2 -1 + (kkblock-2)*(nfilt_width/2))*kswitch
            ! 
                             full_filt_nxnx_all(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) &
                           = full_filt_nxnx_all(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) &
                           + nxnx_all(:,iloc,jloc)
            ! 
                             full_filt_nxnx(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) &
                           = full_filt_nxnx(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) + nxnx(:,iloc,jloc)
            ! 
                              full_filt_nnx(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) &
                           =  full_filt_nnx(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) +  nnx(:,iloc,jloc)
            ! 
                              full_filt_nxn(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) &
                           =  full_filt_nxn(:, ifil,jfil,kfil, ifil2,jfil2,kfil2) +  nxn(:,iloc,jloc)
            ! 
                               full_filt_nn(   ifil,jfil,kfil, ifil2,jfil2,kfil2) &
                           =   full_filt_nn(   ifil,jfil,kfil, ifil2,jfil2,kfil2) +  nn(iloc,jloc)
            ! 
                          end do
                          end do
                          end do
                       end do
                       end do
                       end do
                    end do
                    end do
                    end do
            !        print *,'full_filt_nxn:',full_filt_nnx
            !        print *,'sum(abs(full_filt_nnx)):',sum(abs(full_filt_nnx))
            !        print *,'nxn:',nnx
            !        stop 45
                    print *,'here2'
            ! 
            ! add different versions of this in a (nacross-1)**ndim cube
                    allocate(afilt_nxnx_all_mid(ndim*ndim, istart:ifinish, jstart:jfinish, kstart:kfinish ) )
                    allocate(afilt_nxnx_mid(ndim, istart:ifinish, jstart:jfinish, kstart:kfinish ) )
                    allocate(afilt_nnx_mid(ndim,  istart:ifinish, jstart:jfinish, kstart:kfinish ) )
                    allocate(afilt_nxn_mid(ndim,  istart:ifinish, jstart:jfinish, kstart:kfinish ) )
                    allocate(afilt_nn_mid(        istart:ifinish, jstart:jfinish, kstart:kfinish ) )
            ! 
                    nbase_print=1
                    if(iall_basis_funs==1) then
                       nbase_print=(nacross-1)**ndim
                    endif
                    allocate(rcoef_mean((nacross-1)**ndim))
                    rcoef_mean(:)=1./real((nacross-1)**ndim) ! This is formed from the averaging.
            ! 
            !        stop 382
                    allocate(afilt_nxnx_all(ndim*ndim, nfilt_width, 1+(nfilt_width-1)*jswitch, &
                                            1+(nfilt_width-1)*kswitch, nbase_print))
                    allocate(afilt_nxnx(ndim, nfilt_width, 1+(nfilt_width-1)*jswitch, &
                                            1+(nfilt_width-1)*kswitch, nbase_print))
                    allocate( afilt_nnx(ndim, nfilt_width, 1+(nfilt_width-1)*jswitch, &
                                            1+(nfilt_width-1)*kswitch, nbase_print))
                    allocate( afilt_nxn(ndim, nfilt_width, 1+(nfilt_width-1)*jswitch, &
                                            1+(nfilt_width-1)*kswitch, nbase_print))
                    allocate( afilt_nn(nfilt_width, 1+(nfilt_width-1)*jswitch, &
                                            1+(nfilt_width-1)*kswitch, nbase_print))
            ! 
                    allocate( afilt_resid_tran_nnx(ndim, nfilt_width, 1+(nfilt_width-1)*jswitch, &
                                            1+(nfilt_width-1)*kswitch))
            ! 
                    print *,'here3'
                   do ibase=1,nbase_print
                    if(nbase_print>1) then
                       rcoef_mean(:)    =0.0
                       rcoef_mean(ibase)=1.0
                    endif
            ! 
                    afilt_nxnx_all_mid=0.0
                    afilt_nxnx_mid=0.0
                    afilt_nnx_mid =0.0
                    afilt_nxn_mid =0.0
                    afilt_nn_mid =0.0
            ! 
                    iibase=0
            ! 
                    do kdis=0,0 + (nacross-2)*kswitch
                    do jdis=0,0 + (nacross-2)*jswitch
                    do idis=0,nacross-2
                       iibase=iibase+1
                       do kfil2=kstart,kfinish
                       do jfil2=jstart,jfinish
                       do ifil2=istart,ifinish
            ! 
                          ifil_dis = idis
                          jfil_dis = jdis
                          kfil_dis = kdis
            ! 
                          ifil2_dis = ifil2 + idis
                          jfil2_dis = jfil2 + jdis
                          kfil2_dis = kfil2 + kdis
            ! 
                          afilt_nxnx_all_mid(:, ifil2,jfil2,kfil2) = afilt_nxnx_all_mid(:, ifil2,jfil2,kfil2) &
                          + full_filt_nxnx_all(:, ifil_dis,jfil_dis,kfil_dis, ifil2_dis,jfil2_dis,kfil2_dis) &
                          * rcoef_mean(iibase)
            ! 
                          afilt_nxnx_mid(:,ifil2,jfil2,kfil2) = afilt_nxnx_mid(:,ifil2,jfil2,kfil2) &
                          + full_filt_nxnx(:,ifil_dis,jfil_dis,kfil_dis, ifil2_dis,jfil2_dis,kfil2_dis) &
                          * rcoef_mean(iibase)
            ! 
                          afilt_nnx_mid(:,ifil2,jfil2,kfil2) = afilt_nnx_mid(:,ifil2,jfil2,kfil2) &
                          +  full_filt_nnx(:,ifil_dis,jfil_dis,kfil_dis, ifil2_dis,jfil2_dis,kfil2_dis) &
                          * rcoef_mean(iibase)
            ! 
                          afilt_nxn_mid(:,ifil2,jfil2,kfil2) = afilt_nxn_mid(:,ifil2,jfil2,kfil2) &
                          +  full_filt_nxn(:,ifil_dis,jfil_dis,kfil_dis, ifil2_dis,jfil2_dis,kfil2_dis) &
                          * rcoef_mean(iibase)
            ! 
                          afilt_nn_mid(ifil2,jfil2,kfil2) = afilt_nn_mid(ifil2,jfil2,kfil2) &
                          +  full_filt_nn(ifil_dis,jfil_dis,kfil_dis, ifil2_dis,jfil2_dis,kfil2_dis) &
                          * rcoef_mean(iibase)
            ! 
                       end do
                       end do
                       end do
                    end do
                    end do
                    end do
                    print *,'here3.5'
            
                    jrang=1+(nfilt_width-1)*jswitch
                    krang=1+(nfilt_width-1)*kswitch
            ! 
                    afilt_nxnx_all(:, 1:nfilt_width, 1:jrang, 1:krang, ibase) &
                      = afilt_nxnx_all_mid(:, istart:ifinish, jstart:jfinish, kstart:kfinish)
            ! 
                    afilt_nxnx(:, 1:nfilt_width, 1:jrang, 1:krang, ibase) &
                      = afilt_nxnx_mid(:, istart:ifinish, jstart:jfinish, kstart:kfinish)
            ! 
                    afilt_nnx(:, 1:nfilt_width, 1:jrang, 1:krang, ibase) &
                      = afilt_nnx_mid(:, istart:ifinish, jstart:jfinish, kstart:kfinish)
            ! 
                    afilt_nxn(:, 1:nfilt_width, 1:jrang, 1:krang, ibase) &
                      = afilt_nxn_mid(:, istart:ifinish, jstart:jfinish, kstart:kfinish)
            ! 
                    afilt_nn(    1:nfilt_width, 1:jrang, 1:krang, ibase) &
                      = afilt_nn_mid(    istart:ifinish, jstart:jfinish, kstart:kfinish)
            ! 
                   end do ! do ibase=1,nbase_print
                    print *,'here4'
            !  
                    use_base1_resid=.true. 
                    if(use_base1_resid.and.(nbase_print>1)) then 
            !        if(use_base1_resid) then 
                       afilt_resid_tran_nnx(:,:,:,:)=0.0
                       do ibase=1,nbase_print
                          afilt_resid_tran_nnx(:,:,:,:) =  afilt_resid_tran_nnx(:,:,:,:) &
                                                        + afilt_nnx(:,:,:,:,ibase) 
                       end do
                       afilt_resid_tran_nnx(:,:,:,:) =  afilt_resid_tran_nnx(:,:,:,:) &
                                                     - afilt_nnx(:,:,:,:,1) 
                       tran_value = sum(afilt_nn(:,:,:,:)) - sum(afilt_nn(:,:,:,1))
            !           tran_value = sum(afilt_nn(:)) - sum(afilt_nn_bases(:,1))
                       afilt_resid_tran_nnx(:,:,:,:) = afilt_resid_tran_nnx(:,:,:,:) &
                                               * sum(afilt_nn(:,:,:,:))/tran_value
            ! not sure where these coefficient 0.25 come from...
            !           afilt_resid_tran_nnx = 0.5*(0.25*afilt_resid_tran_nnx-afilt_nnx)
                       afilt_resid_tran_nnx = 0.5*0.25*afilt_resid_tran_nnx
                       do ibase=1,nbase_print
                          afilt_resid_tran_nnx(:,:,:,:) =  afilt_resid_tran_nnx(:,:,:,:) &
                                       - 0.5*afilt_nnx(:,:,:,:,ibase)/real((nacross-1)**ndim) 
            !        rcoef_mean(:)=1./real((nacross-1)**ndim) ! This is formed from the averaging.
                       end do
                    endif
            ! 
             
            
            ! 
                    do idim=1,ndim
                       print *,'idim=',idim
                       do jloc=1,nloc
                          print *,'jloc,nxnx(idim,:,jloc):',jloc,nxnx(idim,:,jloc)
                       end do
                    end do
            ! 
                   do ibase=1,nbase_print
                    do idim=1,ndim
                       print *,'idim=',idim
                       do k=1,krang
                       do j=1,jrang
                          print *,'k,j,afilt_nxnx(idim,:,j,k,ibase):',k,j,afilt_nxnx(idim,:,j,k,ibase)
                       end do
                       end do
                    end do
                   end do
            ! 
                   do ibase=1,nbase_print
                       do k=1,krang
                       do j=1,jrang
                          print *,'k,j,afilt_nn(:,j,k,ibase):',k,j,afilt_nn(:,j,k,ibase)
                       end do
                       end do
                   end do
            ! 
            ! 
                        str_trim1=chara(ndim);      k1=INDEX(str_trim1,' ')-1
                        str_trim2=chara(nacross);   k2=INDEX(str_trim2,' ')-1
                        str_trim3=chara(nbase_print); k3=INDEX(str_trim3,' ')-1
            !            open(27, file='run/group-output-time'//str_trim(1:k)//'.csv', status='replace')
                        open(27, file='afilt_ndim='//str_trim1(1:k1) &
                                      //'_nacross='//str_trim2(1:k2) &
                                    //'_nbase_print='//str_trim3(1:k3)//'.csv', status='replace')
            ! 
                    write(27,*) 'Multi-dimensional convolutional filters for solving PDEs with'
                    write(27,*) 'linear and higher order based methods.'
                    write(27,*) 'The higher order FEM are modified FEM approaches for convolutions.'
                    write(27,*) 
                    write(27,*) 'afilt_nxnx_isotropic.csv:'
                    write(27,*) 'The isotropic diffusion filter D^2.'
                    write(27,*) 'FORTRAN output code... then the actual output of the code...'
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do ibase=1,nbase_print'
                    write(27,*) '   do k=1,krang'
                    write(27,*) '   do j=1,jrang'
                    write(27,*) '      rsum_afilt_nxnx_overi(:)=0.0'
                    write(27,*) '      do idim=1,ndim'
                    write(27,*) '         rsum_afilt_nxnx_overi(:) = rsum_afilt_nxnx_overi(:) &'
                    write(27,*) '                                  + afilt_nxnx(idim,:,j,k,ibase)'
                    write(27,*) '      end do'
                    write(27,*) '      write(27,*) rsum_afilt_nxnx_overi(:)'
                    write(27,*) '   end do'
                    write(27,*) '   end do'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                       do k=1,krang 
                       do j=1,jrang
                          rsum_afilt_nxnx_overi(:)=0.0
                          do idim=1,ndim
                             rsum_afilt_nxnx_overi(:) = rsum_afilt_nxnx_overi(:) &
                                                      + afilt_nxnx(idim,:,j,k,ibase)
                          end do
                          write(27,*) rsum_afilt_nxnx_overi(:)
                       end do
                       end do
                    end do
            ! 
                    write(27,*) 
                    write(27,*) 'afilt_nxnx.csv:'
                    write(27,*) 'The isotropic diffusion filter D^2 but in the x-,y-, and z- directions only.'
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do ibase=1,nbase_print'
                    write(27,*) 'do idim=1,ndim'
                    write(27,*) '   do k=1,krang'  
                    write(27,*) '   do j=1,jrang'
                    write(27,*) '      write(27,*) afilt_nxnx(idim,:,j,k,ibase)'
                    write(27,*) '   end do'
                    write(27,*) '   end do'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                    do idim=1,ndim
                       print *,' '
                       do k=1,krang
                       do j=1,jrang
                   print *,'idim,k,j,afilt_nxnx(idim,:,j,k,ibase):',idim,k,j,afilt_nxnx(idim,:,j,k,ibase)
                          write(27,*) afilt_nxnx(idim,:,j,k,ibase)
                       end do
                       end do
                    end do
                    end do
            ! 
                    write(27,*) 
                    write(27,*) 'afilt_nxnx_all.csv:'
                    write(27,*) 'The isotropic entire diffusion filter Dxx, Dxy,  Dyx, Dyy etc.' 
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do ibase=1,nbase_print'
                    write(27,*) 'do idim=1,ndim'
                    write(27,*) 'do jdim=1,ndim'
                    write(27,*) '   do k=1,krang'  
                    write(27,*) '   do j=1,jrang'
                    write(27,*) '      write(27,*) afilt_nxnx_all(idim+(jdim-1)*ndim,:,j,k,ibase)'
                    write(27,*) '   end do'
                    write(27,*) '   end do'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                    do idim=1,ndim
                    do jdim=1,ndim
                       print *,' '
                       do k=1,krang
                       do j=1,jrang
                   print *,'idim,k,j,afilt_nxnx_all(idim+(jdim-1)*ndim,:,j,k,ibase):', &
                            idim,k,j,afilt_nxnx_all(idim+(jdim-1)*ndim,:,j,k,ibase)
                          write(27,*) afilt_nxnx_all(idim+(jdim-1)*ndim,:,j,k,ibase)
                       end do
                       end do
                    end do
                    end do
                    end do
            ! 
            ! get rid of small values - round off error is an issue here. 
                    write(27,*) 
                    write(27,*) 'afilt_nnx.csv:'
                    write(27,*) 'The gradient (advection) filters in the x-, y-, z- directions' 
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do ibase=1,nbase_print'
                    write(27,*) 'do idim=1,ndim'
                    write(27,*) '   do k=1,krang'  
                    write(27,*) '   do j=1,jrang'
                    write(27,*) '      write(27,*) afilt_nnx(idim,:,j,k,ibase)'
                    write(27,*) '   end do'
                    write(27,*) '   end do'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                    do idim=1,ndim
                       do k=1,krang
                       do j=1,jrang
                       do i=1,nfilt_width
                         if( abs( afilt_nnx(idim,i,j,k,ibase))<7.e-10) afilt_nnx(idim,i,j,k,ibase)=0.0
                       end do
                          write(27,*) afilt_nnx(idim,:,j,k,ibase)
                       end do
                       end do
                    end do
                    end do
            ! 
            ! get rid of small values - round off error is an issue here. 
                    write(27,*) 
                    write(27,*) 'afilt_nxn.csv:'
                    write(27,*) 'The conservative gradient (advection) filters in the x-, y-, z- directions' 
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do ibase=1,nbase_print'
                    write(27,*) 'do idim=1,ndim'
                    write(27,*) '   do k=1,krang'  
                    write(27,*) '   do j=1,jrang'
                    write(27,*) '      write(27,*) afilt_nxn(idim,:,j,k,ibase)'
                    write(27,*) '   end do'
                    write(27,*) '   end do'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                    do idim=1,ndim
                       do k=1,krang
                       do j=1,jrang
                       do i=1,nfilt_width
                         if( abs( afilt_nxn(idim,i,j,k,ibase))<7.e-10) afilt_nxn(idim,i,j,k,ibase)=0.0
                       end do
                          write(27,*) afilt_nxn(idim,:,j,k,ibase)
                       end do
                       end do
                    end do
                    end do
            ! 
                    write(27,*) 
                    write(27,*) 'afilt_nn.csv:'
                    write(27,*) 'The consistent mass matrix filter.' 
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do ibase=1,nbase_print' 
                    write(27,*) 'do k=1,krang'
                    write(27,*) 'do j=1,jrang'
                    write(27,*) '   write(27,*) afilt_nn(:,j,k)'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                       do k=1,krang
                       do j=1,jrang
                          write(27,*) afilt_nn(:,j,k,ibase)
                       end do
                       end do
                    end do
            ! 
                    write(27,*) 
                    write(27,*) 'afilt_ml.csv:'
                    write(27,*) 'The lumped mass term (scalar for this node/cell).'
                    write(27,*) 'do ibase=1,nbase_print'
                    write(27,*) '   write(27,*) sum(afilt_nn(:,:,:,ibase))'
                    write(27,*) 'end do'
                    do ibase=1,nbase_print
                          write(27,*) sum(afilt_nn(:,:,:,ibase))
                    end do
            ! 
                    write(27,*) 
                    write(27,*) 'afilt_ml_check.csv:'
                    write(27,*) 'The lumped mass term (scalar for this node/cell).'
                    write(27,*) 'write(27,*) (2./real(nacross-1))**ndim'
                          write(27,*) (2./real(nacross-1))**ndim
            ! 
                    write(27,*) 
                    write(27,*) 'dxele_dim.csv:'
                    write(27,*) 'The dimensions of the hexahedra element.'
                    write(27,*) 'write(27,*) dxele_dim(:)'
                          write(27,*) dxele_dim(:)
            ! 
                    write(27,*) 
                    write(27,*) 'integer_options_used.csv:'
                    write(27,*) 'write(27,*) nacross, ndim, iall_basis_funs, nbase_print'
                    write(27,*) nacross, ndim, iall_basis_funs, nbase_print
            ! 
            ! afilt_resid_tran_nnx...
            ! get rid of small values - round off error is an issue here. 
                    if(use_base1_resid.and.(nbase_print>1)) then 
                    write(27,*) 
                    write(27,*) 'afilt_resid_tran_nnx.csv:'
                    write(27,*) 'The residual gradient error (advection) filters in the x-, y-, z- directions' 
                    write(27,*) 'jrang=1+(nfilt_width-1)*jswitch'
                    write(27,*) 'krang=1+(nfilt_width-1)*kswitch'
                    write(27,*) 'do idim=1,ndim'
                    write(27,*) '   do k=1,krang'  
                    write(27,*) '   do j=1,jrang'
                    write(27,*) '      write(27,*) afilt_resid_tran_nnx(idim,:,j,k)'
                    write(27,*) '   end do'
                    write(27,*) '   end do'
                    write(27,*) 'end do'
                    do idim=1,ndim
                       do k=1,krang
                       do j=1,jrang
                       do i=1,nfilt_width
                         if( abs( afilt_resid_tran_nnx(idim,i,j,k))<7.e-10) afilt_resid_tran_nnx(idim,i,j,k)=0.0
                       end do
                          write(27,*) afilt_resid_tran_nnx(idim,:,j,k)
                       end do
                       end do
                    end do 
                    endif ! if(use_base1_resid.and.(nbase_print>1)) then
                    close(27)  
            ! 
            ! normalise
                    print *,' '
                    print *,'normalised filter for diffusion components (pre-multiplied by 1/dx^2):'
                       ifilt_mid=1 + nfilt_width/2
                    do ibase=1,nbase_print
                    do idim=1,ndim
                       print *,'idim=',idim
                       if(ndim==1) rnorm=2.0/afilt_nxnx(idim,ifilt_mid,1,1,ibase)
                       if(ndim==2) rnorm=4.0/afilt_nxnx(idim,ifilt_mid,ifilt_mid,1,ibase)
                       if(ndim==3) rnorm=6.0/afilt_nxnx(idim,ifilt_mid,ifilt_mid,ifilt_mid,ibase)
                       do k=1,krang
                       do j=1,jrang
                          print *,'k,j,afilt_nxnx(idim,:,j,k,ibase):', &
                                   k,j,afilt_nxnx(idim,:,j,k,ibase)*rnorm
                       end do
                       end do
                       print *,'sum( abs(afilt_nxnx(idim,:,:,1:1+(ndim-2)*2,ibase)*rnorm )):',  &
                                sum( abs(afilt_nxnx(idim,:,:,1:1+(ndim-2)*2,ibase)*rnorm ))
                    end do ! do idim=1,ndim
                    end do ! do ibase=1,nbase_print
            ! 
                    print *,'normalised filter for diffusion (pre-multiplied by 1/dx^2):'
                       ifilt_mid=1 + nfilt_width/2
                    do ibase=1,nbase_print
                       do k=1,krang
                       do j=1,jrang
                          rsum_afilt_nxnx_overi(:)=0.0
                          do idim=1,ndim
                             if(ndim==1) rnorm=2.0/afilt_nxnx(idim,ifilt_mid,1,1,ibase)
                             if(ndim==2) rnorm=4.0/afilt_nxnx(idim,ifilt_mid,ifilt_mid,1,ibase)
                             if(ndim==3) rnorm=6.0/afilt_nxnx(idim,ifilt_mid,ifilt_mid,ifilt_mid,ibase)
                             rsum_afilt_nxnx_overi(:) = rsum_afilt_nxnx_overi(:) &
                                                      + afilt_nxnx(idim,:,j,k,ibase)*rnorm
                          end do
                          print *,'k,j,afilt_nxnx(sum(idim),:,j,k,ibase):',k,j,rsum_afilt_nxnx_overi(:)
                       end do
                       end do
                    end do
            ! 
                    print *,' '
                    print *,'normalised filter for advection (pre-multiplied by 1/dx):'
                    do ibase=1,nbase_print
                    do idim=1,ndim
                       if(ndim==1) rnorm=1.0/sum(abs(afilt_nnx(idim,:,1,1,ibase)))
                       if(ndim==2) rnorm=1.0/sum(abs(afilt_nnx(idim,:,:,1,ibase)))
                       if(ndim==3) rnorm=1.0/sum(abs(afilt_nnx(idim,:,:,:,ibase)))
                       do k=1,krang
                       do j=1,jrang
            !              print *,'idim,k,j:',idim,k,j
            !              print *,'rnorm:',rnorm
                          print *,'idim,k,j,afilt_nnx(idim,:,j,k,ibase):', &
                                   idim,k,j,afilt_nnx(idim,:,j,k,ibase)*rnorm
                       end do
                       end do
                       print *,' '
                    end do
                    end do
            ! 
                    stop 382
                    end subroutine cty_filter_quadratic_and_higher_fem
            ! 
            ! 
            ! 
            ! 
                  CHARACTER*240 FUNCTION CHARA(CURPRO)
            !     CURPRO must be the same in calling subroutine.
                  INTEGER MXNLEN
                  PARAMETER(MXNLEN=5)
                  INTEGER DIGIT(MXNLEN),II,J,TENPOW,CURPRO,K
                  CHARACTER STRI*240
                  CHARACTER*1 CHADIG(MXNLEN)
                  LOGICAL SWITCH
            !     MXNLEN=max no of digits in integer I.
            !     This function converts integer I to a string.
                  II=CURPRO
                  SWITCH=.FALSE.
                  K=0
                  STRI=' '
                  do  J=MXNLEN,1,-1! Was loop 10
                     TENPOW=10**(J-1)
                     DIGIT(J)=II/TENPOW
                     II=II-DIGIT(J)* TENPOW
            !     ewrite(3,*)'DIGIT*J)=',DIGIT(J),' TENOW=',TENPOW
            !     STRI=STRI//CHAR(DIGIT(J)+48)
                     IF(DIGIT(J).EQ.0) CHADIG(J)='0'
                     IF(DIGIT(J).EQ.1) CHADIG(J)='1'
                     IF(DIGIT(J).EQ.2) CHADIG(J)='2'
                     IF(DIGIT(J).EQ.3) CHADIG(J)='3'
                     IF(DIGIT(J).EQ.4) CHADIG(J)='4'
                     IF(DIGIT(J).EQ.5) CHADIG(J)='5'
                     IF(DIGIT(J).EQ.6) CHADIG(J)='6'
                     IF(DIGIT(J).EQ.7) CHADIG(J)='7'
                     IF(DIGIT(J).EQ.8) CHADIG(J)='8'
                     IF(DIGIT(J).EQ.9) CHADIG(J)='9'
            !         Q=INDEX(STRI,' ')-1
            !         IF(Q.LT.1) STRI=CHADIG
            !         IF(Q.GE.1) STRI=STRI(1:Q)//CHADIG
            !         IF(DIGIT(J).NE.0) SWITCH=.TRUE.
            !         IF(SWITCH) K=K+1
                  end do ! Was loop 10
                   k=0
                  do  J=MXNLEN,1,-1! Was loop 20
                     IF(SWITCH) THEN 
                       STRI=STRI(1:K)//CHADIG(J)
                       K=K+1
                     ENDIF
                     IF((CHADIG(J).NE.'0').AND.(.NOT.SWITCH)) THEN 
                       SWITCH=.TRUE.
                       STRI=CHADIG(J)
                       K=1
                     ENDIF
                  end do ! Was loop 20
                   IF(K.EQ.0) THEN 
                     STRI='0'
                      K=1
                    ENDIF
            !       ewrite(3,*)'STRI=',STRI,' K=',K
            !       ewrite(3,*)'STRI(MXNLEN-K+1:MXNLEN)=',STRI(MXNLEN-K+2:MXNLEN+1)
            !       CHARA=STRI(MXNLEN-K+2:MXNLEN+1)
                    CHARA=STRI(1:K)
                   END
            ! 
            ! 
            ! 
            ! 
            ! Python interface is: 
            ! psi_no_bc = sfc_solver_it_3(psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
            !                                 nonods_sfc_all_grids, nlevel, &
            !                                 a_no_bc, b_no_bc, relax, &
            !                                 fina_no_bc,cola_no_bc, sfc_node_ordering, &
            !                                 ncola_no_bc, nonods_no_bc, &
            !                                 nfilt_size_sfc)  
                    subroutine sfc_solver_it_3(psi_no_bc, psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, sfc_node_ordering, &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix, &
                                             nfilt_size_sfc)  
            ! Solve the system a_no_bc*psi_no_bc = b_no_bc with a single multi-grid iteration and 1 SFC. 
            ! it uses a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. 
            ! It does this with a kernal size of 3. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! if(iscale_matrices==1) then assume the matricies have been divided through by mass matrix.
            ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont.
            ! i_jacobi_full_matrix=1 then include Jacobi relaxation on full matrix, =0 dont.
            ! Default values: iscale_matrices=0, i_jacobi_on_finest_sfc=0, i_jacobi_full_matrix=1
            ! one must have either i_jacobi_on_finest_sfc=1 and/or i_jacobi_full_matrix=1
            ! 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods)
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola_no_bc, nonods_no_bc, nonods_sfc_all_grids, nlevel
                    integer, intent( in ) :: iscale_matrices, i_jacobi_on_finest_sfc, i_jacobi_full_matrix
                    integer, intent( in ) :: nfilt_size_sfc
                    real, intent( out ) :: psi_no_bc(nonods_no_bc)
                    real, intent( in ) :: a_sfc(nfilt_size_sfc,nonods_sfc_all_grids) 
                    real, intent( in ) :: psi_no_bc_guess(nonods_no_bc), relax(nlevel) 
                    real, intent( in ) :: a_no_bc(ncola_no_bc), b_no_bc(nonods_no_bc)
                    integer, intent( in ) :: fin_sfc_nonods(nlevel+1)
                    integer, intent( in ) :: fina_no_bc(nonods_no_bc+1), cola_no_bc(ncola_no_bc)
                    integer, intent( in ) :: sfc_node_ordering(nonods_no_bc)
            ! local variables...
                    real, allocatable :: resid_no_bc(:), resid_sfc_all(:), rhs_sfc_all(:)
                    real, allocatable :: delta_psi_temp(:),delta_psi(:),delta_psi_sfc(:)
                    real rr
                    integer inod, count, jnod, inod_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer inod_sfc_all, ipt, inod_sfc_fine, inod_sfc_fine_all,inod_sfc_fine_all2
                    integer ilevel_finish
            ! 
            ! calculate nlevel from nonods
                    print *,'just inside sfc_solver_it_3'
                    if(nfilt_size_sfc.ne.3) stop 2829
            !        stop 2922
                    allocate(resid_no_bc(nonods_no_bc), resid_sfc_all(nonods_sfc_all_grids))
                    allocate(delta_psi_sfc(nonods_sfc_all_grids), delta_psi(nonods_no_bc))
                    allocate(rhs_sfc_all(nonods_sfc_all_grids), delta_psi_temp(nonods_no_bc))
            ! 
                    psi_no_bc = psi_no_bc_guess ! need to do this because of python interface (can not have an inout variable)
                    resid_no_bc=b_no_bc
                    do inod=1,nonods_no_bc
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
            !              print *,'inod,jnod,count,a_no_bc(count):',inod,jnod,count,a_no_bc(count)
                          resid_no_bc(inod)=resid_no_bc(inod)-a_no_bc(count)*psi_no_bc(jnod) 
                       end do
            !           stop 7
                    end do
            !        stop 229
            ! map to sfc ordering
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       resid_sfc_all(inod_sfc) = resid_no_bc(inod)
                    end do
            ! 
            ! coarsen the residual...
                    do ilevel=2,nlevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       if(iscale_matrices==1) then ! assume the matricies have been divided through by mass matrix...
                          ipt=fin_sfc_nonods(ilevel)
                          resid_sfc_all(ipt:ipt+sfc_nonods_course-1)=0.5*resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                       endif
            !           print *,'ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1):', &
            !                    ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                    end do
            !        stop 227
            ! 
            ! perform Jacobi relaxation on the 1d SFC and on each SFC grid level up to the 2nd. 
                    delta_psi_sfc = 0.0
                    rhs_sfc_all = 0.0
            ! Jacobi relaxation with one cell...
                    ilevel=nlevel
                    do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                       rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) 
                       delta_psi_sfc(inod_sfc_all)  = &
                                    relax(ilevel) * rhs_sfc_all(inod_sfc_all) / a_sfc(2,inod_sfc_all) &
                                                    +(1.-relax(ilevel))* delta_psi_sfc(inod_sfc_all)
                    end do
            ! map to finer grid...
                    sfc_nonods_course = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
                    sfc_nonods_fine   = fin_sfc_nonods(ilevel)   - fin_sfc_nonods(ilevel-1)
                    call map_sfc_course_grid_2_fine_grid_vec( &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine, &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course)
                  if(.false.) then ! reduce delta on fine grid by factor of 2.
                     ipt=fin_sfc_nonods(ilevel-1)
                     delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)=0.5*delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)
                  endif
            ! 
            ! Jacobi relaxation on the other grids...
                    ilevel_finish=2-i_jacobi_on_finest_sfc ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont
                    do ilevel=nlevel-1,ilevel_finish,-1
            !        do ilevel=nlevel-1,1,-1
                       do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) 
                       end do
                       inod_sfc_all=fin_sfc_nonods(ilevel)
                       rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all)    &
                                                -1.0*a_sfc(3,inod_sfc_all) * delta_psi_sfc(inod_sfc_all+1)
                       do inod_sfc_all=fin_sfc_nonods(ilevel) +1,fin_sfc_nonods(ilevel+1)-1 -1
                          rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                -1.0*a_sfc(1,inod_sfc_all) * delta_psi_sfc(inod_sfc_all-1) &
                                                -1.0*a_sfc(3,inod_sfc_all) * delta_psi_sfc(inod_sfc_all+1) 
                       end do
                       inod_sfc_all=fin_sfc_nonods(ilevel+1)-1
                       rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all)  &
                                                -1.0*a_sfc(1,inod_sfc_all) * delta_psi_sfc(inod_sfc_all-1)
            ! Jacobi relaxation...
                       do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          delta_psi_sfc(inod_sfc_all)  = &
                                 relax(ilevel) * rhs_sfc_all(inod_sfc_all) / a_sfc(2,inod_sfc_all) &
                                                       +(1.-relax(ilevel))* delta_psi_sfc(inod_sfc_all)
                       end do
            ! map to finer grid
               if(ilevel.ne.1) then
                       sfc_nonods_course = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
                       sfc_nonods_fine   = fin_sfc_nonods(ilevel)   - fin_sfc_nonods(ilevel-1)
                       call map_sfc_course_grid_2_fine_grid_vec( &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine, &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course)
                  if(.false.) then ! reduce delta on fine grid by factor of 2.
                     ipt=fin_sfc_nonods(ilevel-1)
                     delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)=0.5*delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)
                  endif
               endif
                    end do ! do ilevel=nlevel-1,2,-1
            !        ilevel=1
            !        print *,'fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1):', &
            !                 fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)
            !        sfc_nonods_fine = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
            !        print *,'delta_psi_sfc(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel)-1+sfc_nonods_fine):', &
            !                 delta_psi_sfc(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel)-1+sfc_nonods_fine)
            !        stop 29211
            ! 
            ! For ilevel=1 use Jacobi iteration with the original matrix...
                    ilevel=1
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       delta_psi_temp(inod)=delta_psi_sfc(inod_sfc) 
                    end do
                    delta_psi=delta_psi_temp
                 if(i_jacobi_full_matrix==1) then ! include Jacobi relaxation on full matrix.
                    do inod=1,nonods_no_bc
                       rr=resid_no_bc(inod)
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          rr = rr - a_no_bc(count)*delta_psi_temp(jnod) 
                       end do
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          if(jnod==inod) then ! diagonal...
                             rr = rr + a_no_bc(count)*delta_psi_temp(jnod) 
                             delta_psi(inod) = relax(ilevel) * rr /a_no_bc(count) &
                                               +(relax(ilevel)-1.0) * delta_psi_temp(inod)
                          endif
                       end do
                    end do
                  endif
                    psi_no_bc = psi_no_bc + delta_psi
                    print *,'just leaving sfc_solver_it_3'
            !        stop 2921
                    
                    return 
                    end subroutine sfc_solver_it_3
            ! 
            ! 
            ! 
            ! 
            ! Python interface is: 
            ! psi_no_bc = sfc_solver_it_n(psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
            !                                 nonods_sfc_all_grids, nlevel, &
            !                                 a_no_bc, b_no_bc, relax, &
            !                                 fina_no_bc,cola_no_bc, sfc_node_ordering, &
            !                                 ncola_no_bc, nonods_no_bc, &
            !                                 nfilt_size_sfc)  
                    subroutine sfc_solver_it_n(psi_no_bc, psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, sfc_node_ordering, &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix, &
                                             nfilt_size_sfc)  
            ! Solve the system a_no_bc*psi_no_bc = b_no_bc with a single multi-grid iteration and 1 SFC. 
            ! it uses a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. 
            ! It does this with a kernal size of nfilt_size_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! if(iscale_matrices==1) then assume the matricies have been divided through by mass matrix.
            ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont.
            ! i_jacobi_full_matrix=1 then include Jacobi relaxation on full matrix, =0 dont.
            ! Default values: iscale_matrices=0, i_jacobi_on_finest_sfc=0, i_jacobi_full_matrix=1
            ! one must have either i_jacobi_on_finest_sfc=1 and/or i_jacobi_full_matrix=1
            ! 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods)
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola_no_bc, nonods_no_bc, nonods_sfc_all_grids, nlevel
                    integer, intent( in ) :: iscale_matrices, i_jacobi_on_finest_sfc, i_jacobi_full_matrix
                    integer, intent( in ) :: nfilt_size_sfc
                    real, intent( out ) :: psi_no_bc(nonods_no_bc)
                    real, intent( in ) :: a_sfc(nfilt_size_sfc,nonods_sfc_all_grids) 
                    real, intent( in ) :: psi_no_bc_guess(nonods_no_bc), relax(nlevel) 
                    real, intent( in ) :: a_no_bc(ncola_no_bc), b_no_bc(nonods_no_bc)
                    integer, intent( in ) :: fin_sfc_nonods(nlevel+1)
                    integer, intent( in ) :: fina_no_bc(nonods_no_bc+1), cola_no_bc(ncola_no_bc)
                    integer, intent( in ) :: sfc_node_ordering(nonods_no_bc)
            ! local variables...
                    real, allocatable :: resid_no_bc(:), resid_sfc_all(:), rhs_sfc_all(:)
                    real, allocatable :: delta_psi_temp(:),delta_psi(:),delta_psi_sfc(:)
                    real rr
                    integer inod, count, jnod, inod_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer inod_sfc_all, ipt, inod_sfc_fine, inod_sfc_fine_all,inod_sfc_fine_all2
                    integer ilevel_finish, inod_sfc_all_start, inod_sfc_all_finish
                    integer modified_inod_sfc_all_start, modified_inod_sfc_all_finish
                    integer ifilt_diag, ifilt, icent_ifilt
            ! 
            ! calculate nlevel from nonods
                    print *,'just inside sfc_solver_it_n'
            !        stop 2922
                    allocate(resid_no_bc(nonods_no_bc), resid_sfc_all(nonods_sfc_all_grids))
                    allocate(delta_psi_sfc(nonods_sfc_all_grids), delta_psi(nonods_no_bc))
                    allocate(rhs_sfc_all(nonods_sfc_all_grids), delta_psi_temp(nonods_no_bc))
            ! 
                    ifilt_diag = 1+nfilt_size_sfc/2 
            ! 
                    psi_no_bc = psi_no_bc_guess ! need to do this because of python interface (can not have an inout variable)
                    resid_no_bc=b_no_bc
                    do inod=1,nonods_no_bc
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
            !              print *,'inod,jnod,count,a_no_bc(count):',inod,jnod,count,a_no_bc(count)
                          resid_no_bc(inod)=resid_no_bc(inod)-a_no_bc(count)*psi_no_bc(jnod) 
                       end do
            !           stop 7
                    end do
            !        stop 229
            ! map to sfc ordering
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       resid_sfc_all(inod_sfc) = resid_no_bc(inod)
                    end do
            ! 
            ! coarsen the residual...
                    do ilevel=2,nlevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       if(iscale_matrices==1) then ! assume the matricies have been divided through by mass matrix...
                          ipt=fin_sfc_nonods(ilevel)
                          resid_sfc_all(ipt:ipt+sfc_nonods_course-1)=0.5*resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                       endif
            !           print *,'ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1):', &
            !                    ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                    end do
            !        stop 227
            ! 
            ! perform Jacobi relaxation on the 1d SFC and on each SFC grid level up to the 2nd or 1st. 
                    delta_psi_sfc = 0.0
                    rhs_sfc_all = 0.0
            !         print *,'ifilt_diag:',ifilt_diag
            ! 
            ! Jacobi relaxation on the all grids...
                    ilevel_finish=2-i_jacobi_on_finest_sfc ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont
                    do ilevel=nlevel,ilevel_finish,-1
            !           print *,'ilevel=',ilevel
            !        do ilevel=nlevel-1,1,-1
                       inod_sfc_all_start  = fin_sfc_nonods(ilevel)
                       inod_sfc_all_finish = fin_sfc_nonods(ilevel+1)-1
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
            !           do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) 
                       end do
            !           print *,'h1'
                       do ifilt = 1, nfilt_size_sfc
                          icent_ifilt = ifilt  -  ifilt_diag
                          modified_inod_sfc_all_start  = &
                                     max(inod_sfc_all_start  - icent_ifilt,inod_sfc_all_start)
                          modified_inod_sfc_all_finish = &
                                     min(inod_sfc_all_finish - icent_ifilt,inod_sfc_all_finish)
                          do inod_sfc_all = modified_inod_sfc_all_start, modified_inod_sfc_all_finish
            !              do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
            !            if((inod_sfc_all+icent_ifilt.ge.inod_sfc_all_start) &
            !          .and.(inod_sfc_all+icent_ifilt.le.inod_sfc_all_finish)) then
                             rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                -a_sfc(ifilt,inod_sfc_all) * delta_psi_sfc(inod_sfc_all+icent_ifilt) 
            !            else
            !               print *,'problem here'
            !                stop 2929
            !            endif
                          end do  
                       end do    
            !           print *,'h2'
            ! we have included the diagonal so take it away again...
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish    
                          rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                +a_sfc(ifilt_diag,inod_sfc_all) * delta_psi_sfc(inod_sfc_all)
            !              the_elthorne_variable   = 7e7*a_sfc(imid_ifilt,inod_sfc_all) * delta_psi_sfc(inod_sfc_all)
                       end do
            ! Jacobi relaxation...
                       do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          delta_psi_sfc(inod_sfc_all)  = &
                                 relax(ilevel) * rhs_sfc_all(inod_sfc_all) / a_sfc(ifilt_diag,inod_sfc_all) &
                                                       +(1.-relax(ilevel))* delta_psi_sfc(inod_sfc_all)
                       end do
            ! map to finer grid
               if(ilevel.ne.1) then
                       sfc_nonods_course = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
                       sfc_nonods_fine   = fin_sfc_nonods(ilevel)   - fin_sfc_nonods(ilevel-1)
                       call map_sfc_course_grid_2_fine_grid_vec( &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine, &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course)
                  if(.false.) then ! reduce delta on fine grid by factor of 2.
                     ipt=fin_sfc_nonods(ilevel-1)
                     delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)=0.5*delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)
                  endif
               endif
                    end do ! do ilevel=nlevel,ilevel_finish,-1
            !        ilevel=1
            !        print *,'fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1):', &
            !                 fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)
            !        sfc_nonods_fine = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
            !        print *,'delta_psi_sfc(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel)-1+sfc_nonods_fine):', &
            !                 delta_psi_sfc(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel)-1+sfc_nonods_fine)
            !        stop 29211
            ! 
            ! For ilevel=1 use Jacobi iteration with the original matrix...
                    ilevel=1
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       delta_psi_temp(inod)=delta_psi_sfc(inod_sfc) 
                    end do
                    delta_psi=delta_psi_temp
                 if(i_jacobi_full_matrix==1) then ! include Jacobi relaxation on full matrix.
                    do inod=1,nonods_no_bc
                       rr=resid_no_bc(inod)
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          rr = rr - a_no_bc(count)*delta_psi_temp(jnod) 
                       end do
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          if(jnod==inod) then ! diagonal...
                             rr = rr + a_no_bc(count)*delta_psi_temp(jnod) 
                             delta_psi(inod) = relax(ilevel) * rr /a_no_bc(count) &
                                               +(relax(ilevel)-1.0) * delta_psi_temp(inod)
                          endif
                       end do
                    end do
                  endif
                    psi_no_bc = psi_no_bc + delta_psi
                    print *,'just leaving sfc_solver_it_n'
            !        stop 2921
                    
                    return 
                    end subroutine sfc_solver_it_n
            ! 
            ! 
            ! 
            ! 
            ! Python interface is: 
            ! psi_no_bc = sfc_solver_it_unstructured(psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
            !                                 nonods_sfc_all_grids, nlevel, &
            !                                 a_no_bc, b_no_bc, relax, &
            !                                 fina_no_bc,cola_no_bc, sfc_node_ordering, &
            !                                 ncola_no_bc, nonods_no_bc, &
            !                                 nfilt_size_sfc)  
                    subroutine sfc_solver_it_unstructured(psi_no_bc, psi_no_bc_guess, a_sfc_all_un, &
                                             fina_sfc_all_un, cola_sfc_all_un, &
                                             ncola_sfc_all_un, fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, sfc_node_ordering, &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix)  
            ! Solve the system a_no_bc*psi_no_bc = b_no_bc with a single multi-grid iteration and 1 SFC. 
            ! it uses a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. 
            ! It does this with a kernal size of nfilt_size_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! if(iscale_matrices==1) then assume the matricies have been divided through by mass matrix.
            ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont.
            ! i_jacobi_full_matrix=1 then include Jacobi relaxation on full matrix, =0 dont.
            ! Default values: iscale_matrices=0, i_jacobi_on_finest_sfc=0, i_jacobi_full_matrix=1
            ! one must have either i_jacobi_on_finest_sfc=1 and/or i_jacobi_full_matrix=1
            ! 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods)
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola_no_bc, nonods_no_bc, nonods_sfc_all_grids, nlevel
                    integer, intent( in ) :: iscale_matrices, i_jacobi_on_finest_sfc, i_jacobi_full_matrix
                    integer, intent( in ) :: ncola_sfc_all_un
                    real, intent( out ) :: psi_no_bc(nonods_no_bc)
                    real, intent( in ) :: a_sfc_all_un(ncola_sfc_all_un) 
                    real, intent( in ) :: psi_no_bc_guess(nonods_no_bc), relax(nlevel) 
                    real, intent( in ) :: a_no_bc(ncola_no_bc), b_no_bc(nonods_no_bc)
                    integer, intent( in ) :: fin_sfc_nonods(nlevel+1)
                    integer, intent( in ) :: fina_sfc_all_un(nonods_sfc_all_grids+1)
                    integer, intent( in ) :: cola_sfc_all_un(ncola_sfc_all_un)
                    integer, intent( in ) :: fina_no_bc(nonods_no_bc+1), cola_no_bc(ncola_no_bc)
                    integer, intent( in ) :: sfc_node_ordering(nonods_no_bc)
            ! local variables...
                    real, allocatable :: resid_no_bc(:), resid_sfc_all(:), rhs_sfc_all(:)
                    real, allocatable :: delta_psi_temp(:),delta_psi(:),delta_psi_sfc(:)
                    integer, allocatable :: mida_sfc_all_un(:)
                    real rr
                    integer inod, count, jnod, inod_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer inod_sfc_all, ipt, inod_sfc_fine, inod_sfc_fine_all,inod_sfc_fine_all2
                    integer ilevel_finish, inod_sfc_all_start, inod_sfc_all_finish
                    integer jcol_sfc_all, jnod_sfc_all
            ! 
            ! calculate nlevel from nonods
                    print *,'just inside sfc_solver_it_unstructured'
            !        stop 2922
                    allocate(resid_no_bc(nonods_no_bc), resid_sfc_all(nonods_sfc_all_grids))
                    allocate(delta_psi_sfc(nonods_sfc_all_grids), delta_psi(nonods_no_bc))
                    allocate(rhs_sfc_all(nonods_sfc_all_grids), delta_psi_temp(nonods_no_bc))
                    allocate(mida_sfc_all_un(nonods_sfc_all_grids))
            ! 
            ! find the diagonal...
                    do inod_sfc_all = 1, nonods_sfc_all_grids  
                       do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                          jnod_sfc_all=cola_sfc_all_un(count)
                          if(jnod_sfc_all==inod_sfc_all) mida_sfc_all_un(inod_sfc_all)=count
                       end do
                    end do
            ! 
                    psi_no_bc = psi_no_bc_guess ! need to do this because of python interface (can not have an inout variable)
                    resid_no_bc=b_no_bc
                    do inod=1,nonods_no_bc
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
            !              print *,'inod,jnod,count,a_no_bc(count):',inod,jnod,count,a_no_bc(count)
                          resid_no_bc(inod)=resid_no_bc(inod)-a_no_bc(count)*psi_no_bc(jnod) 
                       end do
            !           stop 7
                    end do
            !        stop 229
            ! map to sfc ordering
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       resid_sfc_all(inod_sfc) = resid_no_bc(inod)
                    end do
            ! 
            ! coarsen the residual...
                    do ilevel=2,nlevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       if(iscale_matrices==1) then ! assume the matricies have been divided through by mass matrix...
                          ipt=fin_sfc_nonods(ilevel)
                          resid_sfc_all(ipt:ipt+sfc_nonods_course-1)=0.5*resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                       endif
            !           print *,'ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1):', &
            !                    ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                    end do
            !        stop 227
            ! 
            ! perform Jacobi relaxation on the 1d SFC and on each SFC grid level up to the 2nd or 1st. 
                    delta_psi_sfc = 0.0
                    rhs_sfc_all = 0.0
            !         print *,'ifilt_diag:',ifilt_diag
            ! 
            ! Jacobi relaxation on the all grids...
                    ilevel_finish=2-i_jacobi_on_finest_sfc ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont
                    do ilevel=nlevel,ilevel_finish,-1
            !           print *,'ilevel=',ilevel
            !        do ilevel=nlevel-1,1,-1
                       inod_sfc_all_start  = fin_sfc_nonods(ilevel)
                       inod_sfc_all_finish = fin_sfc_nonods(ilevel+1)-1
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) 
                       end do
            !           print *,'h1'
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                             jcol_sfc_all = cola_sfc_all_un(count) 
                             rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                -a_sfc_all_un(count) * delta_psi_sfc(jcol_sfc_all) 
                          end do  
                       end do    
            !           print *,'h2'
            ! we have included the diagonal so take it away again...
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish    
                          rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                +a_sfc_all_un(mida_sfc_all_un(inod_sfc_all)) * delta_psi_sfc(inod_sfc_all)
            !              the_elthorne_variable   = 7e7*a_sfc(imid_ifilt,inod_sfc_all) * delta_psi_sfc(inod_sfc_all)
                       end do
            ! Jacobi relaxation...
                       do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          delta_psi_sfc(inod_sfc_all)  = &
                                 relax(ilevel) * rhs_sfc_all(inod_sfc_all) / a_sfc_all_un(mida_sfc_all_un(inod_sfc_all)) &
                                                       +(1.-relax(ilevel))* delta_psi_sfc(inod_sfc_all)
                       end do
            ! map to finer grid
               if(ilevel.ne.1) then
                       sfc_nonods_course = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
                       sfc_nonods_fine   = fin_sfc_nonods(ilevel)   - fin_sfc_nonods(ilevel-1)
                       call map_sfc_course_grid_2_fine_grid_vec( &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine, &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course)
                  if(.false.) then ! reduce delta on fine grid by factor of 2.
                     ipt=fin_sfc_nonods(ilevel-1)
                     delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)=0.5*delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)
                  endif
               endif
                    end do ! do ilevel=nlevel,ilevel_finish,-1
            ! 
            ! For ilevel=1 use Jacobi iteration with the original matrix...
                    ilevel=1
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       delta_psi_temp(inod)=delta_psi_sfc(inod_sfc) 
                    end do
                    delta_psi=delta_psi_temp
                 if(i_jacobi_full_matrix==1) then ! include Jacobi relaxation on full matrix.
                    do inod=1,nonods_no_bc
                       rr=resid_no_bc(inod)
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          rr = rr - a_no_bc(count)*delta_psi_temp(jnod) 
                       end do
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          if(jnod==inod) then ! diagonal...
                             rr = rr + a_no_bc(count)*delta_psi_temp(jnod) 
                             delta_psi(inod) = relax(ilevel) * rr /a_no_bc(count) &
                                               +(relax(ilevel)-1.0) * delta_psi_temp(inod)
                          endif
                       end do
                    end do
                  endif
                    psi_no_bc = psi_no_bc + delta_psi
                    print *,'just leaving sfc_solver_it_unstructured'
            !        stop 2921
                    
                    return 
                    end subroutine sfc_solver_it_unstructured
            ! 
            ! 
            ! 
            ! Python interface is: 
            ! psi_no_bc = sfc_solver_it_unstructured_fcycle(psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
            !                                 nonods_sfc_all_grids, nlevel, &
            !                                 a_no_bc, b_no_bc, relax, &
            !                                 fina_no_bc,cola_no_bc, sfc_node_ordering, &
            !                                 ncola_no_bc, nonods_no_bc, &
            !                                 nfilt_size_sfc)  
                    subroutine sfc_solver_it_unstructured_fcycle(psi_no_bc, psi_no_bc_guess, a_sfc_all_un, &
                                             fina_sfc_all_un, cola_sfc_all_un, &
                                             ncola_sfc_all_un, fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax, &
                                             fina_no_bc,cola_no_bc, sfc_node_ordering, &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix, &
                                             top_level)  
            ! Solve the system a_no_bc*psi_no_bc = b_no_bc with a single multi-grid iteration and 1 SFC. 
            ! it uses a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. 
            ! It does this with a kernal size of nfilt_size_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! if(iscale_matrices==1) then assume the matricies have been divided through by mass matrix.
            ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont.
            ! i_jacobi_full_matrix=1 then include Jacobi relaxation on full matrix, =0 dont.
            ! Default values: iscale_matrices=0, i_jacobi_on_finest_sfc=0, i_jacobi_full_matrix=1
            ! one must have either i_jacobi_on_finest_sfc=1 and/or i_jacobi_full_matrix=1
            ! 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods)
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola_no_bc, nonods_no_bc, nonods_sfc_all_grids, nlevel
                    integer, intent( in ) :: iscale_matrices, i_jacobi_on_finest_sfc, i_jacobi_full_matrix
                    integer, intent( in ) :: top_level
                    integer, intent( in ) :: ncola_sfc_all_un
                    real, intent( out ) :: psi_no_bc(nonods_no_bc)
                    real, intent( in ) :: a_sfc_all_un(ncola_sfc_all_un) 
                    real, intent( in ) :: psi_no_bc_guess(nonods_no_bc), relax(nlevel) 
                    real, intent( in ) :: a_no_bc(ncola_no_bc), b_no_bc(nonods_no_bc)
                    integer, intent( in ) :: fin_sfc_nonods(nlevel+1)
                    integer, intent( in ) :: fina_sfc_all_un(nonods_sfc_all_grids+1)
                    integer, intent( in ) :: cola_sfc_all_un(ncola_sfc_all_un)
                    integer, intent( in ) :: fina_no_bc(nonods_no_bc+1), cola_no_bc(ncola_no_bc)
                    integer, intent( in ) :: sfc_node_ordering(nonods_no_bc)
            ! local variables...
                    real, allocatable :: resid_no_bc(:), resid_sfc_all(:), rhs_sfc_all(:)
                    real, allocatable :: delta_psi_temp(:),delta_psi(:),delta_psi_sfc(:)
                    integer, allocatable :: mida_sfc_all_un(:)
                    real rr
                    integer inod, count, jnod, inod_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer inod_sfc_all, ipt, inod_sfc_fine, inod_sfc_fine_all,inod_sfc_fine_all2
                    integer ilevel_finish, inod_sfc_all_start, inod_sfc_all_finish
                    integer jcol_sfc_all, jnod_sfc_all, icycle,ncycle,icycle_start,icycle_top
            ! 
            ! calculate nlevel from nonods
                    print *,'just inside sfc_solver_it_unstructured_fcycle'
            !        stop 2922
                    allocate(resid_no_bc(nonods_no_bc), resid_sfc_all(nonods_sfc_all_grids))
                    allocate(delta_psi_sfc(nonods_sfc_all_grids), delta_psi(nonods_no_bc))
                    allocate(rhs_sfc_all(nonods_sfc_all_grids), delta_psi_temp(nonods_no_bc))
                    allocate(mida_sfc_all_un(nonods_sfc_all_grids))
            ! 
            ! find the diagonal...
                    do inod_sfc_all = 1, nonods_sfc_all_grids  
                       do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                          jnod_sfc_all=cola_sfc_all_un(count)
                          if(jnod_sfc_all==inod_sfc_all) mida_sfc_all_un(inod_sfc_all)=count
                       end do
                    end do
            ! 
                    psi_no_bc = psi_no_bc_guess ! need to do this because of python interface (can not have an inout variable)
                    resid_no_bc=b_no_bc
                    do inod=1,nonods_no_bc
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
            !              print *,'inod,jnod,count,a_no_bc(count):',inod,jnod,count,a_no_bc(count)
                          resid_no_bc(inod)=resid_no_bc(inod)-a_no_bc(count)*psi_no_bc(jnod) 
                       end do
            !           stop 7
                    end do
            !        stop 229
            ! map to sfc ordering
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       resid_sfc_all(inod_sfc) = resid_no_bc(inod)
                    end do
            ! 
                    delta_psi_sfc = 0.0
                    ncycle=nlevel-2
                    ncycle=0
                 do icycle=0,ncycle
                    icycle_start=nlevel-icycle
                    icycle_top=nlevel-1-icycle
                    if(icycle==0) icycle_start=2
                    if(.true.) then
                       ilevel=icycle_start
                       inod_sfc_all_start  = fin_sfc_nonods(ilevel)
                       inod_sfc_all_finish = fin_sfc_nonods(ilevel+1)-1
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                             jcol_sfc_all = cola_sfc_all_un(count) 
                             resid_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) &
                                                -a_sfc_all_un(count) * delta_psi_sfc(jcol_sfc_all) 
                          end do  
                       end do    
                    endif
            ! coarsen the residual...
                    do ilevel=icycle_start,nlevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       if(iscale_matrices==1) then ! assume the matricies have been divided through by mass matrix...
                          ipt=fin_sfc_nonods(ilevel)
                          resid_sfc_all(ipt:ipt+sfc_nonods_course-1)=0.5*resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                       endif
            !           print *,'ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1):', &
            !                    ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                    end do
            !        stop 227
            ! 
            ! perform Jacobi relaxation on the 1d SFC and on each SFC grid level up to the 2nd or 1st. 
            !        rhs_sfc_all = 0.0
            !         print *,'ifilt_diag:',ifilt_diag
            ! 
            ! Jacobi relaxation on the all grids...
            !        ilevel_finish=2-i_jacobi_on_finest_sfc ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont
            !        do ilevel=nlevel,max(icycle_top,2),-1
                    do ilevel=nlevel,2,-1
            !        do ilevel=nlevel,max(top_level,2),-1
            !           print *,'ilevel=',ilevel
            !        do ilevel=nlevel-1,1,-1
                    if(ilevel.ge.top_level) then
                       inod_sfc_all_start  = fin_sfc_nonods(ilevel)
                       inod_sfc_all_finish = fin_sfc_nonods(ilevel+1)-1
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) 
                       end do
            !           print *,'h1'
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                             jcol_sfc_all = cola_sfc_all_un(count) 
                             rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                -a_sfc_all_un(count) * delta_psi_sfc(jcol_sfc_all) 
                          end do  
                       end do    
            !           print *,'h2'
            ! we have included the diagonal so take it away again...
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish    
                          rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                +a_sfc_all_un(mida_sfc_all_un(inod_sfc_all)) * delta_psi_sfc(inod_sfc_all)
            !              the_elthorne_variable   = 7e7*a_sfc(imid_ifilt,inod_sfc_all) * delta_psi_sfc(inod_sfc_all)
                       end do
            ! Jacobi relaxation...
                       do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          delta_psi_sfc(inod_sfc_all)  = &
                                 relax(ilevel) * rhs_sfc_all(inod_sfc_all) / a_sfc_all_un(mida_sfc_all_un(inod_sfc_all)) &
                                                       +(1.-relax(ilevel))* delta_psi_sfc(inod_sfc_all)
                       end do
                     endif
            ! map to finer grid
               if(ilevel.ne.1) then
                       sfc_nonods_course = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
                       sfc_nonods_fine   = fin_sfc_nonods(ilevel)   - fin_sfc_nonods(ilevel-1)
                       call map_sfc_course_grid_2_fine_grid_vec( &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine, &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course)
                  if(.false.) then ! reduce delta on fine grid by factor of 2.
                     ipt=fin_sfc_nonods(ilevel-1)
                     delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)=0.5*delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)
                  endif
               endif
            ! recalculate residual *******
                if(.false.) then
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                             jcol_sfc_all = cola_sfc_all_un(count) 
                             resid_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) &
                                                -a_sfc_all_un(count) * delta_psi_sfc(jcol_sfc_all) 
                          end do  
                       end do    
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          delta_psi_sfc(inod_sfc_all)=0.0
                       end do
                endif
            ! recalculate residual *******
                    end do ! do ilevel=nlevel,ilevel_finish,-1
                 end do ! do icycle=1,ncycle
            ! 
            ! For ilevel=1 use Jacobi iteration with the original matrix...
                    ilevel=1
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       delta_psi_temp(inod)=delta_psi_sfc(inod_sfc) 
                       delta_psi(inod)=delta_psi_sfc(inod_sfc) 
                    end do
               if(top_level==1) then
            !   if(.true.) then
                    delta_psi=delta_psi_temp
                 if(i_jacobi_full_matrix==1) then ! include Jacobi relaxation on full matrix.
                    do inod=1,nonods_no_bc
                       rr=resid_no_bc(inod)
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          rr = rr - a_no_bc(count)*delta_psi_temp(jnod) 
                       end do
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          if(jnod==inod) then ! diagonal...
                             rr = rr + a_no_bc(count)*delta_psi_temp(jnod) 
                             delta_psi(inod) = relax(ilevel) * rr /a_no_bc(count) &
                                               +(relax(ilevel)-1.0) * delta_psi_temp(inod)
                          endif
                       end do
                    end do
                  endif
               endif
                    psi_no_bc = psi_no_bc + delta_psi
                    print *,'just leaving sfc_solver_it_unstructured_fcycle'
            !        stop 2921
                    
                    return 
                    end subroutine sfc_solver_it_unstructured_fcycle
            ! 
            ! 
            ! 
            ! 
            ! Python interface is: 
            ! psi_no_bc = sfc_solver_it_unstructured_vcycle(psi_no_bc_guess, a_sfc, fin_sfc_nonods, &
            !                                 nonods_sfc_all_grids, nlevel, &
            !                                 a_no_bc, b_no_bc, relax,relax_down, &
            !                                 fina_no_bc,cola_no_bc, sfc_node_ordering, &
            !                                 ncola_no_bc, nonods_no_bc, &
            !                                 nfilt_size_sfc)  
                    subroutine sfc_solver_it_unstructured_vcycle(psi_no_bc, psi_no_bc_guess, a_sfc_all_un, &
                                             fina_sfc_all_un, cola_sfc_all_un, &
                                             ncola_sfc_all_un, fin_sfc_nonods, &
                                             nonods_sfc_all_grids, nlevel, &
                                             a_no_bc, b_no_bc, relax,relax_down, &
                                             fina_no_bc,cola_no_bc, sfc_node_ordering, &
                                             ncola_no_bc, nonods_no_bc, iscale_matrices, &
                                             i_jacobi_on_finest_sfc, i_jacobi_full_matrix)  
            ! Solve the system a_no_bc*psi_no_bc = b_no_bc with a single multi-grid iteration and 1 SFC. 
            ! it uses a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. 
            ! It does this with a kernal size of nfilt_size_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! if(iscale_matrices==1) then assume the matricies have been divided through by mass matrix.
            ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont.
            ! i_jacobi_full_matrix=1 then include Jacobi relaxation on full matrix, =0 dont.
            ! Default values: iscale_matrices=0, i_jacobi_on_finest_sfc=0, i_jacobi_full_matrix=1
            ! one must have either i_jacobi_on_finest_sfc=1 and/or i_jacobi_full_matrix=1
            ! 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods)
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola_no_bc, nonods_no_bc, nonods_sfc_all_grids, nlevel
                    integer, intent( in ) :: iscale_matrices, i_jacobi_on_finest_sfc, i_jacobi_full_matrix
                    integer, intent( in ) :: ncola_sfc_all_un
                    real, intent( out ) :: psi_no_bc(nonods_no_bc)
                    real, intent( in ) :: a_sfc_all_un(ncola_sfc_all_un) 
                    real, intent( in ) :: psi_no_bc_guess(nonods_no_bc), relax(nlevel), relax_down(nlevel) 
                    real, intent( in ) :: a_no_bc(ncola_no_bc), b_no_bc(nonods_no_bc)
                    integer, intent( in ) :: fin_sfc_nonods(nlevel+1)
                    integer, intent( in ) :: fina_sfc_all_un(nonods_sfc_all_grids+1)
                    integer, intent( in ) :: cola_sfc_all_un(ncola_sfc_all_un)
                    integer, intent( in ) :: fina_no_bc(nonods_no_bc+1), cola_no_bc(ncola_no_bc)
                    integer, intent( in ) :: sfc_node_ordering(nonods_no_bc)
            ! local variables...
                    real, allocatable :: resid_no_bc(:), resid_sfc_all(:), rhs_sfc_all(:)
                    real, allocatable :: delta_psi_temp(:),delta_psi(:),delta_psi_sfc(:),delta_psi_sfc2(:)
                    integer, allocatable :: mida_sfc_all_un(:)
                    real rr
                    integer inod, count, jnod, inod_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer inod_sfc_all, ipt, inod_sfc_fine, inod_sfc_fine_all,inod_sfc_fine_all2
                    integer ilevel_finish, inod_sfc_all_start, inod_sfc_all_finish
                    integer jcol_sfc_all, jnod_sfc_all
            ! 
            ! calculate nlevel from nonods
                    print *,'just inside sfc_solver_it_unstructured_vcycle'
            !        stop 2922
                    allocate(resid_no_bc(nonods_no_bc), resid_sfc_all(nonods_sfc_all_grids))
                    allocate(delta_psi_sfc(nonods_sfc_all_grids), delta_psi(nonods_no_bc))
                    allocate(delta_psi_sfc2(nonods_sfc_all_grids))
                    allocate(rhs_sfc_all(nonods_sfc_all_grids), delta_psi_temp(nonods_no_bc))
                    allocate(mida_sfc_all_un(nonods_sfc_all_grids))
            ! 
            ! find the diagonal...
                    do inod_sfc_all = 1, nonods_sfc_all_grids  
                       do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                          jnod_sfc_all=cola_sfc_all_un(count)
                          if(jnod_sfc_all==inod_sfc_all) mida_sfc_all_un(inod_sfc_all)=count
                       end do
                    end do
            ! 
                    psi_no_bc = psi_no_bc_guess ! need to do this because of python interface (can not have an inout variable)
                    resid_no_bc=b_no_bc
                    do inod=1,nonods_no_bc
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
            !              print *,'inod,jnod,count,a_no_bc(count):',inod,jnod,count,a_no_bc(count)
                          resid_no_bc(inod)=resid_no_bc(inod)-a_no_bc(count)*psi_no_bc(jnod) 
                       end do
            !           stop 7
                    end do
            !        stop 229
            ! map to sfc ordering
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       resid_sfc_all(inod_sfc) = resid_no_bc(inod)
                    end do
            ! 
                    delta_psi_sfc2=0.0
            ! coarsen the residual...
            !        do ilevel=2,nlevel
                    do ilevel=1,nlevel
                  if(ilevel.ne.1) then
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     resid_sfc_all(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           call map_sfc_fine_grid_2_course_grid_vec( &
            !                                         delta_psi_sfc2(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
            !                                         delta_psi_sfc2(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       if(iscale_matrices==1) then ! assume the matricies have been divided through by mass matrix...
                          ipt=fin_sfc_nonods(ilevel)
                          resid_sfc_all(ipt:ipt+sfc_nonods_course-1)=0.5*resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
            !              delta_psi_sfc2(ipt:ipt+sfc_nonods_course-1)=0.5*resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                       endif
                  endif
            ! 
                  if(.true.) then ! perform a Jacobi relaxation and form a residual again resid_sfc_all. 
                  if(ilevel.ne.nlevel) then
                  if(ilevel.ne.1) then
                       inod_sfc_all_start  = fin_sfc_nonods(ilevel)
                       inod_sfc_all_finish = fin_sfc_nonods(ilevel+1)-1
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all)
                          delta_psi_sfc2(inod_sfc_all) = relax_down(ilevel) * resid_sfc_all(inod_sfc_all) &
                                                        /a_sfc_all_un(mida_sfc_all_un(inod_sfc_all))
                       end do
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                             jcol_sfc_all = cola_sfc_all_un(count) 
                             rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                -a_sfc_all_un(count) * delta_psi_sfc2(jcol_sfc_all) 
                          end do  
                       end do  
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          resid_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) 
                       end do
                  endif
                  endif
                  endif
            !           print *,'ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1):', &
            !                    ilevel,resid_sfc_all(ipt:ipt+sfc_nonods_course-1)
                    end do
            !        stop 227
            ! 
            ! perform Jacobi relaxation on the 1d SFC and on each SFC grid level up to the 2nd or 1st. 
                    delta_psi_sfc = 0.0
                    rhs_sfc_all = 0.0
            !         print *,'ifilt_diag:',ifilt_diag
            ! 
            ! Jacobi relaxation on the all grids...
                    ilevel_finish=2-i_jacobi_on_finest_sfc ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont
                    do ilevel=nlevel,ilevel_finish,-1
            !           print *,'ilevel=',ilevel
            !        do ilevel=nlevel-1,1,-1
                       inod_sfc_all_start  = fin_sfc_nonods(ilevel)
                       inod_sfc_all_finish = fin_sfc_nonods(ilevel+1)-1
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          rhs_sfc_all(inod_sfc_all) = resid_sfc_all(inod_sfc_all) 
                       end do
            !           print *,'h1'
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish
                          do count=fina_sfc_all_un(inod_sfc_all),fina_sfc_all_un(inod_sfc_all+1)-1
                             jcol_sfc_all = cola_sfc_all_un(count) 
                             rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                -a_sfc_all_un(count) * delta_psi_sfc(jcol_sfc_all) 
                          end do  
                       end do    
            !           print *,'h2'
            ! we have included the diagonal so take it away again...
                       do inod_sfc_all = inod_sfc_all_start, inod_sfc_all_finish    
                          rhs_sfc_all(inod_sfc_all) = rhs_sfc_all(inod_sfc_all) &
                                                +a_sfc_all_un(mida_sfc_all_un(inod_sfc_all)) * delta_psi_sfc(inod_sfc_all)
            !              the_elthorne_variable   = 7e7*a_sfc(imid_ifilt,inod_sfc_all) * delta_psi_sfc(inod_sfc_all)
                       end do
            ! Jacobi relaxation...
                       do inod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1 
                          delta_psi_sfc(inod_sfc_all)  = &
                                 relax(ilevel) * rhs_sfc_all(inod_sfc_all) / a_sfc_all_un(mida_sfc_all_un(inod_sfc_all)) &
                                                       +(1.-relax(ilevel))* delta_psi_sfc(inod_sfc_all)
                       end do
            ! map to finer grid
               if(ilevel.ne.1) then
                       sfc_nonods_course = fin_sfc_nonods(ilevel+1) - fin_sfc_nonods(ilevel)
                       sfc_nonods_fine   = fin_sfc_nonods(ilevel)   - fin_sfc_nonods(ilevel-1)
                       call map_sfc_course_grid_2_fine_grid_vec( &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine, &
                                                     delta_psi_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course)
                  if(.false.) then ! reduce delta on fine grid by factor of 2.
                     ipt=fin_sfc_nonods(ilevel-1)
                     delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)=0.5*delta_psi_sfc(ipt:ipt+sfc_nonods_fine-1)
                  endif
               endif
                  if(.false.) then
                     delta_psi_sfc(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel+1)-1) &
                    =delta_psi_sfc(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel+1)-1) &
                    +delta_psi_sfc2(fin_sfc_nonods(ilevel):fin_sfc_nonods(ilevel+1)-1) 
                  endif
                    end do ! do ilevel=nlevel,ilevel_finish,-1
            ! 
            ! For ilevel=1 use Jacobi iteration with the original matrix...
                    ilevel=1
                    do inod=1,nonods_no_bc
                       inod_sfc=sfc_node_ordering(inod)
                       delta_psi_temp(inod)=delta_psi_sfc(inod_sfc) 
                    end do
                    delta_psi=delta_psi_temp
                 if(i_jacobi_full_matrix==1) then ! include Jacobi relaxation on full matrix.
                    do inod=1,nonods_no_bc
                       rr=resid_no_bc(inod)
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          rr = rr - a_no_bc(count)*delta_psi_temp(jnod) 
                       end do
                       do count=fina_no_bc(inod),fina_no_bc(inod+1)-1
                          jnod=cola_no_bc(count)
                          if(jnod==inod) then ! diagonal...
                             rr = rr + a_no_bc(count)*delta_psi_temp(jnod) 
                             delta_psi(inod) = relax(ilevel) * rr /a_no_bc(count) &
                                               +(relax(ilevel)-1.0) * delta_psi_temp(inod)
                          endif
                       end do
                    end do
                  endif
                    psi_no_bc = psi_no_bc + delta_psi
                    print *,'just leaving sfc_solver_it_unstructured'
            !        stop 2921
                    
                    return 
                    end subroutine sfc_solver_it_unstructured_vcycle
            ! 
            ! 
            ! 
            ! 
            ! in python: 
            ! t_old, t_new, x_all, ndglno, fina, cola  = set_up_grid_problem(dx, dy, ncola, nx, ny, nloc, ndim)
                    subroutine set_up_grid_problem(t_old, t_new, x_all, ndglno, fina, cola, &
                                                   dx, dy, ncola, nx, ny, nloc, ndim) 
                    implicit none
            ! set up grid
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
                    
            ! local variables...
            ! 2d:
            ! nx=no of nodes across, ny=no of nodes up. 
                    integer, intent( in ) :: ncola, nx, ny, nloc, ndim
            !        integer, parameter :: nonods=nx*ny, totele=(nx-1)*(ny-1)
                    real, intent( out ) :: t_old(nx*ny), t_new(nx*ny), x_all(ndim,(nx+1)*(ny+1)*nloc) 
                    integer, intent( out ) ::  ndglno(nloc*(nx+1)*(ny+1)), fina(nx*ny+1), cola(ncola) 
                    real, intent( in ) :: dx, dy
            ! example of node ordering...
            !      7-----8-----9
            !      !     !     !
            !      !     !     !        
            !      4-----5-----6
            !      !     !     !
            !      !     !     !        
            !      1-----2-----3
            ! filters for ann:
            ! local variables...
                    integer npoly,ele_type, iloc,count
                    integer enx_i, eny_j, ele, i,j, ii,jj, iii,jjj, inod, jnod, itime
            ! ! 
                    print *,'here in setup grid'
            !        stop 23
            ! 
            
                    t_old=0.0
                    do enx_i=1,nx-1
                    do eny_j=1,ny-1
                       ele=(eny_j-1)*(nx-1)+enx_i
            !
                       do ii=1,2
                       do jj=1,2
            
                          iloc=(jj-1)*2+ii 
                          inod = (eny_j-2 +jj)*nx + enx_i + ii-1
                          ndglno((ele-1)*nloc+iloc)=inod 
                          x_all(1,(ele-1)*nloc+iloc) = real(enx_i-2+ii ) * dx
                          x_all(2,(ele-1)*nloc+iloc) = real(eny_j-2+jj ) * dy 
                          if(  (x_all(1,(ele-1)*nloc+iloc)>1.9) &
                          .and.(x_all(1,(ele-1)*nloc+iloc)<3.9) ) then
                             if(  (x_all(2,(ele-1)*nloc+iloc)>1.9) &
                             .and.(x_all(2,(ele-1)*nloc+iloc)<3.9) ) then
                                 t_old(inod)=1.0
                             endif
                          endif
                       end do
                       end do
                    end do
                    end do
                    t_new=t_old
            !        print *,'t_new:',t_new
            !        stop 22
            !
                    count=0
                    do j=1,ny
                    do i=1,nx
                       inod=(j-1)*nx+i
                       fina(inod)=count+1
                       do jj=-1,1
                       do ii=-1,1
                          iii=i+ii
                          jjj=j+jj
                          if((iii>0).and.(jjj>0)) then 
                          if((iii<nx+1).and.(jjj<ny+1)) then 
                             jnod=(jjj-1)*nx + iii
                             count=count+1
                             cola(count)=jnod
                          endif
                          endif
                       end do
                       end do
                    end do
                    end do
                    fina(nx*ny+1)=count+1 
                    end subroutine set_up_grid_problem
            ! 
            ! 
            ! 
            ! 
            ! in python:
            ! nlevel = calculate_nlevel_sfc(nonods)
                    subroutine calculate_nlevel_sfc(nlevel,nonods)
            ! this subroutine calculates the number of multi-grid levels for a 
            ! space filling curve multi-grid or 1d multi-grid applied to nonods nodes. 
                    implicit none
                    integer, intent( in ) :: nonods
                    integer, intent( out ) :: nlevel
            ! local variables...
                    integer sfc_nonods_fine,sfc_nonods_course,ilevel
            ! coarsen...
                    if(nonods==1) then
                       nlevel=1 
                    else
                       sfc_nonods_course=nonods
                       do ilevel=2,200
                          sfc_nonods_fine=sfc_nonods_course
                          sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                          nlevel=ilevel
                          if(sfc_nonods_course==1) exit
                       end do
                    endif
                    return
                    end subroutine calculate_nlevel_sfc
            ! 
            ! 
            ! 
            ! 
            ! in python:
            ! a_sfc, b_sfc, ml_sfc, fin_sfc_nonods, nonods_sfc_all_grids, nlevel = best_sfc_mapping_to_sfc_matrix( &
            !                                     a, b, ml, &
            !                                     fina,cola, ncola, sfc_node_ordering, &
            !                                     nonods, max_nonods_sfc_all_grids, max_nlevel) 
                  subroutine best_sfc_mapping_to_sfc_matrix_3(a_sfc, b_sfc, ml_sfc, &
                                                 fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                                 a, b, ml, relax_keep_off, &
                                                 fina,cola, sfc_node_ordering, ncola, &
                                                 nonods, max_nonods_sfc_all_grids, max_nlevel, &
                                                 nfilt_size_sfc) 
            ! It does this with a kernal size of 3. 
            ! this subroutine finds the space filling curve representation of matrix eqns A T=b 
            ! - that is it forms matrix a and vector b and the soln vector is T 
            ! although T is not needed here. 
            ! It does this with a kernal size of 3. 
            ! It uses the BEST approach we can to form these tridigonal matrix approximations on different grids. 
            ! It also puts the vector b in space filling curve ordering. 
            ! it forms a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. Similarly for the vectors b,ml 
            ! which are stored in b_sfc, ml_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(fem node number)=i_sfc_order. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods). 
            !        relax_keep_off=0.7 ! works -how much of the not found value to add into the diagonal of the sfc matrix a_sfc
            ! relax_keep_off=0.0 (dont add any - more stable); relax_keep_off=1.0 (more accurate). =0.5 compromise. 
            !        relax_keep_off=0.5 ! works for hard problem =0.9 not work, =0.7 works, =0.0 works
            !        relax_keep_off=0.75 ! works for hard problem =0.9 not work, =0.8 not work, =0.7 works, =0.0 works
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola, nonods, max_nonods_sfc_all_grids, max_nlevel, nfilt_size_sfc
                    real, intent( out ) :: a_sfc(nfilt_size_sfc,max_nonods_sfc_all_grids), &
                                           b_sfc(max_nonods_sfc_all_grids), &
                                           ml_sfc(max_nonods_sfc_all_grids) 
                    real, intent( in ) :: a(ncola), b(nonods), ml(nonods)
                    real, intent( in ) :: relax_keep_off
                    integer, intent( out ) :: nonods_sfc_all_grids, fin_sfc_nonods(max_nlevel+1), nlevel
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    integer, intent( in ) :: sfc_node_ordering(nonods)
            ! local variables...
                    integer, allocatable :: sfc_node_ordering_inverse(:)
                    real, allocatable :: pot_diag_a_sfc(:)
                    integer i, count, nodj, nodi_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod, ipt
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
            ! 
                    print *,'2-just inside best_sfc_mapping_to_sfc_matrix_3'
            ! calculate nlevel from nonods
                    call calculate_nlevel_sfc(nlevel,nonods)
            ! form SFC matrix...
                    a_sfc(:,:)=0.0
                    b_sfc(:)=0.0
                    ml_sfc(:)=0.0
                   do ifinest_nod=1,nonods
                      ifinest_nod_sfc = sfc_node_ordering(ifinest_nod) 
                      b_sfc(ifinest_nod_sfc)=b(ifinest_nod)
                      ml_sfc(ifinest_nod_sfc)=ml(ifinest_nod)
                   end do 
            !       print *,'here 1 nlevel:',nlevel
            ! 
            ! coarsen...
                    sfc_nonods_accum=1
                    fin_sfc_nonods(1)=sfc_nonods_accum
                    sfc_nonods_accum=sfc_nonods_accum + nonods
                    fin_sfc_nonods(2)=sfc_nonods_accum 
                    do ilevel=2,nlevel
            !           print *,'ilevel=',ilevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       if(sfc_nonods_fine.le.1) stop 13331 ! something went wrong. 
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
            !           call map_sfc_course_grid( a_sfc(:,fin_sfc_nonods(ilevel)),sfc_nonods_course, &
            !                                     a_sfc(:,fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           print *,'fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel-1):', &
            !                    fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel-1)
            !           print *,'max_nonods_sfc_all_grids,sfc_nonods_course,sfc_nonods_fine:', &
            !                    max_nonods_sfc_all_grids,sfc_nonods_course,sfc_nonods_fine
            
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     ml_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     ml_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           ipt=fin_sfc_nonods(ilevel)
            !           print *,'ml_sfc(ipt:ipt+sfc_nonods_course-1):',ml_sfc(ipt:ipt+sfc_nonods_course-1)
            !           ipt=fin_sfc_nonods(ilevel-1)
            !           print *,'ml_sfc(ipt:ipt+sfc_nonods_fine-1):',ml_sfc(ipt:ipt+sfc_nonods_fine-1)
            !       print *,'here 1.1' 
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     b_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     b_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !       print *,'here 1.2' 
                       sfc_nonods_accum = sfc_nonods_accum + sfc_nonods_course
                       fin_sfc_nonods(ilevel+1)=sfc_nonods_accum
                    end do
                    nonods_sfc_all_grids=sfc_nonods_accum-1
                    if(max_nonods_sfc_all_grids<nonods_sfc_all_grids) then
                       print *,'run out of memory here stopping'
                       stop 2822
                    endif
                   print *,'here 2'
            !         stop 25
            ! sfc_node_ordering(nod) = new node numbering from current node number nod.
                    allocate(sfc_node_ordering_inverse(nonods))
                    do ifinest_nod=1,nonods
                       ifinest_nod_sfc = sfc_node_ordering(ifinest_nod) 
                       sfc_node_ordering_inverse(ifinest_nod_sfc) = ifinest_nod
                    end do 
            !       print *,'here 3'
            ! 
            ! coarsen the original matrix to form a_sfc on each grid level...
            !        relax_keep_off=0.7 ! works -how much of the not found value to add into the diagonal of the sfc matrix a_sfc
            ! relax_keep_off=0.0 (dont add any - more stable); relax_keep_off=1.0 (more accurate). =0.5 compromise. 
            !        relax_keep_off=0.5 ! works for hard problem =0.9 not work, =0.7 works, =0.0 works
            !        relax_keep_off=0.75 ! works for hard problem =0.9 not work, =0.8 not work, =0.7 works, =0.0 works
                    allocate(pot_diag_a_sfc(nonods_sfc_all_grids))
                    pot_diag_a_sfc=0.0
                    do ilevel=1,nlevel
            !           print *,'ilevel=',ilevel
                       ilevel2=2**(ilevel-1)
                       do ifinest_nod_sfc=1,nonods
                          icourse_nod_sfc = 1 + (ifinest_nod_sfc-1)/ilevel2
                          icourse_nod_sfc_displaced = icourse_nod_sfc + fin_sfc_nonods(ilevel) - 1
                          ifinest_nod = sfc_node_ordering_inverse(ifinest_nod_sfc) 
            
                          do count=fina(ifinest_nod),fina(ifinest_nod+1)-1
                             jfinest_nod=cola(count)
                             jfinest_nod_sfc = sfc_node_ordering(jfinest_nod)
                             jcourse_nod_sfc = 1 + (jfinest_nod_sfc-1)/ilevel2
                             if(jcourse_nod_sfc==icourse_nod_sfc-1) then
                                a_sfc(1,icourse_nod_sfc_displaced)=a_sfc(1,icourse_nod_sfc_displaced)+a(count)
                             else if(jcourse_nod_sfc==icourse_nod_sfc+1) then
                                a_sfc(3,icourse_nod_sfc_displaced)=a_sfc(3,icourse_nod_sfc_displaced)+a(count)
                             else if(jcourse_nod_sfc==icourse_nod_sfc) then
                                a_sfc(2,icourse_nod_sfc_displaced)=a_sfc(2,icourse_nod_sfc_displaced)+a(count) ! diagonal
                             else
            !                    if(ilevel>nlevel-7) then
            !                    a_sfc(2,icourse_nod_sfc_displaced)=a_sfc(2,icourse_nod_sfc_displaced)+a(count)
            !                    else
                                a_sfc(2,icourse_nod_sfc_displaced)=a_sfc(2,icourse_nod_sfc_displaced)+relax_keep_off*a(count) ! diagonal
            !                    endif
            !                    pot_diag_a_sfc(icourse_nod_sfc_displaced)=  &
            !                         pot_diag_a_sfc(icourse_nod_sfc_displaced) + a(count) ! diagonal
                             endif
                          end do
            
                       end do
                    end do
            
                  if(.false.) then
                    do icourse_nod_sfc_displaced=1,nonods_sfc_all_grids
                      if(.true.) then ! simplest and best
                         if(icourse_nod_sfc_displaced.lt.nonods_sfc_all_grids-70) then
                          a_sfc(2,icourse_nod_sfc_displaced)=a_sfc(2,icourse_nod_sfc_displaced) &
                           +relax_keep_off*pot_diag_a_sfc(icourse_nod_sfc_displaced) ! diagonal
                         endif
                      else ! variable method...
                       if(abs(a_sfc(1,icourse_nod_sfc_displaced))+abs(a_sfc(3,icourse_nod_sfc_displaced)).gt.1.e-2) then
            !           if(a_sfc(2,icourse_nod_sfc_displaced)+pot_diag_a_sfc(icourse_nod_sfc_displaced).gt.1.e-2) then
                          a_sfc(2,icourse_nod_sfc_displaced)=a_sfc(2,icourse_nod_sfc_displaced) &
                          +1.0*pot_diag_a_sfc(icourse_nod_sfc_displaced) ! diagonal
            !              +relax_keep_off*pot_diag_a_sfc(icourse_nod_sfc_displaced) ! diagonal
                       endif
                      endif
            !        do ifinest_nod_sfc=80,84
                       if(a_sfc(2,icourse_nod_sfc_displaced).lt.1.e-4) then
                          print *,'icourse_nod_sfc_displaced,a_sfc(:,icourse_nod_sfc_displaced):', &
                                   icourse_nod_sfc_displaced,a_sfc(:,icourse_nod_sfc_displaced)
                          stop 2211
                       end if
                    end do
                  endif
            !        stop 282
                    print *,'just leaving best_sfc_mapping_to_sfc_matrix_3'
                    return 
                    end subroutine best_sfc_mapping_to_sfc_matrix_3
            ! 
            ! 
            ! in python:
            ! a_sfc, b_sfc, ml_sfc, fin_sfc_nonods, nonods_sfc_all_grids, nlevel = best_sfc_mapping_to_sfc_matrix( &
            !                                     a, b, ml, &
            !                                     fina,cola, ncola, sfc_node_ordering, &
            !                                     nonods, max_nonods_sfc_all_grids, max_nlevel) 
                  subroutine best_sfc_mapping_to_sfc_matrix_n(a_sfc, b_sfc, ml_sfc, &
                                                 fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                                 a, b, ml, relax_keep_off, &
                                                 fina,cola, sfc_node_ordering, ncola, &
                                                 nonods, max_nonods_sfc_all_grids, max_nlevel, &
                                                 nfilt_size_sfc)  
            ! It does this with a kernal size of nfilt_size_sfc. 
            ! this subroutine finds the space filling curve representation of matrix eqns A T=b 
            ! - that is it forms matrix a and vector b and the soln vector is T 
            ! although T is not needed here. 
            ! It does this with a kernal size of nfilt_size_sfc. 
            ! It uses the BEST approach we can to form these tridigonal matrix approximations on different grids. 
            ! It also puts the vector b in space filling curve ordering. 
            ! it forms a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. Similarly for the vectors b,ml 
            ! which are stored in b_sfc, ml_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(fem node number)=i_sfc_order. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods). 
            !        relax_keep_off=0.7 ! works -how much of the not found value to add into the diagonal of the sfc matrix a_sfc
            ! relax_keep_off=0.0 (dont add any - more stable); relax_keep_off=1.0 (more accurate). =0.5 compromise. 
            !        relax_keep_off=0.5 ! works for hard problem =0.9 not work, =0.7 works, =0.0 works
            !        relax_keep_off=0.75 ! works for hard problem =0.9 not work, =0.8 not work, =0.7 works, =0.0 works
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola, nonods, max_nonods_sfc_all_grids, max_nlevel, nfilt_size_sfc
                    real, intent( out ) :: a_sfc(nfilt_size_sfc,max_nonods_sfc_all_grids), &
                                           b_sfc(max_nonods_sfc_all_grids), &
                                           ml_sfc(max_nonods_sfc_all_grids) 
                    real, intent( in ) :: a(ncola), b(nonods), ml(nonods)
                    real, intent( in ) :: relax_keep_off
                    integer, intent( out ) :: nonods_sfc_all_grids, fin_sfc_nonods(max_nlevel+1), nlevel
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    integer, intent( in ) :: sfc_node_ordering(nonods)
            ! local variables...
                    integer, allocatable :: sfc_node_ordering_inverse(:)
                    real, allocatable :: pot_diag_a_sfc(:)
                    integer i, count, nodj, nodi_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_displaced
                    integer ifinest_nod, jfinest_nod, ipt
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer ifilt, icent_ifilt, ifilt_diag
                    logical found
            ! 
                    print *,'2-just inside best_sfc_mapping_to_sfc_matrix_n'
            ! calculate nlevel from nonods
                    call calculate_nlevel_sfc(nlevel,nonods)
            ! 
                    ifilt_diag = 1 + nfilt_size_sfc/2
            ! form SFC matrix...
                    a_sfc(:,:)=0.0
                    b_sfc(:)=0.0
                    ml_sfc(:)=0.0
                   do ifinest_nod=1,nonods
                      ifinest_nod_sfc = sfc_node_ordering(ifinest_nod) 
                      b_sfc(ifinest_nod_sfc)=b(ifinest_nod)
                      ml_sfc(ifinest_nod_sfc)=ml(ifinest_nod)
                   end do 
            !       print *,'here 1 nlevel:',nlevel
            ! 
            ! coarsen...
                    sfc_nonods_accum=1
                    fin_sfc_nonods(1)=sfc_nonods_accum
                    sfc_nonods_accum=sfc_nonods_accum + nonods
                    fin_sfc_nonods(2)=sfc_nonods_accum 
                    do ilevel=2,nlevel
            !           print *,'ilevel=',ilevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       if(sfc_nonods_fine.le.1) stop 13331 ! something went wrong. 
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
            !           call map_sfc_course_grid( a_sfc(:,fin_sfc_nonods(ilevel)),sfc_nonods_course, &
            !                                     a_sfc(:,fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           print *,'fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel-1):', &
            !                    fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel-1)
            !           print *,'max_nonods_sfc_all_grids,sfc_nonods_course,sfc_nonods_fine:', &
            !                    max_nonods_sfc_all_grids,sfc_nonods_course,sfc_nonods_fine
            
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     ml_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     ml_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           ipt=fin_sfc_nonods(ilevel)
            !           print *,'ml_sfc(ipt:ipt+sfc_nonods_course-1):',ml_sfc(ipt:ipt+sfc_nonods_course-1)
            !           ipt=fin_sfc_nonods(ilevel-1)
            !           print *,'ml_sfc(ipt:ipt+sfc_nonods_fine-1):',ml_sfc(ipt:ipt+sfc_nonods_fine-1)
            !       print *,'here 1.1' 
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     b_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     b_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !       print *,'here 1.2' 
                       sfc_nonods_accum = sfc_nonods_accum + sfc_nonods_course
                       fin_sfc_nonods(ilevel+1)=sfc_nonods_accum
                    end do
                    nonods_sfc_all_grids=sfc_nonods_accum-1
                    if(max_nonods_sfc_all_grids<nonods_sfc_all_grids) then
                       print *,'run out of memory here stopping'
                       stop 2822
                    endif
                   print *,'here 2'
            !         stop 25
            ! sfc_node_ordering(nod) = new node numbering from current node number nod.
                    allocate(sfc_node_ordering_inverse(nonods))
                    do ifinest_nod=1,nonods
                       ifinest_nod_sfc = sfc_node_ordering(ifinest_nod) 
                       sfc_node_ordering_inverse(ifinest_nod_sfc) = ifinest_nod
                    end do 
            !       print *,'here 3'
            ! 
            ! coarsen the original matrix to form a_sfc on each grid level...
            !        relax_keep_off=0.7 ! works -how much of the not found value to add into the diagonal of the sfc matrix a_sfc
            ! relax_keep_off=0.0 (dont add any - more stable); relax_keep_off=1.0 (more accurate). =0.5 compromise. 
            !        relax_keep_off=0.5 ! works for hard problem =0.9 not work, =0.7 works, =0.0 works
            !        relax_keep_off=0.75 ! works for hard problem =0.9 not work, =0.8 not work, =0.7 works, =0.0 works
                    allocate(pot_diag_a_sfc(nonods_sfc_all_grids))
                    pot_diag_a_sfc=0.0
                    do ilevel=1,nlevel
            !           print *,'ilevel=',ilevel
                       ilevel2=2**(ilevel-1)
                       do ifinest_nod_sfc=1,nonods
                          icourse_nod_sfc = 1 + (ifinest_nod_sfc-1)/ilevel2
                          icourse_nod_sfc_displaced = icourse_nod_sfc + fin_sfc_nonods(ilevel) - 1
                          ifinest_nod = sfc_node_ordering_inverse(ifinest_nod_sfc) 
            
                          do count=fina(ifinest_nod),fina(ifinest_nod+1)-1
                             jfinest_nod=cola(count)
                             jfinest_nod_sfc = sfc_node_ordering(jfinest_nod)
                             jcourse_nod_sfc = 1 + (jfinest_nod_sfc-1)/ilevel2
                             found=.false. 
                             do ifilt = 1, nfilt_size_sfc
                                 icent_ifilt = ifilt - ifilt_diag
                                if(jcourse_nod_sfc==icourse_nod_sfc+icent_ifilt) then ! off diagonal and diagonal..
                                   a_sfc(ifilt,icourse_nod_sfc_displaced)=a_sfc(ifilt,icourse_nod_sfc_displaced)+a(count)
                                   found=.true. 
                                endif
                             end do
                             if(.not.found) then ! could not find it in the matrix sparcity so put on diagonal.
                               a_sfc(ifilt_diag,icourse_nod_sfc_displaced) &
                                   =a_sfc(ifilt_diag,icourse_nod_sfc_displaced)+relax_keep_off*a(count) ! diagonal
                             endif
                          end do ! do count=fina(ifinest_nod),fina(ifinest_nod+1)-1
            
                       end do
                    end do
            
            !        stop 282
                    print *,'just leaving best_sfc_mapping_to_sfc_matrix_n'
                    return 
                    end subroutine best_sfc_mapping_to_sfc_matrix_n
            ! 
            ! 
            ! 
            ! 
            ! in python:
            ! a_sfc, b_sfc, ml_sfc, fin_sfc_nonods, nonods_sfc_all_grids, nlevel = best_sfc_mapping_to_sfc_matrix( &
            !                                     a, b, ml, &
            !                                     fina,cola, ncola, sfc_node_ordering, &
            !                                     nonods, max_nonods_sfc_all_grids, max_nlevel) 
                  subroutine best_sfc_mapping_to_sfc_matrix_unstructured( &
                                                 a_sfc_all_un,fina_sfc_all_un, &
                                                 cola_sfc_all_un,ncola_sfc_all_un, &
                                                 b_sfc, ml_sfc, &
                                                 fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                                 a, b, ml,  &
                                                 fina,cola, sfc_node_ordering, ncola, &
                                                 nonods, max_nonods_sfc_all_grids, &
                                                 max_ncola_sfc_all_un, max_nlevel)  
            ! It does this with a kernal size of nfilt_size_sfc. 
            ! this subroutine finds the space filling curve representation of matrix eqns A T=b 
            ! - that is it forms matrix a and vector b and the soln vector is T 
            ! although T is not needed here. 
            ! It does this with a kernal size of nfilt_size_sfc. 
            ! It uses the BEST approach we can to form these tridigonal matrix approximations on different grids. 
            ! It also puts the vector b in space filling curve ordering. 
            ! it forms a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. Similarly for the vectors b,ml 
            ! which are stored in b_sfc, ml_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(fem node number)=i_sfc_order. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods). 
            !        relax_keep_off=0.7 ! works -how much of the not found value to add into the diagonal of the sfc matrix a_sfc
            ! relax_keep_off=0.0 (dont add any - more stable); relax_keep_off=1.0 (more accurate). =0.5 compromise. 
            !        relax_keep_off=0.5 ! works for hard problem =0.9 not work, =0.7 works, =0.0 works
            !        relax_keep_off=0.75 ! works for hard problem =0.9 not work, =0.8 not work, =0.7 works, =0.0 works
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola, nonods, max_nonods_sfc_all_grids
                    integer, intent( in ) :: max_ncola_sfc_all_un, max_nlevel
                    real, intent( out ) :: a_sfc_all_un(max_ncola_sfc_all_un), &
                                           b_sfc(max_nonods_sfc_all_grids), &
                                           ml_sfc(max_nonods_sfc_all_grids) 
                    real, intent( in ) :: a(ncola), b(nonods), ml(nonods)
                    integer, intent( out ) :: nonods_sfc_all_grids, fin_sfc_nonods(max_nlevel+1), nlevel
                    integer, intent( out ) :: fina_sfc_all_un(max_nonods_sfc_all_grids+1), &
                                              cola_sfc_all_un(max_ncola_sfc_all_un),ncola_sfc_all_un
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    integer, intent( in ) :: sfc_node_ordering(nonods)
            ! local variables...
                    integer, allocatable :: sfc_node_ordering_inverse(:), in_row_count(:)
                    integer, allocatable :: fina_sfc_all_un2(:)
                    integer i, count, count2, nodj, nodi_sfc, ilevel, ilevel2
                    integer ifinest_nod_sfc, jfinest_nod_sfc, icourse_nod_sfc, jcourse_nod_sfc
                    integer icourse_nod_sfc_all
                    integer ifinest_nod, jfinest_nod, ipt
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
                    integer nrow, count_col, idisplace, jcourse_nod_sfc_all2
                    integer jcourse_nod_sfc_all, ifinest_nod_sfc_all, count_all
                    logical found
            ! 
                    print *,'2-just inside best_sfc_mapping_to_sfc_matrix_unstructured'
            ! calculate nlevel from nonods
                    call calculate_nlevel_sfc(nlevel,nonods)
            ! 
            ! form SFC matrix...
            !        a_sfc(:,:)=0.0
                    b_sfc(:)=0.0
                    ml_sfc(:)=0.0
                    do ifinest_nod=1,nonods
                       ifinest_nod_sfc = sfc_node_ordering(ifinest_nod) 
                       b_sfc(ifinest_nod_sfc)=b(ifinest_nod)
                       ml_sfc(ifinest_nod_sfc)=ml(ifinest_nod)
                    end do 
            !       print *,'here 1 nlevel:',nlevel
            ! 
            ! coarsen...
                    sfc_nonods_accum=1
                    fin_sfc_nonods(1)=sfc_nonods_accum
                    sfc_nonods_accum=sfc_nonods_accum + nonods
                    fin_sfc_nonods(2)=sfc_nonods_accum 
                    do ilevel=2,nlevel
            !           print *,'ilevel=',ilevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       if(sfc_nonods_fine.le.1) stop 13331 ! something went wrong. 
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
            !           call map_sfc_course_grid( a_sfc(:,fin_sfc_nonods(ilevel)),sfc_nonods_course, &
            !                                     a_sfc(:,fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           print *,'fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel-1):', &
            !                    fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel-1)
            !           print *,'max_nonods_sfc_all_grids,sfc_nonods_course,sfc_nonods_fine:', &
            !                    max_nonods_sfc_all_grids,sfc_nonods_course,sfc_nonods_fine
            
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     ml_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     ml_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !           ipt=fin_sfc_nonods(ilevel)
            !           print *,'ml_sfc(ipt:ipt+sfc_nonods_course-1):',ml_sfc(ipt:ipt+sfc_nonods_course-1)
            !           ipt=fin_sfc_nonods(ilevel-1)
            !           print *,'ml_sfc(ipt:ipt+sfc_nonods_fine-1):',ml_sfc(ipt:ipt+sfc_nonods_fine-1)
            !       print *,'here 1.1' 
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     b_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     b_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            !       print *,'here 1.2' 
                       sfc_nonods_accum = sfc_nonods_accum + sfc_nonods_course
                       fin_sfc_nonods(ilevel+1)=sfc_nonods_accum
                    end do
                    nonods_sfc_all_grids=sfc_nonods_accum-1
                    if(max_nonods_sfc_all_grids<nonods_sfc_all_grids) then
                       print *,'run out of memory here stopping'
                       stop 2822
                    endif
                    print *,'here 2'
            !         stop 25
            ! sfc_node_ordering(nod) = new node numbering from current node number nod.
                    allocate(sfc_node_ordering_inverse(nonods))
                    do ifinest_nod=1,nonods
                       ifinest_nod_sfc = sfc_node_ordering(ifinest_nod) 
                       sfc_node_ordering_inverse(ifinest_nod_sfc) = ifinest_nod
                    end do 
            !     
                    print *,'---max_ncola_sfc_all_un,ncola,nlevel:',max_ncola_sfc_all_un,ncola,nlevel
                    print *,'---nonods,nonods_sfc_all_grids:',nonods,nonods_sfc_all_grids
                    print *,'fin_sfc_nonods(1:,nlevel+1):',fin_sfc_nonods(1:nlevel+1)
            !        a_sfc_all_un=0.0
                    count_all=0
                    do ilevel=1,nlevel
                       ilevel2=2**(ilevel-1)
                       print *,'--- ilevel=',ilevel
                       idisplace = fin_sfc_nonods(ilevel) 
                       fina_sfc_all_un(idisplace) = count_all+1
                       do ifinest_nod_sfc=1,nonods
            !              print *,'ifinest_nod_sfc=',ifinest_nod_sfc
                          ifinest_nod = sfc_node_ordering_inverse(ifinest_nod_sfc)
                          icourse_nod_sfc_all = idisplace + (ifinest_nod_sfc-1)/ilevel2
                          do count=fina(ifinest_nod),fina(ifinest_nod+1)-1
                             jfinest_nod = cola(count)
                             jfinest_nod_sfc = sfc_node_ordering(jfinest_nod) 
                             jcourse_nod_sfc_all = idisplace + (jfinest_nod_sfc-1)/ilevel2
            ! look to see if we have included jcourse_nod_sfc_all yet
                             found=.false.
                             do count2=fina_sfc_all_un(icourse_nod_sfc_all),count_all
                                jcourse_nod_sfc_all2=cola_sfc_all_un(count2)
                                if(jcourse_nod_sfc_all==jcourse_nod_sfc_all2) then
                                   found=.true.
                                   a_sfc_all_un(count2)=a_sfc_all_un(count2)+a(count) ! map from original matrix
                                endif
                             end do
                             if(.not.found) then
                                count_all=count_all+1
                                cola_sfc_all_un(count_all) = jcourse_nod_sfc_all
            !                    a_sfc_all_un(count_all)=a_sfc_all_un(count_all)+a(count) ! map from original matrix
                                a_sfc_all_un(count_all)=a(count) ! map from original matrix
                             endif
                          end do ! do count=fina(ifinest_nod),fina(ifinest_nod+1)-1
                          fina_sfc_all_un(icourse_nod_sfc_all+1) = count_all+1
                       end do ! do ifinest_nod_sfc=1,nonods
                       print *,'here2'
                       print *,'fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1):', &
                                fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)
                       print *,'diff=',fin_sfc_nonods(ilevel+1)-fin_sfc_nonods(ilevel)
                       print *,'fina_sfc_all_un(fin_sfc_nonods(ilevel)):',fina_sfc_all_un(fin_sfc_nonods(ilevel))
                       print *,'fina_sfc_all_un(fin_sfc_nonods(ilevel+1))-1:',fina_sfc_all_un(fin_sfc_nonods(ilevel+1))-1
                       print *,'difference:', &
                           fina_sfc_all_un(fin_sfc_nonods(ilevel+1)) - fina_sfc_all_un(fin_sfc_nonods(ilevel))
                      if(.false.) then
                       do icourse_nod_sfc_all=fin_sfc_nonods(ilevel),fin_sfc_nonods(ilevel+1)-1
                          print *,'icourse_nod_sfc_all=',icourse_nod_sfc_all
                          print *,'cola_sfc_all_un(count2):', &
                              (cola_sfc_all_un(count2),count2=fina_sfc_all_un(icourse_nod_sfc_all), &
                                                              fina_sfc_all_un(icourse_nod_sfc_all+1)-1) 
                          print *,'a_sfc_all_un(count2):', &
                              (a_sfc_all_un(count2),count2=fina_sfc_all_un(icourse_nod_sfc_all), &
                                                           fina_sfc_all_un(icourse_nod_sfc_all+1)-1) 
                       end do
                      endif
                    end do ! do ilevel=1,nlevel
            
                    ncola_sfc_all_un = fina_sfc_all_un(nonods_sfc_all_grids+1)-1
                    if( max_ncola_sfc_all_un < ncola_sfc_all_un ) then
                       print *,'run out of memory here stopping'
                       stop 2825
                    endif
            ! 
                    print *,'ncola, ncola_sfc_all_un:',ncola, ncola_sfc_all_un
                    print *,'nonods_sfc_all_grids:',nonods_sfc_all_grids
                    print *,'fina_sfc_all_un(nonods_sfc_all_grids+1)-fina_sfc_all_un(nonods_sfc_all_grids):', &
                             fina_sfc_all_un(nonods_sfc_all_grids+1)-fina_sfc_all_un(nonods_sfc_all_grids)
            
            !        stop 282
                    print *,'just leaving best_sfc_mapping_to_sfc_matrix_unstructured'
                    return 
                    end subroutine best_sfc_mapping_to_sfc_matrix_unstructured
            ! 
            ! 
            ! 
            ! python interface: 
            ! filt_nxnx, filt_nnx, ml = filters_for_structured_mesh_dg(dx,ndim,nloc)
                    subroutine filters_for_structured_mesh_dg_de_bug(filt_nxnx, filt_nnx, ml, dx,ndim,nloc)
                    implicit none
            ! this subroutine calculates filters for the 2D rectangular element and 
            ! the 3D hex element of dimensions dx.
            ! filt_nxnx is the filter for the diffusion/Laplacian operator. 
            ! filt_nnx is the filter for the derivatives in the x,y and z-directions. 
            ! ml contains the mass associated with the local nodes. 
            ! nloc=no of nodes per element
            ! ndim=no of dimensions 
            ! dx is the dimensions of the element - width, length, height. 
            ! For the arrays:
            ! filt_nxnx(3,3,1+(ndim-2)*2, nloc)
            ! filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
            ! The 3,3 is the dimensions of the filter in 2D. It needs to be a 3x3 array.
            ! NDIM is the number of dimensions ndim=2 in our case but will change to3 soon.
            ! nloc is the number of local noes in an element. So we produce a filter for each local node of an element - 4 in our case.
            ! nsign=1 or 2 and is 1 is we have a positive sign of the component of interest (idim that goes into
            ! the ndim part of the array) of the velocity. Its 2 if the component is negative. 
                    integer, parameter :: nsign=2
                    integer, intent( in ) :: ndim, nloc
                    real, intent( in ) :: dx(ndim)
                    real, intent( out ) :: filt_nxnx(3,3,1+(ndim-2)*2, ndim,nloc)
                    real, intent( out ) :: filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
                    real, intent( out ) :: ml(nloc)
                    
            ! local variables...
                    real, allocatable :: nxnx_ele(:,:,:),nxn_ele(:,:,:,:),snsn(:,:,:)
                    real, allocatable :: filt_nnx_nosign(:,:,:, :,:)
                    real, allocatable :: dx_face_normal(:,:),face_normal(:,:,:) 
                    real, allocatable :: x_all(:,:)
                    integer totele,ele, iloc,isig
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k
                    integer snloc,nface,idim,iface
            ! 
                    print *,'just inside filters_for_structured_mesh_dg_de_bug'
            !        return
                    totele=1
                    if(ndim==2) then
            ! 2d:
                       snloc=2
                       nface=4
                    else ! ndim=3
            ! 3d:
                       snloc=4
                       nface=6
                    endif
                    allocate(nxnx_ele(nloc,nloc,totele),nxn_ele(ndim,nloc,nloc,totele))
                    allocate(filt_nnx_nosign(3,3,1+(ndim-2)*2, ndim,nloc))
                    allocate(snsn(nloc,nloc,totele))
                    allocate(dx_face_normal(nface,totele),face_normal(ndim,nface,totele))
                    allocate(x_all(ndim,totele*nloc)) 
            ! 
                    if(ndim==2) then
                      x_all(:,1)=(/-1.0,-1.0/)
                      x_all(:,2)=(/+1.0,-1.0/)
                      x_all(:,3)=(/-1.0,+1.0/)
                      x_all(:,4)=(/+1.0,+1.0/)
                       print *,'--x_all:',x_all
                       print *,'dx:',dx
                    endif
                    if(ndim==3) then
                      x_all(:,1)=(/-1.0,-1.0,-1.0/)
                      x_all(:,2)=(/+1.0,-1.0,-1.0/)
                      x_all(:,3)=(/-1.0,+1.0,-1.0/)
                      x_all(:,4)=(/+1.0,+1.0,-1.0/)
            ! 2nd layer...
                      x_all(:,5)=(/-1.0,-1.0,+1.0/)
                      x_all(:,6)=(/+1.0,-1.0,+1.0/)
                      x_all(:,7)=(/-1.0,+1.0,+1.0/)
                      x_all(:,8)=(/+1.0,+1.0,+1.0/)
                    endif
                    print *,'ndim,nloc:',ndim,nloc
            ! make the elements of width dx
                    do iloc=1,nloc
                       x_all(:,iloc)=x_all(:,iloc)*0.5*dx(:) 
                    end do
            ! 
            ! form the sourface and volume integrals...
            !        stop 298
                    call spacial_tables_for_dg_filters(nxnx_ele, nxn_ele, ml, &
                                                       dx_face_normal, face_normal, snsn, &
                                                       x_all, totele, nface,ndim,nloc,snloc) 
                                       
                    filt_nxnx=1. 
                    filt_nnx=1.
                    ml=1.
                    print *,'just leaving filters_for_structured_mesh_dg_de_bug'
                    return               
            ! 
            !        stop 299
            ! overwrite dx as its in the orthogonal direction (wrong direction)...
                    ele=1    
                    do iface=1,nface
                       idim= 1 + (iface-1)/2  
                       dx_face_normal(iface,ele) = dx(idim) 
                    end do
            ! 
            !        stop 2910
            ! form the spatial dg filters from the spatial tables...
                    call form_dg_filters_from_nx(filt_nxnx, filt_nnx_nosign, &
                         filt_nnx,  &
                         nxnx_ele(:,:,ele),nxn_ele(:,:,:,ele),snsn(:,:,ele), &
                         dx_face_normal(:,ele),face_normal(:,:,ele), &
                         ndim,nface,nloc,snloc )
            !        stop 2911
                    print *,'just outside of form_dg_filters_from_nx'
            ! 
                    do iloc=1,nloc
                       do isig=1,2
                          filt_nnx(:,:,:,:,isig,iloc) = filt_nnx(:,:,:,:,isig,iloc) &
                                                      + filt_nnx_nosign(:,:,:,:,iloc)
                       end do
                    end do
                    print *,'filt_nxnx:',filt_nxnx
                    print *,'filt_nnx:',filt_nnx
                    print *,'ml:',ml
                    print *,'just about to leave filters_for_structured_mesh_dg'
            
                    filt_nxnx=1. 
                    filt_nnx=1.
                    ml=1.
            ! 
                    print *,'just leaving filters_for_structured_mesh_dg_de_bug'
                    return
                    end subroutine filters_for_structured_mesh_dg_de_bug
            ! 
            ! 
            ! python interface: 
            ! filt_nxnx, filt_nnx, ml = filters_for_structured_mesh_dg(dx,ndim,nloc)
                    subroutine filters_for_structured_mesh_dg(filt_nxnx, filt_nnx, ml, dx,ndim,nloc)
                    implicit none
            ! this subroutine calculates filters for the 2D rectangular element and 
            ! the 3D hex element of dimensions dx.
            ! filt_nxnx is the filter for the diffusion/Laplacian operator. 
            ! filt_nnx is the filter for the derivatives in the x,y and z-directions. 
            ! ml contains the mass associated with the local nodes. 
            ! nloc=no of nodes per element
            ! ndim=no of dimensions 
            ! dx is the dimensions of the element - width, length, height. 
            ! For the arrays:
            ! filt_nxnx(3,3,1+(ndim-2)*2, ndim,nloc)
            ! filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
            ! The 3,3 is the dimensions of the filter in 2D. It needs to be a 3x3 array.
            ! NDIM is the number of dimensions ndim=2 in our case but will change to3 soon.
            ! nloc is the number of local noes in an element. So we produce a filter for each local node of an element - 4 in our case.
            ! nsign=1 or 2 and is 1 is we have a positive sign of the component of interest (idim that goes into
            ! the ndim part of the array) of the velocity. Its 2 if the component is negative. 
                    integer, parameter :: nsign=2
                    integer, intent( in ) :: ndim, nloc
                    real, intent( in ) :: dx(ndim)
                    real, intent( out ) :: filt_nxnx(3,3,1+(ndim-2)*2, ndim,nloc)
                    real, intent( out ) :: filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
                    real, intent( out ) :: ml(nloc)
                    
            ! local variables...
                    real, allocatable :: nxnx_ele(:,:,:,:),nxn_ele(:,:,:,:),snsn(:,:,:,:)
                    real, allocatable :: filt_nnx_nosign(:,:,:, :,:)
                    real, allocatable :: dx_face_normal(:,:),face_normal(:,:,:) 
                    real, allocatable :: x_all(:,:)
                    integer totele,ele, iloc,isig
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k
                    integer snloc,nface,idim,iface
            ! 
                    print *,'just inside filters_for_structured_mesh_dg'
            !        return
                    totele=1
                    if(ndim==2) then
            ! 2d:
                       snloc=2
                       nface=4
                    else ! ndim=3
            ! 3d:
                       snloc=4
                       nface=6
                    endif
                    allocate(nxnx_ele(ndim,nloc,nloc,totele),nxn_ele(ndim,nloc,nloc,totele))
                    allocate(filt_nnx_nosign(3,3,1+(ndim-2)*2, ndim,nloc))
                    allocate(snsn(snloc,snloc,nface,totele))
                    allocate(dx_face_normal(nface,totele),face_normal(ndim,nface,totele))
                    allocate(x_all(ndim,totele*nloc)) 
            ! 
                    if(ndim==2) then
                      x_all(:,1)=(/-1.0,-1.0/)
                      x_all(:,2)=(/+1.0,-1.0/)
                      x_all(:,3)=(/-1.0,+1.0/)
                      x_all(:,4)=(/+1.0,+1.0/)
                       print *,'--x_all:',x_all
                       print *,'dx:',dx
                    endif
                    if(ndim==3) then
                      x_all(:,1)=(/-1.0,-1.0,-1.0/)
                      x_all(:,2)=(/+1.0,-1.0,-1.0/)
                      x_all(:,3)=(/-1.0,+1.0,-1.0/)
                      x_all(:,4)=(/+1.0,+1.0,-1.0/)
            ! 2nd layer...
                      x_all(:,5)=(/-1.0,-1.0,+1.0/)
                      x_all(:,6)=(/+1.0,-1.0,+1.0/)
                      x_all(:,7)=(/-1.0,+1.0,+1.0/)
                      x_all(:,8)=(/+1.0,+1.0,+1.0/)
                    endif
                    print *,'ndim,nloc:',ndim,nloc
            ! make the elements of width dx
                    do iloc=1,nloc
                       x_all(:,iloc)=x_all(:,iloc)*0.5*dx(:) 
                    end do
                     print *,'x_all:',x_all
                    do idim=1,ndim
                       print *,'idim=',idim
                       print *,'x_all(idim,:):',x_all(idim,:)
                    end do
            !        stop 292
            ! 
            ! form the sourface and volume integrals...
            !        stop 298
                    call spacial_tables_for_dg_filters(nxnx_ele, nxn_ele, ml, &
                                                       dx_face_normal, face_normal, snsn, &
                                                       x_all, totele, nface,ndim,nloc,snloc)
            !        stop 299
            ! overwrite dx as its in the orthogonal direction (wrong direction)...
                    ele=1    
                    do iface=1,nface
                       idim= 1 + (iface-1)/2  
                       dx_face_normal(iface,ele) = dx(idim)  
                    end do
            ! 
            !        stop 2910
            ! form the spatial dg filters from the spatial tables...
                    call form_dg_filters_from_nx(filt_nxnx, filt_nnx_nosign, &
                         filt_nnx,  &
                         nxnx_ele(:,:,:,ele),nxn_ele(:,:,:,ele),snsn(:,:,:,ele), &
                         dx_face_normal(:,ele),face_normal(:,:,ele), &
                         ndim,nface,nloc,snloc )
            !        stop 2911
                    print *,'just outside of form_dg_filters_from_nx'
            ! 
                    do iloc=1,nloc
                       do isig=1,2
                          filt_nnx(:,:,:,:,isig,iloc) = filt_nnx(:,:,:,:,isig,iloc) &
                                                      + filt_nnx_nosign(:,:,:,:,iloc)
                       end do
                    end do
                    print *,'filt_nxnx:',filt_nxnx
                    print *,'filt_nnx:',filt_nnx
                    print *,'ml:',ml
                    print *,'just about to leave filters_for_structured_mesh_dg'
            !         stop 2921
            ! 
                    return
                    end subroutine filters_for_structured_mesh_dg
            ! 
            ! 
            ! 
            ! 
            ! python interface:
            ! filt_nxnx,filt_nnx, filt_nnx_nosign, suf_filt_nnx, ml, face_normal = filters_for_unstructured_mesh_dg( &
            !                                                     x_all,totele,nface,ndim,nloc)
                    subroutine filters_for_unstructured_mesh_dg(filt_nxnx,filt_nnx, filt_nnx_nosign, suf_filt_nnx, ml, face_normal, &
                                                                x_all,totele,nface,ndim,nloc)
                    implicit none
            ! This subroutine calculates filters for the 2D rectangular elements 
            ! and 3D hex elemenents that can be distorted. 
            ! filt_nxnx is the filter for the diffusion/Laplacian operator. 
            ! filt_nnx is the filter for the derivatives in the x,y and z-directions. 
            ! ml contains the mass associated with the local nodes. 
            ! nloc=no of nodes per element
            ! ndim=no of dimensions 
            ! For the arrays:
            ! filt_nxnx(3,3,1+(ndim-2)*2, ndim, nloc)
            ! filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
            ! The 3,3 is the dimensions of the filter in 2D. It needs to be a 3x3 array.
            ! NDIM is the number of dimensions ndim=2 in our case but will change to3 soon.
            ! nloc is the number of local noes in an element. So we produce a filter for each local node of an element - 4 in our case.
            ! nsign=1 or 2 and is 1 is we have a positive sign of the component of interest (idim that goes into
            ! the ndim part of the array) of the velocity. Its 2 if the component is negative. 
                    integer, parameter :: nsign=2
                    integer, intent( in ) :: totele,nface,ndim,nloc
                    real, intent( in ) :: x_all(ndim,totele)
                    real, intent( out ) :: filt_nxnx(3,3,1+(ndim-2)*2, ndim,nloc,totele)
                    real, intent( out ) :: filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc,totele)
                    real, intent( out ) :: filt_nnx_nosign(3,3,1+(ndim-2)*2, ndim,nloc,totele)
                    real, intent( out ) :: suf_filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc,totele)
                    real, intent( out ) :: ml(totele*nloc)
                    real, intent( out ) :: face_normal(ndim,nface,totele)
            ! 
            ! local variables...
                    real, allocatable :: nxnx_ele(:,:,:),nxn_ele(:,:,:,:)
                    real, allocatable :: snsn(:,:,:,:)
                    real, allocatable :: dx_face_normal(:,:)
                    integer snloc,ele
            !
                    allocate(nxnx_ele(nloc,nloc,totele),nxn_ele(ndim,nloc,nloc,totele))
                    allocate(snsn(snloc,snloc,nface,totele))
                    allocate(dx_face_normal(nface,totele))
            !
                    if(ndim==2) then ! 2D...
                       snloc=2
                    else ! 3D...
                       snloc=4
                    endif
            ! 
            ! Form the spatial tables that will be used to form dg filters...
                    call spacial_tables_for_dg_filters(nxnx_ele, nxn_ele, ml, &
                                                       dx_face_normal, face_normal, snsn,  &
                                                       x_all, totele, nface,ndim,nloc,snloc)
            ! 
            ! Form the spatial dg filters from the spatial tables...
                    do ele=1,totele
                       call form_dg_filters_from_nx(filt_nxnx(:,:,:,:,:,ele), filt_nnx_nosign(:,:,:,:,:,ele), &
                            filt_nnx(:,:,:,:,:,:,ele),  &
                            nxnx_ele(:,:,ele),nxn_ele(:,:,:,ele),snsn(:,:,:,ele), &
                            dx_face_normal(:,ele),face_normal(:,:,ele), &
                            ndim,nface,nloc,snloc )
                    end do
            ! 
                    return
                    end subroutine filters_for_unstructured_mesh_dg
            ! 
            ! 
            ! 
            ! 
                    subroutine form_dg_filters_from_nx(filt_nxnx, filt_nnx_nosign, &
                                                       filt_nnx,  &
                                                       nxnx_ele,nxn_ele,snsn, &
                                                       dx_face_normal,face_normal, &
                                                       ndim,nface,nloc,snloc )
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
            ! For the arrays:
            ! filt_nxnx(3,3,1+(ndim-2)*2, ndim, nloc)
            ! filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
            ! The 3,3 is the dimensions of the filter in 2D. It needs to be a 3x3 array.
            ! NDIM is the number of dimensions ndim=2 in our case but will change to3 soon.
            ! nloc is the number of local noes in an element. So we produce a filter for each local node of an element - 4 in our case.
            ! nsign=1 or 2 and is 1 is we have a positive sign of the component of interest (idim that goes into
            ! the ndim part of the array) of the velocity. Its 2 if the component is negative. 
                    implicit none
                    integer, parameter :: nsign=2
                    integer, intent( in ) :: nface,ndim,nloc,snloc
                    real, intent( in ) :: nxnx_ele(ndim,nloc,nloc),nxn_ele(ndim,nloc,nloc)
                    real, intent( in ) :: snsn(snloc,snloc,nface)
                    real, intent( in ) :: dx_face_normal(nface),face_normal(ndim,nface)
                    real, intent( out ) :: filt_nxnx(3,3,1+(ndim-2)*2, ndim,nloc)
                    real, intent( out ) :: filt_nnx_nosign(3,3,1+(ndim-2)*2, ndim,nloc)
                    real, intent( out ) :: filt_nnx(3,3,1+(ndim-2)*2, ndim,nsign,nloc)
            ! local variables...
                    integer iloc,jloc,idim,idir, siloc,sjloc
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k, i2,j2,k2
                    integer iswitch,istart,ifinish
                    integer jswitch,jstart,jfinish
                    integer kswitch,kstart,kfinish
                    integer iface, iloc_d
                    integer ii,jj,kk
                    integer isig
            ! 
            !        print *,'---ndim,nloc:',ndim,nloc
            ! 
                    filt_nxnx=0.0
                    filt_nnx_nosign=0.0
                    filt_nnx =0.0
                    do kkblock=1,ndim-1
                    do jjblock=1,2
                    do iiblock=1,2
                       iloc=1 + (2-iiblock) +(2-jjblock)*2   + (ndim-2)*(2-kkblock)*4
                       print *,'iiblock,jjblock,kkblock,iloc:',iiblock,jjblock,kkblock,iloc
                       do kfil=1,ndim-1
                       do jfil=1,2
                       do ifil=1,2
            !              do iidim2=1,2
            !              do jjdim2=1,2
            !              do kkdim2=1,ndim-1
                             iloc=1 + (2-iiblock) +(2-jjblock)*2   + (ndim-2)*(2-kkblock)*4
            !                 floc=iloc
            !                 jloc=iiblock +(jjblock-1)*2   + (kkblock-1)*4
                             jloc=ifil +(jfil-1)*2   + (kfil-1)*4
            !                 jloc=iidim2 +(jjdim2-1)*2 + (kkdim2-1)*4
                             i=ifil + (iiblock-1)*1
                             j=jfil + (jjblock-1)*1
                             k=kfil + (kkblock-1)*1
                             print *,'i,j,k:',i,j,k
            ! Volume integrals...
                             filt_nxnx(i,j,k,:,iloc)  = filt_nxnx(i,j,k,:,iloc)  + nxnx_ele(:,iloc,jloc)
                             filt_nnx_nosign(i,j,k,:,iloc) = filt_nnx_nosign(i,j,k,:,iloc) - nxn_ele(:,iloc,jloc)
                       end do ! do ifil=1,2
                       end do ! do jfil=1,2
                       end do ! do kfil=1,ndim-1
                    end do ! do iiblock=1,2
                    end do ! do jjblock=1,2
                    end do ! do kkblock=1,ndim-1
            ! 
            !        print *,'diffusion part (no surface integrals):'
            !        do iloc=1,nloc
            !           do k=1,1+2*(ndim-2)
            !           do j=3,1,-1
            !              print *,'j,k,iloc,filt_nxnx(:,j,k,iloc):',j,k,iloc,filt_nxnx(:,j,k,iloc)
            !           end do
            !           end do
            !           print *,' '
            !        end do
            !        stop 921
            
                    do iface = 1, nface !  Between_Elements_And_Boundary 
                       print *,'++++++++++++iface:',iface
            ! 
            ! idim is the dimension on which the face is and idir =1 if 1st face of dimension and =2 if second face. 
            ! iswitch=1 if face is on dimension idim else=0 similarly jswitch associated with idim=2. 
                       idim = 1 + (iface-1)/2 
                       idir = iface - idim*2 +2
            
            !           iswitch =   1-min(1,max(0,1-idim,idim-1))
                       iswitch =   1-min(1,abs(1-idim))
                       istart =1*(1-iswitch) + idir*iswitch
                       ifinish=2*(1-iswitch) + idir*iswitch
            
            !           jswitch =   1-max(0,2-idim,idim-2)
                       jswitch =   1-abs(2-idim)
                       jstart =1*(1-jswitch) + idir*jswitch
                       jfinish=2*(1-jswitch) + idir*jswitch
            
                       kswitch =   max(0,idim-2)
                       kstart =1*(1-kswitch) + idir*kswitch
                       kfinish=(ndim-1)*(1-kswitch) + idir*kswitch
                             print *,'idim:',idim
                             print *,'kswitch,jswitch,iswitch,idir:',kswitch,jswitch,iswitch,idir
                             print *,'kstart,kfinish:',kstart,kfinish
                             print *,'jstart,jfinish:',jstart,jfinish
                             print *,'istart,ifinish:',istart,ifinish
            ! 
                       siloc=0
                       do kk=kstart,kfinish
                       do jj=jstart,jfinish
                       do ii=istart,ifinish
                          iloc=1+(ii-1) + (jj-1)*2 + (kk-1)*4
                          siloc=siloc+1
            ! 
            !              kkblock = 1 + (iloc-1)/4
            !              iloc_d  = iloc - (kkblock-1)*4
            !              jjblock = 1 + (iloc_d-1)/2
            !              iiblock = iloc_d - (jjblock-1)*2
            
                          kkblock = (3-kk)*(ndim-2) + 1*(3-ndim)
                          jjblock = 3-jj
                          iiblock = 3-ii
                            print *,'iloc,siloc:',iloc,siloc
                            print *,'iiblock,jjblock,kkblock:',iiblock,jjblock,kkblock
            !                
                          sjloc=0
                          do kfil=kstart,kfinish
                          do jfil=jstart,jfinish
                          do ifil=istart,ifinish
                             sjloc=sjloc+1
            ! 
                             i=ifil + (iiblock-1)*1
                             j=jfil + (jjblock-1)*1
                             k=kfil + (kkblock-1)*1
            ! 
                             i2=ifil + (iiblock-1)*1 + iswitch*(2*idir-3) 
                             j2=jfil + (jjblock-1)*1 + jswitch*(2*idir-3) 
                             k2=kfil + (kkblock-1)*1 + kswitch*(2*idir-3) 
            
            ! Surface element contributions for Laplacian...
                        print *,'ifil,iiblock,iswitch,idir,sjloc:',ifil,iiblock,iswitch,idir,sjloc
                        print *,'i,j,k,i2,j2,k2:',i,j,k,i2,j2,k2
                             filt_nxnx(i,j,k,idim,iloc)  = filt_nxnx(i,j,k,idim,iloc)  &
                                                      + snsn(siloc,sjloc,iface)*2.0/dx_face_normal(iface)
                        print *,'h1'
                             filt_nxnx(i2,j2,k2,idim,iloc)    = filt_nxnx(i2,j2,k2,idim,iloc)    &
                                                      - snsn(siloc,sjloc,iface)*2.0/dx_face_normal(iface)
                        print *,'h2'
            ! Advection...
            !                 isig=1 ! positive velocity into element 
                             isig=idir ! positive velocity into element 
                             filt_nnx(i2,j2,k2,idim,isig,iloc) = filt_nnx(i2,j2,k2,idim,isig,iloc) &
                                                            + snsn(siloc,sjloc,iface)*face_normal(idim,iface)
                        print *,'h3'
            !                 isig=2 ! -ve velocity out of element 
                             isig=3-idir ! -ve velocity out of element 
                             filt_nnx(i,j,k,idim,isig,iloc)    = filt_nnx(i,j,k,idim,isig,iloc)    &
                                                            + snsn(siloc,sjloc,iface)*face_normal(idim,iface)
                        print *,'h4'
                          end do ! do ifil=istart,ifinish
                          end do ! do jfil=jstart,jfinish
                          end do ! do kfil=kstart,kfinish
                       end do ! do ii=istart,ifinish
                       end do ! do jj=jstart,jfinish
                       end do ! do kk=kstart,kfinish
            ! 
                    end do ! do iface = 1, nface 
                    print *,'just about to leave form_dg_filters_from_nx'
                    return
                    end subroutine form_dg_filters_from_nx
            ! 
            ! 
            ! 
            ! 
                    subroutine spacial_tables_for_dg_filters(nxnx_ele, nxn_ele, ml, &
                                                             dx_face_normal, face_normal, snsn,  & 
                                                             x_all, totele, nface,ndim,nloc,snloc)
                    implicit none
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
                    integer, parameter :: nsign=2
                    integer, intent( in ) :: totele, nface,ndim,nloc,snloc
                    real, intent( in ) :: x_all(ndim,totele*nloc)
                    real, intent( out ) :: nxnx_ele(ndim,nloc,nloc,totele), nxn_ele(ndim,nloc,nloc,totele)
                    real, intent( out ) :: ml(totele*nloc)
                    real, intent( out ) :: dx_face_normal(nface,totele),face_normal(ndim,nface,totele)
                    real, intent( out ) :: snsn(snloc,snloc,nface,totele)
            ! local variables...
                    real, allocatable :: n(:,:), nlx(:,:,:), weight(:)
                    real, allocatable :: face_sn(:,:,:), face_sn2(:,:,:)
                    real, allocatable :: face_snlx(:,:,:,:), face_sweigh(:,:) 
                    real, allocatable :: sn(:,:), snlx(:,:,:)
                    real, allocatable :: nx(:,:,:),detwei(:),inv_jac(:,:,:)
                    real, allocatable :: nxnx(:,:,:), nnx(:,:,:)
            ! filters for ann:
            !        real, allocatable :: afilt_nxnx(:,:,:,:)
                    real, allocatable :: afilt_nnx(:,:,:,:)
                    real, allocatable :: x_loc(:,:), xc(:), xsgi(:,:), sx_loc(:,:)
                    real, allocatable :: norm(:),snorm(:,:),sdetwei(:),sweigh(:)
                    integer npoly,ele_type,ele, iloc,jloc,idim, siloc,sjloc
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k, gi, iface
                    integer sngi, ngi, max_face_list_no
                    integer idir
                    integer ii,jj,kk
                    integer iswitch, istart, ifinish
                    integer jswitch, jstart, jfinish
                    integer kswitch, kstart, kfinish
                    real sarea
            ! 
            !        print *,'x_all:',x_all
            !        stop 2991
            !         return
            ! 
                    if(ndim==2) then
            ! 2d:
                       sngi=3; ngi=9
                       max_face_list_no=2
                    else ! ndim=3
            ! 3d:
                       sngi=9; ngi=27
                       max_face_list_no=4
                    endif
            
                    allocate(n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi))
                    allocate(face_sn(sngi,snloc,nface), face_sn2(sngi,snloc,max_face_list_no) )
                    allocate(face_snlx(sngi,ndim-1,snloc,nface), face_sweigh(sngi,nface) )
                    allocate(sn(sngi,snloc), snlx(sngi,ndim-1,snloc)) 
            ! 
                    allocate(nx(ngi,ndim,nloc),detwei(ngi),inv_jac(ngi,ndim,ndim))
                    allocate(nxnx(ndim,nloc,nloc),nnx(ndim,nloc,nloc))
                    allocate(x_loc(ndim,nloc),xc(ndim),xsgi(sngi,ndim)) 
                    allocate(sx_loc(ndim,snloc))
                    allocate(norm(ndim),snorm(sngi,ndim),sdetwei(sngi),sweigh(sngi))
            
            !         stop 3382
                    npoly=1
                    ele_type=1
            
            ! form the shape functions...
                    print *,'going into get_shape_funs_with_faces'
                    call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                    iface=1
                    sn(:,:) = face_sn(:,:,iface)
                    snlx(:,:,:) = face_snlx(:,:,:,iface)
                    sweigh(:)=face_sweigh(:,iface)
            
                    print *,'integrating over volns...'
                    print *,'face_sn:',face_sn
                    print *,'face_snlx:',face_snlx
                    print *,'face_sweigh:',face_sweigh
            !         stop 3383
            ! 
            ! obtain 
            ! for filters...
                    nxnx_ele=0.0
                    nxn_ele=0.0
            !        nxn_ele=0.0
                    do ele = 1, totele ! VOLUME integral
                         print *,'here1'
                         x_loc(:,:) = x_all(:,(ele-1)*nloc+1:ele*nloc)
                         print *,'here2 x_loc:',x_loc
                         call det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, INV_JAC )
            
                         print *,'here3'
                         do iloc=1,nloc
                            ml((ele-1)*nloc+iloc)=sum( n(:,iloc)*detwei(:) )
                         end do
                         print *,'here4'
                         do iloc=1,nloc
                         do jloc=1,nloc
                               do idim=1,ndim
                      nxnx_ele(idim,iloc,jloc,ele) = sum( nx(:,idim,iloc)*nx(:,idim,jloc)*detwei(:) )
                      nxn_ele(idim,iloc,jloc,ele) = sum( nx(:,idim,iloc)*n(:,jloc)*detwei(:) )
                               end do
                         end do
                         end do
                         print *,'here5'
                    end do
            !         stop 3384
            !         return
            ! 
                    print *,'integrating over surfaces...'
            ! surface integrals... 
                    do ele = 1, totele ! Surface integral
                        ! for copy local memory copying...
                       x_loc(:,:) = x_all(:,(ele-1)*nloc+1:ele*nloc)
                       do idim=1,ndim
                          xc(idim)=sum(x_loc(idim,:))/real(nloc) 
                       end do
                       do iface = 1, nface !  Between_Elements_And_Boundary 
                            print *,'---------iface=',iface
            ! 
            ! idim is the dimension on which the face is and idir =1 if 1st face of dimension and =2 if second face. 
            ! iswitch=1 if face is on dimension idim else=0 similarly jswitch associated with idim=2. 
                             idim = 1 + (iface-1)/2 
                             idir = iface - idim*2 +2
            
            !                 iswitch =   1-min(1,max(0,1-idim,idim-1))
                             iswitch =   1-min(1,abs(1-idim))
                             istart =1*(1-iswitch) + idir*iswitch
                             ifinish=2*(1-iswitch) + idir*iswitch
            
            !                 jswitch =   1-max(0,2-idim,idim-2)
                             jswitch =   1-abs(2-idim)
                             jstart =1*(1-jswitch) + idir*jswitch
                             jfinish=2*(1-jswitch) + idir*jswitch
            
                             kswitch =   max(0,idim-2)
                             kstart =1*(1-kswitch) + idir*kswitch
                             kfinish=(ndim-1)*(1-kswitch) + idir*kswitch
                             print *,'idim:',idim
                             print *,'kswitch,jswitch,iswitch,idir:',kswitch,jswitch,iswitch,idir
                             print *,'kstart,kfinish:',kstart,kfinish
                             print *,'jstart,jfinish:',jstart,jfinish
                             print *,'istart,ifinish:',istart,ifinish
                             siloc=0
                             do kk=kstart,kfinish
                             do jj=jstart,jfinish
                             do ii=istart,ifinish
                                iloc=1+(ii-1) + (jj-1)*2 + (kk-1)*4
                                siloc=siloc+1
                                 print *,'iloc,siloc=',iloc,siloc
                                sx_loc(:,siloc) = x_loc(:,iloc)
                                 print *,'h3'
                             end do
                             end do
                             end do
            !               stop 28
            
            !                 s_list_no = face_list_no( iface, ele) 
            !                 sn2 =face_sn2(:,:,s_list_no)
            
            ! nn for element ele
            !                 snorm(:,ndim+1)=0.0
            !            stop 3103
                             xsgi = 0.0
                             do siloc=1,snloc ! use all of the nodes not just the surface nodes. 
                                do idim=1,ndim
                                   xsgi(:,idim)  = xsgi(:,idim)  + sn(:,siloc)*sx_loc(idim,siloc) 
            !                       print *,'idim,siloc,sx_loc(idim,siloc):',idim,siloc,sx_loc(idim,siloc)
                                end do
                             end do
                                 print *,'h4'
                             do idim=1,ndim
                                norm(idim) = sum(xsgi(:,idim))/real(sngi) - xc(idim)
                             end do
            !                     print *,'h5'
            !                  print *,'nloc, sngi, ndim:',nloc, sngi, ndim
            !                  print *,'sx_loc:',sx_loc
            !                  print *,'sn:',sn
            !                  print *,'snlx:',snlx
            !                  print *,'sweigh:',sweigh
            !                 do siloc=1,snloc 
            !                    do idim=1,ndim-1
            !       print *,'snlx(:,idim,siloc):',idim,siloc,snlx(:,idim,siloc)
            !                    end do
            !                 end do
            !            stop 3104
            ! start to do the integration...
                             call det_snlx_all( snloc, sngi, ndim-1, ndim, sx_loc, sn, snlx, &
                                                sweigh, sdetwei, sarea, snorm, norm )
            !         if(iface==3) return ! OK
            !             print *,'sdetwei:',sdetwei
            !             print *,'sarea:',sarea
            !             print *,'snorm:',snorm
            !             print *,'norm:',norm
            !            stop 3105
            !                     print *,'h6'
            !         if(iface==3) return ! ok
                             face_normal(:,iface,ele)=snorm(1,:)
            !         if(iface==3) return ! not ok
                             dx_face_normal(iface,ele)=sarea**(1./real(ndim)) 
            !         if(iface==3) return ! not ok
                             do siloc=1,snloc
                                 do sjloc=1,snloc
                                    snsn(siloc,sjloc,iface,ele) = sum( sdetwei(:)*sn(:,siloc)*sn(:,sjloc) )
            !                        do idim=1,ndim
            !                           snsn_normal(idim,siloc,sjloc,iface,ele) = sum( snorm(:,idim)*sdetwei(:)*sn(:,siloc)*sn(:,sjloc) )
            !                        end do
                                 end do
                              end do
            ! Put into global vector...
            ! Integrate both sides...
            !            stop 3123
            !         if(iface==3) return
                       end do ! do iface = 1, nface !  Between_Elements_And_Boundary 
                    end do ! do ele = 1, totele ! Surface integral
            ! 
            !         stop 382
                    return
                    end subroutine spacial_tables_for_dg_filters
            ! 
            ! 
            ! 
            ! 
                    subroutine on_fly_spacial_tables_for_dg_filters(a_filter, ml, source_vec, &
                                                             source,sigma,kdiff, u, dist_ele_face, x_loc,   & 
                                                             n, nlx, weight, sn, snlx, sweigh, &
                                                             nface,ndim,nloc,snloc,ngi,sngi)
                    implicit none
            ! integers representing the length of arrays...
            ! totele=no of elements,nloc=no of nodes per element, totele_nloc=totele*nloc
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
                    integer, parameter :: nsign=2
                    integer, intent( in ) :: nface,ndim,nloc,snloc,ngi,sngi
                    real, intent( in ) :: source(nloc),sigma(nloc),kdiff(ndim,nloc), u(ndim,nloc)
                    real, intent( in ) :: dist_ele_face(nface), x_loc(ndim,nloc)
                    real, intent( in ) :: n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi)
                    real, intent( in ) :: sn(sngi,snloc), snlx(sngi,ndim-1,snloc), sweigh(sngi)
                    real, intent( out ) :: a_filter(3,3,ndim-1,nloc), ml(nloc), source_vec(nloc)
            ! local variables - put on the stack for speed...
                    real nx(ngi,ndim,nloc),detwei(ngi),inv_jac(ngi,ndim,ndim)
                    real xc(ndim),sx_loc(ndim,snloc)
                    real sourcegi(ngi),sigmagi(ngi),kdiffgi(ngi,ndim),ugi(ngi,ndim),dudxgi(ngi,ndim)
            ! 
                    real norm(ndim),snorm(sngi,ndim),sdetwei(sngi)
            ! 
                    real skdiff(ndim,snloc),su(ndim,snloc)
                    real kdiffsgi(sngi,ndim),xsgi(sngi,ndim),usgi(sngi,ndim),income(sngi)
                    integer iloc,jloc,idim,jdim,idir, siloc,sjloc
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j,k, i2,j2,k2
                    integer iswitch,istart,ifinish
                    integer jswitch,jstart,jfinish
                    integer kswitch,kstart,kfinish
                    integer gi, sgi, iface, iloc_d
                    integer ii,jj,kk
                    real sarea, inv_dis, cont_diffusion, cont_advection_in, cont_advection_out
            ! 
            ! 
                    a_filter=0.0
            ! VOLUME integral
                    call det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, INV_JAC )
            
                    do gi=1,ngi
                       sourcegi(gi)=sum( n(gi,:)*source(:) )
                       sigmagi(gi)=sum( n(gi,:)*sigma(:) )
                       do idim=1,ndim
                          kdiffgi(gi,idim)=sum( n(gi,:)*kdiff(idim,:) )
                          ugi(gi,idim)   = sum( n(gi,:)*u(idim,:) )
                          dudxgi(gi,idim)= sum( nx(gi,idim,:)*u(idim,:) )
                       end do
                    end do
                    do iloc=1,nloc
                        ml(iloc)=sum( n(:,iloc)*detwei(:) )
                        source_vec(iloc)=sum( n(:,iloc)*sourcegi(:)*detwei(:) )
                    end do
                    do kkblock=1,ndim-1
                    do jjblock=1,2
                    do iiblock=1,2
                       iloc=1 + (2-iiblock) +(2-jjblock)*2   + (ndim-2)*(2-kkblock)*4
                       do kfil=1,ndim-1
                       do jfil=1,2
                       do ifil=1,2
                          jloc=ifil +(jfil-1)*2   + (kfil-1)*4
            ! 
                          i=ifil + (iiblock-1)*1
                          j=jfil + (jjblock-1)*1
                          k=kfil + (kkblock-1)*1
                          a_filter(i,j,k,iloc)=a_filter(i,j,k,iloc) + & 
                                 sum( n(:,iloc)*sigmagi(:)*n(:,jloc)*detwei(:) )  ! sbsoption
                          do idim=1,ndim
                             a_filter(i,j,k,iloc)=a_filter(i,j,k,iloc) + & 
                             sum( (  nx(:,idim,iloc)*kdiffgi(:,idim)*nx(:,idim,jloc)  & ! diffusion
                                   +(nx(:,idim,iloc)*ugi(:,idim)+n(:,iloc)*dudxgi(:,idim))*n(:,jloc) & ! advection
                                           )*detwei(:) )
                          end do
                       end do ! do ifil=1,2
                       end do ! do jjblock=1,2
                       end do ! do kkblock=1,ndim-1
                    end do ! do iiblock=1,2
                    end do ! do jjblock=1,2
                    end do ! do kkblock=1,ndim-1
            ! 
            ! surface integrals... 
                    do idim=1,ndim
                       xc(idim)=sum(x_loc(idim,:))/real(nloc) 
                    end do
            
                    do iface = 1, nface !  Between_Elements_And_Boundary 
            ! 
            ! idim is the dimension on which the face is and idir =1 if 1st face of dimension and =2 if second face. 
            ! iswitch=1 if face is on dimension idim else=0 similarly jswitch associated with idim=2. 
                       idim = 1 + (iface-1)/2 
                       idir = iface - idim*2 +2
            
            !           iswitch =   1-min(1,max(0,1-idim,idim-1))
                       iswitch =   1-min(1,abs(1-idim))
                       istart =1*(1-iswitch) + idir*iswitch
                       ifinish=2*(1-iswitch) + idir*iswitch
            
            !           jswitch =   1-max(0,2-idim,idim-2)
                       jswitch =   1-abs(2-idim)
                       jstart =1*(1-jswitch) + idir*jswitch
                       jfinish=2*(1-jswitch) + idir*jswitch
            
                       kswitch =   max(0,idim-2)
                       kstart =1*(1-kswitch) + idir*kswitch
                       kfinish=(ndim-1)*(1-kswitch) + idir*kswitch
            ! 
                       siloc=0
                       do kk=kstart,kfinish
                       do jj=jstart,jfinish
                       do ii=istart,ifinish
                          iloc=1+(ii-1) + (jj-1)*2 + (kk-1)*4
                          siloc=siloc+1
                          sx_loc(:,siloc) = x_loc(:,iloc)
                          skdiff(:,siloc) = kdiff(:,iloc)
                          su(:,siloc) = u(:,iloc)
                       end do
                       end do
                       end do
            ! 
                       do sgi=1,sngi
                          do jdim=1,ndim
                             kdiffsgi(sgi,jdim)=sum( sn(sgi,:)*skdiff(jdim,:) )
                             usgi(sgi,jdim) = sum( sn(sgi,:)*su(jdim,:) )
                             xsgi(sgi,jdim) = sum( sn(sgi,:)*sx_loc(jdim,:) )  
                          end do
                       end do
                       do jdim=1,ndim
                          norm(jdim) = sum(xsgi(:,jdim))/real(sngi) - xc(jdim)
                       end do
            ! start to do the integration...
                       call det_snlx_all( snloc, sngi, ndim-1, ndim, sx_loc, sn, snlx, &
                                                sweigh, sdetwei, sarea, snorm, norm )
                       inv_dis = 1.0/dist_ele_face(iface)
                       siloc=0
                       do kk=kstart,kfinish
                       do jj=jstart,jfinish
                       do ii=istart,ifinish
                          iloc=1+(ii-1) + (jj-1)*2 + (kk-1)*4
                          siloc=siloc+1
            ! 
            !              kkblock = 1 + (iloc-1)/4
            !              iloc_d  = iloc - (kkblock-1)*4
            !              jjblock = 1 + (iloc_d-1)/2
            !              iiblock = iloc_d - (jjblock-1)*2
            
                          kkblock = (3-kk)*(ndim-2) + 1*(3-ndim)
                          jjblock = 3-jj
                          iiblock = 3-ii
            !                
                          sjloc=0
                          do kfil=kstart,kfinish
                          do jfil=jstart,jfinish
                          do ifil=istart,ifinish
                             sjloc=sjloc+1
            ! 
                             i=ifil + (iiblock-1)*1
                             j=jfil + (jjblock-1)*1
                             k=kfil + (kkblock-1)*1
            ! 
                             i2=ifil + (iiblock-1)*1 + iswitch*(2*idir-3)
                             j2=jfil + (jjblock-1)*1 + jswitch*(2*idir-3)
                             k2=kfil + (kkblock-1)*1 + kswitch*(2*idir-3)
            ! nn for element ele
            !                 snorm(:,ndim+1)=0.0
            ! Integrate both sides...
                             cont_diffusion = 2.*inv_dis*sum( sn(:,siloc)*kdiffsgi(:,idim)*sn(:,sjloc) ) ! diffusion
                             a_filter(i,j,k,iloc)   =a_filter(i,j,k,iloc)    + cont_diffusion
                             a_filter(i2,j2,k2,iloc)=a_filter(i2,j2,k2,iloc) - cont_diffusion ! contribution on otherside of element
                             do sgi=1,sngi
                                income(sgi) = 0.5*sign(1.0, sum(-usgi(sgi,:)*snorm(sgi,:)))+0.5
                             end do
                             do jdim=1,ndim ! advection
                                cont_advection_in = sum( sn(:,siloc)*usgi(:,jdim)*snorm(:,jdim)*income(:)*sn(:,sjloc)*detwei(:) )
                                cont_advection_out= sum( sn(:,siloc)*usgi(:,jdim)*snorm(:,jdim)*(1.-income(:))*sn(:,sjloc)*detwei(:) )
                                a_filter(i,j,k,iloc)   =a_filter(i,j,k,iloc)    + cont_advection_out
                                a_filter(i2,j2,k2,iloc)=a_filter(i2,j2,k2,iloc) + cont_advection_in
                             end do
                          end do ! do ifil=istart,ifinish
                          end do ! do jfil=jstart,jfinish
                          end do ! do kfil=kstart,kfinish
                       end do ! do ii=istart,ifinish
                       end do ! do jj=jstart,jfinish
                       end do ! do kk=kstart,kfinish
            ! 
                    end do ! do iface = 1, nface 
            !         stop 382
                    return
                    end subroutine on_fly_spacial_tables_for_dg_filters
            ! 
            ! 
            ! 
            ! 
            ! The call from python looks like: 
            ! cube_sn_weight, cube_sn_direction = cube_sn_quadrature(nx_cube, ny_cube)
                    subroutine cube_sn_quadrature(cube_sn_weight, cube_sn_direction, nx_cube, ny_cube)
            ! This subroutine caclculates the Sn quadrature set. 
            ! It gives the direction of each Sn ordinate: cube_sn_direction(ix_cube, iy_cube, iface_cube) 
            ! in which ix_cube, iy_cube defines the cell on one of the 6 faces iface_cube on the cube-sphere. 
            ! cube_sn_weight contains the area associated with the patch on the unit sphere of 
            ! this Sn quadrature set. 
            ! nx_cube, ny_cube are the dimensions of the regular grid on each face of the cube  
            ! and for a multi-grid method it is suggested that they are a power of 2 so that the mult-grid 
            ! can coursen to one cell which results in 6 cells in total - one on each of the 6 faces. 
            ! The faces look like:
            !        !---------!
            !        !         !\
            !        !   5     ! \
            !        !         !  \
            !        !---------! 2!
            !         \    3    \ !
            !          \---------\!
            ! or in the xz plane:
            !       !---4---!
            !       !       !
            !       1       2
            !       !       !
            !       !---3---!
            ! or in the yz plane:
            !       !---6---!
            !       !       !
            !       1       2
            !       !       !
            !       !---5---!
            ! 
                    implicit none
                    integer, intent( in ) :: nx_cube, ny_cube
                    integer, parameter :: ndim=3, nloc=8, snloc=4, nface_cube=6 
                    real, intent( out ) :: cube_sn_weight(nx_cube, ny_cube, nface_cube)
                    real, intent( out ) :: cube_sn_direction(ndim,nx_cube, ny_cube, nface_cube)
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
            ! nloc=no of nodes per element. 
            ! local variables...
                    real, parameter :: pi = 3.14159265358
                    real, allocatable :: n(:,:), nlx(:,:,:), weight(:)
                    real, allocatable :: face_sn(:,:,:), face_sn2(:,:,:)
                    real, allocatable :: face_snlx(:,:,:,:), face_sweigh(:,:) 
                    real, allocatable :: sn(:,:), snlx(:,:,:)
                    real, allocatable :: norm(:),snorm(:,:),sdetwei(:),sweigh(:)
                    integer npoly,ele_type,idim, siloc, iface, nface, ix_cube, iy_cube, iface_cube
                    integer sngi, ngi, max_face_list_no
                    real sarea, dx, rnorm, sarea_sum
                    real direction(ndim), x_corn(ndim), sx_loc(ndim,snloc)
            !      
            ! 3d:
                    sngi=9
                    ngi=27
                    max_face_list_no=4
                    nface=6
            
                    allocate(n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi))
                    allocate(face_sn(sngi,snloc,nface), face_sn2(sngi,snloc,max_face_list_no) )
                    allocate(face_snlx(sngi,ndim-1,snloc,nface), face_sweigh(sngi,nface) )
                    allocate(sn(sngi,snloc), snlx(sngi,ndim-1,snloc)) 
            ! 
                    allocate(norm(ndim),snorm(sngi,ndim),sdetwei(sngi),sweigh(sngi))
            
            !         stop 3382
                    npoly=1
                    ele_type=1
            
            ! form the shape functions...
                    print *,'going into get_shape_funs_with_faces'
                    call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                    iface=1
                    sn(:,:) = face_sn(:,:,iface)
                    snlx(:,:,:) = face_snlx(:,:,:,iface)
                    sweigh(:)=face_sweigh(:,iface)
            
            ! 
            ! surface integrals... 
                    dx=2.0/real(nx_cube)
            ! do this for just the top surface of the sphere then work out the 
            ! sn wieghts and directions for the other faces. 
            
                    do iy_cube=1,ny_cube
                    do ix_cube=1,nx_cube
            !           ele = (iy_oct-1)*nx_oct + ix_oct
                        ! for copy local memory copying...
                       x_corn(1)=real(ix_cube-1)*dx - 1.0
                       x_corn(2)=real(iy_cube-1)*dx - 1.0
            ! define cornders of the square...
                       sx_loc(1,1) = x_corn(1)
                       sx_loc(2,1) = x_corn(2)
            
                       sx_loc(1,2) = x_corn(1) + dx
                       sx_loc(2,2) = x_corn(2)
            
                       sx_loc(1,3) = x_corn(1) 
                       sx_loc(2,3) = x_corn(2) + dx
            
                       sx_loc(1,4) = x_corn(1) + dx
                       sx_loc(2,4) = x_corn(2) + dx
            ! 
                       sx_loc(3,:) = 1.0
            ! now project onto unit sphere
                       do siloc=1,snloc
                          rnorm=sqrt(sum(sx_loc(:,siloc)**2))
                          sx_loc(:,siloc)=sx_loc(:,siloc)/rnorm
                       end do
            ! rotate according to iface_cube
            ! normal=(-1,0,0) to cube face...
                       norm(:) = 0.0
                       norm(3) = 1.0
            ! 
                       iface = 1
                       iface_cube=4
                               
            !                 s_list_no = face_list_no( iface, ele) 
            !           sn = face_sn(:,:,iface)
            !           snlx(:,:,:) = face_snlx(:,:,:,iface)
            !                 sn2 =face_sn2(:,:,s_list_no)
            ! start to do the integration...
                       call det_snlx_all( snloc, sngi, ndim-1, ndim, sx_loc, sn, snlx, &
                                          sweigh, sdetwei, sarea, snorm, norm )
                       cube_sn_weight(ix_cube,iy_cube,iface_cube) = sarea
                       do idim=1,ndim
                          direction(idim) = sum(sx_loc(idim,:))/real(snloc) 
                       end do
            ! make sure the sn direction has unit length
                       rnorm=sqrt(sum(direction(:)**2))
                       cube_sn_direction(:,ix_cube,iy_cube,iface_cube) = direction(:)/rnorm
            
            ! Put into global vector...
                    end do ! do ix_oct=1,ny_oct
                    end do ! do iy_oct=1,ny_oct
            
            ! norm form the sn quadrature on the 6 faces of the cube. 
                    do iface_cube=1,nface_cube
                       cube_sn_direction(:,:,:,iface_cube) = cube_sn_direction(:,:,:,4) 
            ! normal=(-1,0,0) to cube face...
                       if(iface_cube==1) then ! swap x and z over and make x -ve
                          cube_sn_direction(1,:,:,iface_cube) = -cube_sn_direction(3,:,:,4) 
                          cube_sn_direction(3,:,:,iface_cube) = cube_sn_direction(1,:,:,4) 
                       endif
            ! normal=(1,0,0) to cube face...
                       if(iface_cube==2) then ! swap x and z over
                          cube_sn_direction(1,:,:,iface_cube) = cube_sn_direction(3,:,:,4) 
                          cube_sn_direction(3,:,:,iface_cube) = cube_sn_direction(1,:,:,4) 
                       endif
            ! normal=(0,0,-1) to cube face...
                       if(iface_cube==3) then ! change sign of z coord
                          cube_sn_direction(3,:,:,iface_cube) = -cube_sn_direction(3,:,:,4) 
                       endif
            ! normal=(0,0,1) to cube face...
                       if(iface_cube==4) then ! iface_cube==4 do nothing.
                       endif
            ! normal=(0,-1,0) to cube face...
                       if(iface_cube==5) then ! swap y and z over and make y -ve
                          cube_sn_direction(2,:,:,iface_cube) = -cube_sn_direction(3,:,:,4) 
                          cube_sn_direction(3,:,:,iface_cube) = cube_sn_direction(2,:,:,4) 
                       endif
            ! normal=(0,1,0) to cube face...
                       if(iface_cube==6) then ! swap y and z over
                          cube_sn_direction(2,:,:,iface_cube) = cube_sn_direction(3,:,:,4) 
                          cube_sn_direction(3,:,:,iface_cube) = cube_sn_direction(2,:,:,4) 
                       endif
                       cube_sn_weight(:,:,iface_cube) = cube_sn_weight(:,:,4) 
                    end do ! do iface_oct=1,nface_oct
            ! r-normalise so the area is the same as the unit sphere. 
                    sarea_sum = sum(cube_sn_weight) 
                    cube_sn_weight = cube_sn_weight * 4.0*pi/sarea_sum
            ! 
            !         stop 382
                    return
                    end subroutine cube_sn_quadrature
            ! 
            ! 
            ! 
            ! 
                    subroutine file_generator4octant_sn_quadrature
            ! this subroutine outputs a file containing the quadrature directions and 
            ! weights associated with the discrete ordinate discretisation of the unit sphere. 
            ! nx_cube, ny_cube are the number of cells across and up for each of 
            ! the eight patches on the octant that produces a discretisation of the unit sphere.
            ! CHANGE nx_cube, ny_cube as necessary to increase the quadrature points. 
                    integer, parameter :: nx_cube=4, ny_cube=4  
                    integer, parameter :: ndim=3, nloc=8, snloc=4, nface_cube=8 
                    integer iface_cube, idim, ix_cube, iy_cube
                    real, allocatable :: cube_sn_weight(:, :, :)
                    real, allocatable :: cube_sn_direction(:,:, :, :)
            
                    allocate(cube_sn_weight(nx_cube, ny_cube, nface_cube))
                    allocate(cube_sn_direction(ndim,nx_cube, ny_cube, nface_cube))
            ! 
                    call octant_sn_quadrature(cube_sn_weight, cube_sn_direction, nx_cube, ny_cube)
            ! 
                    open(27, file='octant_sn_quadrature.csv')
                    write(27,*) 'This outputs a file containing the quadrature directions and '
                    write(27,*) 'weights associated with the discrete ordinate discretisation of the unit sphere.' 
                    write(27,*) 'nx_cube, ny_cube are the number of cells across and up for each of '
                    write(27,*) 'the eight patches on the octant that produces a discretisation of the unit sphere.'
                    write(27,*)
                    write(27,*) 'nface_cube, ndim, nx_cube, ny_cube'
                    write(27,*) 'do iface_cube=1,nface_cube'
                    write(27,*) '      do iy_cube = 1, ny_cube'
                    write(27,*) '         write(27,*) cube_sn_weight(:,iy_cube,iface_cube) '
                    write(27,*) '      end do'
                    write(27,*) 'end do ! do iface_cube=1,nface_cube'
                    write(27,*) 
                    write(27,*) 'do iface_cube=1,nface_cube'
                    write(27,*) '   do idim=1,ndim'
                    write(27,*) '      do iy_cube = 1, ny_cube'
                    write(27,*) '         write(27,*) cube_sn_direction(idim,:,iy_cube,iface_cube) '
                    write(27,*) '      end do'
                    write(27,*) '   end do ! do idim=1,ndim'
                    write(27,*) 'end do ! do iface_cube=1,nface_cube'
                    write(27,*)
                    write(27,*) nface_cube, ndim, nx_cube, ny_cube
                    do iface_cube=1,nface_cube
                          do iy_cube = 1, ny_cube
                             write(27,*) cube_sn_weight(:,iy_cube,iface_cube) 
                          end do
                    end do ! do iface_cube=1,nface_cube
                    write(27,*)
                    do iface_cube=1,nface_cube
                       do idim=1,ndim
                          do iy_cube = 1, ny_cube
                             write(27,*) cube_sn_direction(idim,:,iy_cube,iface_cube) 
                          end do
                       end do ! do idim=1,ndim
                    end do ! do iface_cube=1,nface_cube
                    close(27)
                    return
                    end subroutine file_generator4octant_sn_quadrature
            ! 
            ! 
            ! 
            ! 
            ! The call from python looks like: 
            ! cube_sn_weight, cube_sn_direction = octant_sn_quadrature(nx_cube, ny_cube)
                    subroutine octant_sn_quadrature(cube_sn_weight, cube_sn_direction, nx_cube, ny_cube)
            ! This subroutine caclculates the Sn quadrature set. 
            ! It gives the direction of each Sn ordinate: octant_sn_direction(ix_cube, iy_cube, iface_cube) 
            ! in which ix_cube, iy_cube defines the cell on one of the 6 faces iface_cube on the octant-sphere. 
            ! cube_sn_weight contains the area associated with the patch on the unit sphere of 
            ! this Sn quadrature set. 
            ! nx_cube, ny_cube are the dimensions of the regular grid on each face of the cube  
            ! and for a multi-grid method it is suggested that they are a power of 2 so that the mult-grid 
            ! can coursen to one cell which results in 8 cells in total - one on each of the 8 faces. 
            ! The faces look like at the top of the sphere:
            !          o     
            !        / ! \     
            !      /   !   \    
            !    /  3  !  4  \   
            !   o------o------o
            !    \  1  !  2  /     
            !      \   !   /   
            !        \ ! /   
            !          o
            ! and at the bottom of the sphere - still looking from the top but underneath:
            !          o     
            !        / ! \     
            !      /   !   \    
            !    /  7  !  8  \   
            !   o------o------o
            !    \  5  !  6  /     
            !      \   !   /   
            !        \ ! /   
            !          o
                    implicit none
                    integer, intent( in ) :: nx_cube, ny_cube
                    integer, parameter :: ndim=3, nloc=8, snloc=4, nface_cube=8 
                    real, intent( out ) :: cube_sn_weight(nx_cube, ny_cube, nface_cube)
                    real, intent( out ) :: cube_sn_direction(ndim,nx_cube, ny_cube, nface_cube)
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces.
            ! ndim=no of dimensions - including time possibly, nface=no of faces of each elemenet, nc no of fields to solve for.
            ! nloc=no of nodes per element. 
            ! local variables...
                    real, parameter :: pi = 3.14159265358
                    real, allocatable :: n(:,:), nlx(:,:,:), weight(:)
                    real, allocatable :: face_sn(:,:,:), face_sn2(:,:,:)
                    real, allocatable :: face_snlx(:,:,:,:), face_sweigh(:,:) 
                    real, allocatable :: sn(:,:), snlx(:,:,:)
                    real, allocatable :: norm(:),snorm(:,:),sdetwei(:),sweigh(:)
                    real, allocatable :: sx_loc_sgi(:,:)
                    integer npoly,ele_type,idim, siloc, iface, nface, ix_cube, iy_cube, iface_cube
                    integer sngi, ngi, max_face_list_no, sgi, icorn
                    real sarea, dx, rnorm, sarea_sum
                    real direction(ndim), x_corn(ndim), sx_loc(ndim,snloc)
                    real lx(4), ly(4), lz(4), x_interp_corn(ndim,4)
            !      
            ! 3d:
                    sngi=9
                    ngi=27
                    max_face_list_no=4
                    nface=6
            
                    allocate(n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi))
                    allocate(face_sn(sngi,snloc,nface), face_sn2(sngi,snloc,max_face_list_no) )
                    allocate(face_snlx(sngi,ndim-1,snloc,nface), face_sweigh(sngi,nface) )
                    allocate(sn(sngi,snloc), snlx(sngi,ndim-1,snloc)) 
            ! 
                    allocate(norm(ndim),snorm(sngi,ndim),sdetwei(sngi),sweigh(sngi))
            
                    allocate(sx_loc_sgi(ndim,sngi))
            
            !         stop 3382
                    npoly=1
                    ele_type=1
            
            ! form the shape functions...
                    print *,'going into get_shape_funs_with_faces'
                    call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                    iface=1
                    sn(:,:) = face_sn(:,:,iface)
                    snlx(:,:,:) = face_snlx(:,:,:,iface)
                    sweigh(:)=face_sweigh(:,iface)
            
            ! 
            ! surface integrals... 
                    dx=1.0/real(nx_cube)
            ! do this for just the top surface of the sphere then work out the 
            ! sn wieghts and directions for the other faces. 
            ! interpolations corners
            ! local nodes...
            !       3-------4     
            !       !       !
            !       !       !
            !       !       !
            !       1-------2
            ! This is mapped to a triangle with a collapsed node (1 and 3): 
            !       4     
            !       ! \     
            !       !   \    
            !       !     \   
            !      1,3------2
            ! With nodal coordinates...
            !     (0,1)     
            !       ! \     
            !       !   \    
            !       !     \   
            !     (0,0)----(1,0)
            ! the cells are numbered in the non-distorted system...
            !        1,4   2,4   3,4   4,4
            !        1,3   2,3   3,3   4,3
            !        1,2   2,2   3,2   4,2
            !        1,1   2,1   3,1   4,1
            ! 1st node...
                    x_interp_corn(1,1)=0.0
                    x_interp_corn(2,1)=0.0
                    x_interp_corn(3,1)=1.0
            ! 2nd node...
                    x_interp_corn(1,2)=1.0
                    x_interp_corn(2,2)=0.0
                    x_interp_corn(3,2)=0.0
            ! 3rd node (collapsed node same as node 1)...
                    x_interp_corn(1,3)=0.0
                    x_interp_corn(2,3)=0.0
                    x_interp_corn(3,3)=1.0
            ! 4th node...
                    x_interp_corn(1,4)=0.0
                    x_interp_corn(2,4)=1.0
                    x_interp_corn(3,4)=0.0
            ! 
                    do iy_cube=1,ny_cube
                    do ix_cube=1,nx_cube
            !           ele = (iy_oct-1)*nx_oct + ix_oct
                        ! for copy local memory copying...
                       x_corn(1)=real(ix_cube-1)*dx 
                       x_corn(2)=real(iy_cube-1)*dx 
            ! define cornders of the square...
                       lx(1) = x_corn(1)
                       ly(1) = x_corn(2)
            
                       lx(2) = x_corn(1) + dx
                       ly(2) = x_corn(2)
            
                       lx(3) = x_corn(1) 
                       ly(3) = x_corn(2) + dx
            
                       lx(4) = x_corn(1) + dx
                       ly(4) = x_corn(2) + dx
            
                       lz(:)=1.0-lx(:)
            
            ! now linearly interpolate corner nodes
                       do icorn=1,4
                          sx_loc(1:3,icorn) = (1.0-lx(icorn))*(1.0-ly(icorn))*x_interp_corn(1:3,1) &
                                            +      lx(icorn) *(1.0-ly(icorn))*x_interp_corn(1:3,2) &
                                            + (1.0-lx(icorn))*ly(icorn)      *x_interp_corn(1:3,3) &
                                            +      lx(icorn) *ly(icorn)      *x_interp_corn(1:3,4)
                       end do
            ! now project onto unit sphere
                       do siloc=1,snloc
                          rnorm=sqrt(sum(sx_loc(:,siloc)**2))
                          sx_loc(:,siloc)=sx_loc(:,siloc)/rnorm
                       end do
            ! rotate according to iface_cube
            ! normal=(-1,0,0) to cube face...
                       norm(:) = 0.0
                       norm(3) = 1.0
            ! 
                       iface = 1
                       iface_cube=4
                               
            !                 s_list_no = face_list_no( iface, ele) 
            !           sn = face_sn(:,:,iface)
            !           snlx(:,:,:) = face_snlx(:,:,:,iface)
            !                 sn2 =face_sn2(:,:,s_list_no)
            ! start to do the integration...
                       call det_snlx_all( snloc, sngi, ndim-1, ndim, sx_loc, sn, snlx, &
                                          sweigh, sdetwei, sarea, snorm, norm )
                       cube_sn_weight(ix_cube,iy_cube,iface_cube) = sarea
                       do idim=1,ndim
                          do sgi=1,sngi
                             sx_loc_sgi(idim,sgi) = sum(sn(sgi,:)*sx_loc(idim,:)) 
                          end do
                       end do
                       do idim=1,ndim
                          direction(idim) = sum(sx_loc_sgi(idim,:)*sdetwei(:))/sum(sdetwei(:)) 
                       end do
            ! make sure the sn direction has unit length
                       rnorm=sqrt(sum(direction(:)**2))
                       cube_sn_direction(:,ix_cube,iy_cube,iface_cube) = direction(:)/rnorm
            
            ! Put into global vector...
                    end do ! do ix_oct=1,ny_oct
                    end do ! do iy_oct=1,ny_oct
            
            ! norm form the sn quadrature on the 6 faces of the cube. 
                    do iface_cube=1,nface_cube
                       cube_sn_direction(:,:,:,iface_cube) = cube_sn_direction(:,:,:,4) 
            ! normal=(-1,0,0) to cube face...
                       if(iface_cube==1) then ! swap x and z over and make x -ve
                          cube_sn_direction(1,:,:,iface_cube) = -cube_sn_direction(1,:,:,4)
                          cube_sn_direction(2,:,:,iface_cube) = -cube_sn_direction(2,:,:,4)  
                          cube_sn_direction(3,:,:,iface_cube) = +cube_sn_direction(3,:,:,4) 
                       endif
            ! normal=(1,0,0) to cube face...
                       if(iface_cube==2) then ! swap x and z over
                          cube_sn_direction(1,:,:,iface_cube) = +cube_sn_direction(1,:,:,4)
                          cube_sn_direction(2,:,:,iface_cube) = -cube_sn_direction(2,:,:,4)  
                          cube_sn_direction(3,:,:,iface_cube) = +cube_sn_direction(3,:,:,4) 
                       endif
            ! normal=(0,0,-1) to cube face...
                       if(iface_cube==3) then ! change sign of z coord
                          cube_sn_direction(1,:,:,iface_cube) = -cube_sn_direction(1,:,:,4)
                          cube_sn_direction(2,:,:,iface_cube) = +cube_sn_direction(2,:,:,4)  
                          cube_sn_direction(3,:,:,iface_cube) = +cube_sn_direction(3,:,:,4) 
                       endif
            ! normal=(0,0,1) to cube face...
                       if(iface_cube==4) then ! iface_cube==4 do nothing.
                       endif
            ! normal=(0,-1,0) to cube face...
                       cube_sn_weight(:,:,iface_cube) = cube_sn_weight(:,:,4) 
                    end do ! do iface_oct=1,nface_oct
            ! bottom half of the unit sphere.  
                    cube_sn_direction(1,:,:,5:8) = +cube_sn_direction(1,:,:,1:4) 
                    cube_sn_direction(2,:,:,5:8) = +cube_sn_direction(2,:,:,1:4) 
                    cube_sn_direction(3,:,:,5:8) = -cube_sn_direction(3,:,:,1:4) 
            ! 
            ! r-normalise so the area is the same as the unit sphere. 
                    sarea_sum = sum(cube_sn_weight) 
                    cube_sn_weight = cube_sn_weight * 4.0*pi/sarea_sum
            ! 
            !         stop 382
                    return
                    end subroutine octant_sn_quadrature
            ! 
            ! 
            ! 
            ! 
            ! in python:
            ! a_sfc, b_sfc, ml_sfc, fin_sfc_nonods, nonods_sfc_all_grids, nlevel = sfc_mapping_to_sfc_matrix( &
            !                                     a, b, ml, &
            !                                     fina,cola, ncola, sfc_node_ordering, &
            !                                     nonods, max_nonods_sfc_all_grids, max_nlevel) 
                  subroutine sfc_mapping_to_sfc_matrix(a_sfc, b_sfc, ml_sfc, fin_sfc_nonods, nonods_sfc_all_grids, nlevel, &
                                                 a, b, ml, &
                                                 fina,cola, sfc_node_ordering, ncola, &
                                                 nonods, max_nonods_sfc_all_grids, max_nlevel) 
            ! this subroutine finds the space filling curve representation of matrix eqns A T=b 
            ! - that is it forms matrix a and vector b and the soln vector is T 
            ! although T is not needed here. 
            ! It also puts the vector b in space filling curve ordering. 
            ! it forms a series of matricies and vectors on a number of increasing coarse 1d grids 
            ! from nonods in length to 1 in length and stores this matrix in a_sfc. Similarly for the vectors b,ml 
            ! which are stored in b_sfc, ml_sfc. 
                    implicit none
            ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
            ! are nlevel grids from course to fine. 
            ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
            ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
            ! sfc_node_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
            ! the space filling curve trajectory. 
            ! nonods=number of finite element nodes in the mesh.
            ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
            ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
            ! call in python: nlevel = calculate_nlevel_sfc(nonods)
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
                    integer, intent( in ) :: ncola, nonods, max_nonods_sfc_all_grids, max_nlevel
                    real, intent( out ) :: a_sfc(3,max_nonods_sfc_all_grids), b_sfc(max_nonods_sfc_all_grids), &
                                           ml_sfc(max_nonods_sfc_all_grids) 
                    real, intent( in ) :: a(ncola), b(nonods), ml(nonods)
                    integer, intent( out ) :: nonods_sfc_all_grids, fin_sfc_nonods(max_nlevel), nlevel
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    integer, intent( in ) :: sfc_node_ordering(nonods)
            ! local variables...
                    integer i, count, nodj, prev_nodi_sfc, next_nodi_sfc, nodi_sfc, ilevel
                    integer sfc_nonods_fine, sfc_nonods_course, sfc_nonods_accum 
            ! 
                    print *,'dont use - use the best version' 
                    stop 2231
            ! calculate nlevel from nonods
                    call calculate_nlevel_sfc(nlevel,nonods)
            ! form SFC matrix...
                    a_sfc(:,:)=0.0
                    b_sfc(:)=0.0; b_sfc(1:nonods)=b(1:nonods)
                    ml_sfc(:)=0.0; ml_sfc(1:nonods)=ml(1:nonods)
            ! 
                    do i=1,nonods
                       prev_nodi_sfc = 0
                       next_nodi_sfc = 0
                       if(i.ne.1) prev_nodi_sfc = sfc_node_ordering(i-1)
                       if(i.ne.nonods) next_nodi_sfc = sfc_node_ordering(i+1)
                       nodi_sfc=sfc_node_ordering(i)
                       do count=fina(nodi_sfc),fina(nodi_sfc+1)-1
                          nodj=cola(count)
                          if(nodj==prev_nodi_sfc) then
                             a_sfc(1,nodi_sfc)=a_sfc(1,nodi_sfc)+a(count)
                          else if(nodj==next_nodi_sfc) then
                             a_sfc(3,nodi_sfc)=a_sfc(3,nodi_sfc)+a(count)
                          else 
                             a_sfc(2,nodi_sfc)=a_sfc(2,nodi_sfc)+a(count) ! diagonal
                          endif
                       end do
                    end do
                    sfc_nonods_accum=1
                    fin_sfc_nonods(1)=sfc_nonods_accum
                    sfc_nonods_accum=sfc_nonods_accum + nonods
                    fin_sfc_nonods(2)=sfc_nonods_accum 
            ! 
            ! coarsen...
                    do ilevel=2,nlevel
                       sfc_nonods_fine=fin_sfc_nonods(ilevel)-fin_sfc_nonods(ilevel-1)
                       if(sfc_nonods_fine.le.1) stop 13331 ! something went wrong. 
                       sfc_nonods_course = (sfc_nonods_fine-1)/2 + 1
                       call map_sfc_course_grid( a_sfc(:,fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                 a_sfc(:,fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
            
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     ml_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     ml_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       call map_sfc_fine_grid_2_course_grid_vec( &
                                                     b_sfc(fin_sfc_nonods(ilevel)),sfc_nonods_course, &
                                                     b_sfc(fin_sfc_nonods(ilevel-1)),sfc_nonods_fine)
                       sfc_nonods_accum = sfc_nonods_accum + sfc_nonods_course
                       fin_sfc_nonods(ilevel+1)=sfc_nonods_accum
                    end do
                    nonods_sfc_all_grids=sfc_nonods_accum
                    if(max_nonods_sfc_all_grids<nonods_sfc_all_grids) then
                       print *,'run out of memory here stopping'
                       stop 2822
                    endif
                    return 
                    end subroutine sfc_mapping_to_sfc_matrix
            ! 
            ! 
            ! 
            ! 
                    subroutine map_sfc_course_grid( a_sfc_course,sfc_nonods_course, a_sfc_fine,sfc_nonods_fine)
                    implicit none 
                    integer, intent( in ) :: sfc_nonods_course, sfc_nonods_fine
                    real, intent( out ) :: a_sfc_course(3,sfc_nonods_course)
                    real, intent( in ) :: a_sfc_fine(3,sfc_nonods_fine)
            ! local variables...
                    integer i_short, i_long
            ! 
                    a_sfc_course(:,:)=0.0
                    do i_short=1,sfc_nonods_course
                       i_long=(i_short-1)*2 + 1
                       a_sfc_course(1,i_short)=a_sfc_course(1,i_short)+a_sfc_fine(1,i_long)
                       a_sfc_course(2,i_short)=a_sfc_course(2,i_short)+a_sfc_fine(2,i_long)
                       a_sfc_course(2,i_short)=a_sfc_course(2,i_short)+a_sfc_fine(3,i_long)
            
                       i_long=(i_short-1)*2 + 2
                       a_sfc_course(2,i_short)=a_sfc_course(2,i_short)+a_sfc_fine(1,i_long)
                       a_sfc_course(2,i_short)=a_sfc_course(2,i_short)+a_sfc_fine(2,i_long)
                       a_sfc_course(3,i_short)=a_sfc_course(3,i_short)+a_sfc_fine(3,i_long)
                    end do
                    
                    return 
                    end subroutine map_sfc_course_grid
            ! 
            ! 
            ! 
            ! 
                    subroutine map_sfc_fine_grid_2_course_grid_vec( ml_sfc_course,sfc_nonods_course, &
                                                                    ml_sfc_fine,sfc_nonods_fine)
                    implicit none 
                    integer, intent( in ) :: sfc_nonods_course, sfc_nonods_fine
                    real, intent( out ) :: ml_sfc_course(sfc_nonods_course)
                    real, intent( in ) :: ml_sfc_fine(sfc_nonods_fine)
            ! local variables...
                    integer i_short, i_long
            ! 
                    ml_sfc_course(:)=0.0
            !        do i_short=1,sfc_nonods_course
            !           i_long=(i_short-1)*2 + 1
            !           ml_sfc_course(i_short)=ml_sfc_course(i_short)+ml_sfc_fine(i_long)
            
            !           i_long=min( (i_short-1)*2 + 2, sfc_nonods_fine)----miss this out---
            !           ml_sfc_course(i_short)=ml_sfc_course(i_short)+ml_sfc_fine(i_long)
            !        end do
            ! 
                    do i_long=1,sfc_nonods_fine,2
                       i_short=(i_long-1)/2 + 1
                       ml_sfc_course(i_short)=ml_sfc_course(i_short)+ml_sfc_fine(i_long)
                    end do
                    do i_long=2,sfc_nonods_fine,2
                       i_short=(i_long-1)/2 + 1
                       ml_sfc_course(i_short)=ml_sfc_course(i_short)+ml_sfc_fine(i_long)
                    end do
                    
                    return 
                    end subroutine map_sfc_fine_grid_2_course_grid_vec
            ! 
            ! 
            ! 
            ! 
                    subroutine map_sfc_course_grid_2_fine_grid_vec( ml_sfc_fine,sfc_nonods_fine, &
                                                                    ml_sfc_course,sfc_nonods_course)
                    implicit none 
                    integer, intent( in ) :: sfc_nonods_course, sfc_nonods_fine
                    real, intent( in ) :: ml_sfc_course(sfc_nonods_course)
                    real, intent( out ) :: ml_sfc_fine(sfc_nonods_fine)
            ! local variables...
                    integer i_short, i_long
            ! 
                    do i_long=1,sfc_nonods_fine,2
                       i_short=(i_long-1)/2 + 1
                       ml_sfc_fine(i_long) = ml_sfc_course(i_short)
                    end do
                    do i_long=2,sfc_nonods_fine,2
                       i_short=(i_long-1)/2 + 1
                       ml_sfc_fine(i_long) = ml_sfc_course(i_short)
                    end do
                    
                    return 
                    end subroutine map_sfc_course_grid_2_fine_grid_vec
            ! 
            ! 
            ! 
            ! in python:
            ! t_new = time_step_filter_matrix( t_old, a_filter, fina,cola, ncola,nonods)
                   subroutine time_step_filter_matrix(t_new, t_old, a_filter,   &
                                                 fina,cola, ncola, nonods)
            ! this subroutine finds T^{n+1} = a_filter * T^n 
                    implicit none
            ! nonods=number of finite element nodes in the mesh.
            ! dt = time step size. 
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
                    integer, intent( in ) :: ncola, nonods
                    real, intent( out ) :: t_new(nonods)
                    real, intent( in ) :: a_filter(ncola)
                    real, intent( in ) :: t_old(nonods)
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
            ! local variables...  
                    integer count,nodi,icol
            ! 
                    t_new=0.0
                    do nodi=1,nonods
                       do count=fina(nodi),fina(nodi+1)-1
                          icol=cola(count)
                          t_new(nodi) = t_new(nodi) + a_filter(count) * t_old(icol) 
                       end do
                    end do
            ! 
                    return
                    end subroutine time_step_filter_matrix
            ! 
            ! in python:
            ! a_filter = get_filter_matrix( a, ml, dt, fina,cola, ncola,nonods)
                   subroutine get_filter_matrix(a_filter, a, ml, dt,  &
                                                 fina,cola, ncola,nonods)
            ! this subroutine finds the matrix eqns a_filter = -M_L^{-1} ( -M_L + dt* A). 
            ! Time stepping can be realised with T^{n+1} = a_filter * T^n 
                    implicit none
            ! nonods=number of finite element nodes in the mesh.
            ! dt = time step size. 
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
                    integer, intent( in ) :: ncola, nonods
                    real, intent( out ) :: a_filter(ncola)
                    real, intent( in ) :: a(ncola), ml(nonods), dt
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
            ! local variables...  
                    integer count,nodi,icol
            
                    a_filter = dt*a 
                    do nodi=1,nonods
                       do count=fina(nodi),fina(nodi+1)-1
                          icol=cola(count)
                          if(icol==nodi) a_filter(count) = a_filter(count) - ml(nodi) 
                       end do
                    end do
            ! 
                    do nodi=1,nonods
                       do count=fina(nodi),fina(nodi+1)-1
                          a_filter(count) = - a_filter(count)/ml(nodi) 
                       end do
                    end do
            ! 
                    return
                    end subroutine get_filter_matrix
            ! 
            ! 
            ! in python:
            ! a, b = u2r.get_fe_matrix_eqn(x_all, u, k, sig, s, fina,cola, ncola, ndglno, nonods,totele,nloc, ndim, ele_type)
            ! ml = the lumped mass 
                    subroutine get_fe_matrix_eqn(a,b, ml, k, sig, s, u, x_all, &
                                                 fina,cola, ndglno,  &
                                                 ele_type, ndim, totele,nloc, ncola,nonods) 
            ! this subroutine finds the matrix eqns A T=b - that is it forms matrix a and vector b and the soln vector is T 
            ! although T is not needed here. 
                    implicit none
            ! nonods=number of finite element nodes in the mesh.
            ! totele=no of elements in the mesh. 
            ! nloc=no of local nodes per element.
            ! ndim=no of dimensions.
            ! ele_type=element type index.
            ! 
            ! x_all contains the coordinates 
            ! and x_all(idim, (ele-1)*nloc+iloc) contains the idim'th coorindate for element number ele and local node 
            ! number iloc associated with element ele. 
            ! That is idim=1 corresponds to x coord, idim=2 y coordinate, idim=3 z coordinate.
            !  
            ! u, k, sig, s the velocities, diffusion coefficient, absorption coefficient and source respectively of the differential equation. 
            ! The eqn we are solving is u\cdot\nabla T - \nabla \cdot k \nabla T + \sig T = s. 
            ! u(idim,inod) is the idim'th dimensional velocity (idim=1 corresponds to x-coord velocity) 
            ! of finite element node inod. 
            ! k(inod)=the diffusion coefficient of fem node nodi and similarly for sig, s. 
            ! 
            ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
            ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
            ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
            ! fina(inod) start of the inod row of a matrix.
            ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
            !      1-----2-----3
            !      !     !     !
            !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
            !      4-----5-----6
            ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
            !           1  2  3  4  5  6 - column
            ! row 1    (X  X  0  X  X  0)
            ! row 2    (X  X  X  X  X  X)
            ! row 3    (0  X  X  0  X  X)
            ! row 4    (X  X  0  X  X  0)
            ! row 5    (X  X  X  X  X  X)
            ! row 6    (0  X  X  0  X  X)
            ! The comparact row storage only stores the non-zeros. 
            ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
            ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
            ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
            ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
            ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
            ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
            !                                                                                             fina(7)=29
            ! 
            ! 
            ! ndglno contains the gloabal node number given a local node number and element number. 
            ! Thus ndglno((ele-1)*nloc+iloc) contains the global node number for element number ele and local node 
            ! number iloc associated with element ele.
            !         
            ! local variables...
            ! 2d:
            !        integer, parameter :: totele=1,nloc=4,sngi=3, ngi=9, ndim=2, nface=4, max_face_list_no=2
            ! 3d:
            !        integer, parameter :: totele=1,nloc=8,sngi=9, ngi=27, ndim=3, nface=6, max_face_list_no=4
            !        real :: n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi)
            !        real :: face_sn(sngi,nloc,nface), face_sn2(sngi,nloc,max_face_list_no), face_snlx(sngi,ndim,nloc,nface), face_sweigh(sngi,nface) 
                    integer, intent( in ) :: ndim, totele, nloc, ele_type,  ncola, nonods
                    real, intent( out ) :: a(ncola), b(nonods), ml(nonods)
                    real, intent( in ) :: k(ndim,nonods), sig(nonods), s(nonods)
                    real, intent( in ) :: u(ndim,nonods)
                    real, intent( in ) :: x_all(ndim,nloc*totele)
                    integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    integer, intent( in ) :: ndglno(nloc*totele)
            ! local variables...
                    real, allocatable :: n(:,:), nlx(:,:,:), weight(:)
                    real, allocatable :: face_sn(:,:,:), face_sn2(:,:,:)
                    real, allocatable :: face_snlx(:,:,:,:), face_sweigh(:,:) 
                    real, allocatable :: nx(:,:,:),detwei(:),inv_jac(:,:,:)
                    real, allocatable :: x_loc(:,:)
                    real, allocatable :: ugi(:,:), kgi(:,:), sgi(:), siggi(:)
                    real, allocatable :: l1(:), l2(:), l3(:), l4(:)  
                    logical, allocatable :: lmark(:)
                    integer npoly,ele, iloc,jloc,idim
                    integer ifil,jfil,kfil, iiblock, jjblock, kkblock, i,j
                    integer count, nodi, nodj
                    integer sngi, ngi, nface, max_face_list_no, snloc
                    real nxnx_k, nnx_u, nnsig, aa, max_x2
                    logical d3, triangle_or_tet_high_order
            
            ! sngi=no of surface quadrature points of the faces - this is set to the max no of all faces.
            ! ngi=no of surface quadrature points of the faces. 
            ! nface=no of faces of each elemenet, nc no of fields to solve for.
                triangle_or_tet_high_order=.false.
                if( ((nloc==3).or.(nloc==6).or.(nloc==10).or.(nloc==15)) .and.(ndim==2)) then
                   triangle_or_tet_high_order= .true. 
                endif
                if( ((nloc==4).or.(nloc==10).or.(nloc==20).or.(nloc==35)) .and.(ndim==3)) then
                   triangle_or_tet_high_order= .true. 
                endif
            ! 
                    if(ele_type.ge.100) then ! triangle or tet...
                       if(ndim==2) then
                          sngi=2; ngi=3; nface=3; max_face_list_no=2
                          snloc=2
                          if(triangle_or_tet_high_order) ngi=14
                       else if(ndim==3) then
                          sngi=3; ngi=4; nface=4; max_face_list_no=3
                          snloc=3
                          if(triangle_or_tet_high_order) ngi=45
                       endif
                    else ! rectangle...
                       if(ndim==2) then
                          sngi=3; ngi=9; nface=4; max_face_list_no=2
                          snloc=2
                       else if(ndim==3) then
                          sngi=9; ngi=27; nface=6; max_face_list_no=4
                          snloc=4
                       endif
                    endif
            
            ! 
                    allocate( n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi) )
                    allocate( face_sn(sngi,snloc,nface) )
                    allocate( face_sn2(sngi,snloc,max_face_list_no) )
                    allocate( face_snlx(sngi,ndim-1,snloc,nface), face_sweigh(sngi,nface) )
            
                    allocate(nx(ngi,ndim,nloc),detwei(ngi),inv_jac(ngi,ndim,ndim))
            !        allocate(nxnx(nloc,nloc),nnx(ndim,nloc,nloc))
                    allocate(x_loc(ndim,nloc)) 
            
                    allocate(ugi(ngi,ndim), kgi(ngi,ndim), sgi(ngi), siggi(ngi))
            
                    npoly=1
            !        ele_type=1
            
            ! form the shape functions...
                  if(triangle_or_tet_high_order) then
                    allocate(l1(ngi), l2(ngi), l3(ngi), l4(ngi) ) 
            !        stop 22221
              !
                    d3=(ndim==3)
            !       print *,'****GOING bbbbbonkers 1'
                    call TRIQUAold(L1, L2, L3, L4, WEIGHT, D3,NGI)
            
            !        print *,'d3,nloc,ngi,ndim:',d3,nloc,ngi,ndim
            !        print *,'l1,l2,l3:',l1,l2,l3
            !        print *,'weight:',weight
            !       print *,'****GOING bbbbbonkers 2'
                    call SHATRInew(L1, L2, L3, L4, weight, &
                      nloc,ngi,ndim,  n,nlx) 
            !       print *,'****GOING bbbbbonkers 3'
            !       stop 2821
                  else
                    print *,'going into get_shape_funs_with_faces'
                    call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                  endif
            ! 
            !        print *,'k:',k
            !        print *,'sig:',sig
            !        print *,'s:',s 
            !        print *,'u:',u
            !        print *,'x_all:',x_all
            !        print *,'fina:',fina
            !        print *,'cola:',cola 
            !        print *,'ndglno:',ndglno
            !        print *,'ele_type, ndim, totele,nloc, ncola,nonods:', &
            !                 ele_type, ndim, totele,nloc, ncola,nonods
            !        print *,'n:',n
            !        print *,'nlx:',nlx
            ! obtain 
            ! for filters...
                    a=0.0
                    b=0.0 
                    ml=0.0
                    do ele = 1, totele ! VOLUME integral
                         x_loc(:,:) = x_all(:,(ele-1)*nloc+1:ele*nloc)
                         call det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, INV_JAC )
            !             print *,'nx, detwei, weight:',nx, detwei, weight
            !
                         ugi=0.0
                         kgi=0.0
                         sgi=0.0
                         siggi=0.0
                         do iloc=1,nloc
                            nodi=ndglno((ele-1)*nloc+iloc) 
                            do idim=1,ndim
                               ugi(:,idim) = ugi(:,idim) + n(:,iloc)*u(idim,nodi)
                               kgi(:,idim) = kgi(:,idim) + n(:,iloc)*k(idim,nodi)
                            end do
                            sgi(:) = sgi(:) + n(:,iloc)*s(nodi)
                            siggi(:) = siggi(:) + n(:,iloc)*sig(nodi)
                         end do
            
                         do iloc=1,nloc
                         nodi=ndglno((ele-1)*nloc+iloc) 
                         b(nodi)=b(nodi)+sum( n(:,iloc)*detwei(:)*sgi(:) )
                         ml(nodi)=ml(nodi)+sum( n(:,iloc)*detwei(:) )
                         do jloc=1,nloc
                               nodj=ndglno((ele-1)*nloc+jloc) 
                               nxnx_k=0.0
                               nnx_u=0.0
                               do idim=1,ndim
                                  nxnx_k = nxnx_k + sum( nx(:,idim,iloc)*kgi(:,idim)*nx(:,idim,jloc)*detwei(:) )
                                  nnx_u = nnx_u + sum( n(:,iloc)*ugi(:,idim)*nx(:,idim,jloc)*detwei(:) )
                               end do
                               nnsig = sum( n(:,iloc)*siggi(:)*n(:,jloc)*detwei(:) )
                               aa=nxnx_k + nnx_u + nnsig
            !                   do idim=1,1
            !                      nxnx(iloc,jloc) = nxnx(iloc,jloc) + sum( nx(:,idim,iloc)*nx(:,idim,jloc)*detwei(:) )
            !                   end do
            !                   print *,'ugi:',ugi
            !                   print *,'aa, nxnx_k, nnx_u, nnsig:',aa, nxnx_k, nnx_u, nnsig
                               do count=fina(nodi),fina(nodi+1)-1
                                  if(cola(count)==nodj) a(count) = a(count) + aa
                               end do
                         end do
                         end do
                    end do
            ! Boyang tweak for bc. ************
                    if(.false.) then
                    if(k(1,1)>0.5) then
                      allocate( lmark(nonods) ) 
                      lmark(:)=.false.
                      max_x2=maxval(x_all(2,:))
                      do nodi=1,nonods
                         if(abs(x_all(2,nodi)-max_x2).lt.1.e-3) then
                           lmark(nodi)=.true.
                         endif
                      end do
                      if(.true.) then ! just take away off digonal terms...
                        do nodi=1,nonods
                           do count=fina(nodi),fina(nodi+1)-1
                              nodj=cola(count)
                              if(nodi.ne.nodj) then ! off diagonal terms...
                                 if(lmark(nodi).or.lmark(nodj)) a(count)=0.0
                              endif
                           end do
                         end do
                      else ! original method...
                        do nodi=1,nonods
                           if(abs(x_all(2,nodi)-max_x2).lt.1.e-3) then
                               do count=fina(nodi),fina(nodi+1)-1 ! change the diagonal...
                                  if(cola(count)==nodi) a(count) = a(count)*4.0
                               end do
                            endif
                         end do
                      endif
                    endif
                    endif
            ! Boyang tweak for bc. ************
            ! 
                    return
                    end subroutine get_fe_matrix_eqn
            ! 
            
            
            !subroutine det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, jac )
               subroutine det_nlx( x_loc, n, nlx, nx, detwei, weight, ndim, nloc, ngi, INV_JAC )
              ! ****************************************************
              ! This sub form the derivatives of the shape functions
              ! ****************************************************
              ! x_loc: spatial nodes.
              ! n, nlx, nlx_lxx: shape function and local derivatives of the shape functions (nlx_lxx is local grad of the local laplacian)- defined by shape functional library.
              ! nx, nx_lxx: derivatives of the shape functions.
              ! detwei, inv_jac: determinant at the quadrature pots and inverse of Jacobian at quadrature pts.
              ! ndim,nloc,ngi: no of dimensions, no of local nodes within an element, no of quadrature points.
              ! nlx_nod, nx_nod: same as nlx and nx but formed at the nodes not quadrature points.
              implicit none
              integer, intent( in ) :: ndim,nloc,ngi
            
              REAL, DIMENSION( ndim,nloc ), intent( in ) :: x_loc
              REAL, DIMENSION( ngi, nloc ), intent( in ) :: N
              REAL, DIMENSION( ngi, ndim, nloc ), intent( in ) :: nlx
              REAL, DIMENSION( ngi ), intent( in ) :: WEIGHT
              REAL, DIMENSION( ngi ), intent( inout ) :: DETWEI
              REAL, DIMENSION( ngi, ndim, nloc ), intent( inout ) :: nx
              REAL, DIMENSION( ngi, ndim, ndim ), intent( inout ):: INV_JAC
              ! Local variables
              REAL :: AGI, BGI, CGI, DGI, EGI, FGI, GGI, HGI, KGI, A11, A12, A13, A21, &
                      A22, A23, A31, A32, A33, DETJ
              INTEGER :: GI, L, IGLX, ii
            
              if (ndim==2) then
               ! conventional:
                do  GI=1,NGI! Was loop 331
            
                  AGI=0.
                  BGI=0.
            
                  CGI=0.
                  DGI=0.
            
                  do  L=1,NLOC! Was loop 79
            
                    AGI=AGI+NLX(GI,1,L)*x_loc(1,L)
                    BGI=BGI+NLX(GI,1,L)*x_loc(2,L)
            
                    CGI=CGI+NLX(GI,2,L)*x_loc(1,L)
                    DGI=DGI+NLX(GI,2,L)*x_loc(2,L)
            
                  end do ! Was loop 79
            
                  DETJ= AGI*DGI-BGI*CGI
                  DETWEI(GI)=ABS(DETJ)*WEIGHT(GI)
                  ! For coefficient in the inverse mat of the jacobian.
                  A11= DGI /DETJ
                  A21=-BGI /DETJ
            
                  A12=-CGI /DETJ
                  A22= AGI /DETJ
            
                  INV_JAC( GI, 1,1 )= A11
                  INV_JAC( GI, 1,2 )= A21
            
                  INV_JAC( GI, 2,1 )= A12
                  INV_JAC( GI, 2,2 )= A22
            
                  if(.false.) then
                  do L=1,NLOC! Was loop 373
                    NX(GI,1,L)= A11*NLX(GI,1,L)+A12*NLX(GI,2,L)
                    NX(GI,2,L)= A21*NLX(GI,1,L)+A22*NLX(GI,2,L)
                  end do ! Was loop 373
                  else
                      do L=1,NLOC
                    NX(GI,1,L)= (DGI*NLX(GI,1,L) -BGI*NLX(GI,2,L))/DETJ
                    NX(GI,2,L)= (-CGI*NLX(GI,1,L)+AGI*NLX(GI,2,L))/DETJ
            !             NX(L,GI)=(DGI*NLX(L,GI)-BGI*NLY(L,GI))/DETJ
            !             NY(L,GI)=(-CGI*NLX(L,GI)+AGI*NLY(L,GI))/DETJ
                         !               NZ(L,GI)=0.0
                      END DO
                  endif
                end do ! GI Was loop 331
            
                !jac(1) = AGI; jac(2) = DGI ; jac(3) = BGI ; jac(4) = EGI
            
              elseif ( ndim.eq.3 ) then
                do  GI=1,NGI! Was loop 331
            
                  AGI=0.
                  BGI=0.
                  CGI=0.
            
                  DGI=0.
                  EGI=0.
                  FGI=0.
            
                  GGI=0.
                  HGI=0.
                  KGI=0.
            
                  do  L=1,NLOC! Was loop 79
                    IGLX=L
                    !ewrite(3,*)'xndgln, x, nl:', &
                    !     iglx, l, x(iglx), y(iglx), z(iglx), NLX(L,GI), NLY(L,GI), NLZ(L,GI)
                    ! NB R0 does not appear here although the z-coord might be Z+R0.
                    AGI=AGI+NLX(GI,1,L)*x_loc(1,IGLX)
                    BGI=BGI+NLX(GI,1,L)*x_loc(2,IGLX)
                    CGI=CGI+NLX(GI,1,L)*x_loc(3,IGLX)
            
                    DGI=DGI+NLX(GI,2,L)*x_loc(1,IGLX)
                    EGI=EGI+NLX(GI,2,L)*x_loc(2,IGLX)
                    FGI=FGI+NLX(GI,2,L)*x_loc(3,IGLX)
            
                    GGI=GGI+NLX(GI,3,L)*x_loc(1,IGLX)
                    HGI=HGI+NLX(GI,3,L)*x_loc(2,IGLX)
                    KGI=KGI+NLX(GI,3,L)*x_loc(3,IGLX)
                  end do ! Was loop 79
            
                  DETJ=AGI*(EGI*KGI-FGI*HGI)&
                      -BGI*(DGI*KGI-FGI*GGI)&
                      +CGI*(DGI*HGI-EGI*GGI)
                  DETWEI(GI)=ABS(DETJ)*WEIGHT(GI)
                  ! ewrite(3,*)'gi, detj, weight(gi)', gi, detj, weight(gi)
                  ! rsum = rsum + detj
                  ! rsumabs = rsumabs + abs( detj )
                  ! For coefficient in the inverse mat of the jacobian.
                  A11= (EGI*KGI-FGI*HGI) /DETJ
                  A21=-(DGI*KGI-FGI*GGI) /DETJ
                  A31= (DGI*HGI-EGI*GGI) /DETJ
            
                  A12=-(BGI*KGI-CGI*HGI) /DETJ
                  A22= (AGI*KGI-CGI*GGI) /DETJ
                  A32=-(AGI*HGI-BGI*GGI) /DETJ
            
                  A13= (BGI*FGI-CGI*EGI) /DETJ
                  A23=-(AGI*FGI-CGI*DGI) /DETJ
                  A33= (AGI*EGI-BGI*DGI) /DETJ
            
                  INV_JAC( GI, 1,1 )= A11
                  INV_JAC( GI, 2,1 )= A21
                  INV_JAC( GI, 3,1 )= A31
                      !
                  INV_JAC( GI, 1,2 )= A12
                  INV_JAC( GI, 2,2 )= A22
                  INV_JAC( GI, 3,2 )= A32
                      !
                  INV_JAC( GI, 1,3 )= A13
                  INV_JAC( GI, 2,3 )= A23
                  INV_JAC( GI, 3,3 )= A33
            
                  do  L=1,NLOC! Was loop 373
                    NX(GI,1,L)= A11*NLX(GI,1,L)+A12*NLX(GI,2,L)+A13*NLX(GI,3,L)
                    NX(GI,2,L)= A21*NLX(GI,1,L)+A22*NLX(GI,2,L)+A23*NLX(GI,3,L)
                    NX(GI,3,L)= A31*NLX(GI,1,L)+A32*NLX(GI,2,L)+A33*NLX(GI,3,L)
                  end do ! Was loop 373
                end do ! GI Was loop 331
              end if
                end subroutine det_nlx
            
            
            
            
              SUBROUTINE det_snlx_all( SNLOC, SNGI, SNDIM, ndim, XSL_ALL, SN, SNLX, &
                                       SWEIGH, SDETWE, SAREA, NORMXN_ALL, NORMX_ALL )
            !       inv_jac )
                IMPLICIT NONE
            
                INTEGER, intent( in ) :: SNLOC, SNGI, SNDIM, ndim
                REAL, DIMENSION( NDIM, SNLOC ), intent( in ) :: XSL_ALL
                REAL, DIMENSION( SNGI, SNLOC ), intent( in ) :: SN
                REAL, DIMENSION( SNGI, SNDIM, SNLOC ), intent( in ) :: SNLX
                REAL, DIMENSION( SNGI ), intent( in ) :: SWEIGH
                REAL, DIMENSION( SNGI ), intent( inout ) :: SDETWE
                REAL, intent( inout ) ::  SAREA
                REAL, DIMENSION( sngi, NDIM ), intent( inout ) :: NORMXN_ALL
                REAL, DIMENSION( NDIM ), intent( in ) :: NORMX_ALL
            !    REAL, DIMENSION( NDIM,ndim ), intent( in ) :: inv_jac
                ! Local variables
                INTEGER :: GI, SL, IGLX
                REAL :: DXDLX, DXDLY, DYDLX, DYDLY, DZDLX, DZDLY
                REAL :: A, B, C, DETJ, RUB3, RUB4
            
                SAREA=0.
                if(ndim==3) then
            
                   DO GI=1,SNGI
            
                      DXDLX=0.
                      DXDLY=0.
                      DYDLX=0.
                      DYDLY=0.
                      DZDLX=0.
                      DZDLY=0.
            
                      DO SL=1,SNLOC
                         DXDLX=DXDLX + SNLX(GI,1,SL)*XSL_ALL(1,SL)
                         DXDLY=DXDLY + SNLX(GI,2,SL)*XSL_ALL(1,SL)
                         DYDLX=DYDLX + SNLX(GI,1,SL)*XSL_ALL(2,SL)
                         DYDLY=DYDLY + SNLX(GI,2,SL)*XSL_ALL(2,SL)
                         DZDLX=DZDLX + SNLX(GI,1,SL)*XSL_ALL(3,SL)
                         DZDLY=DZDLY + SNLX(GI,2,SL)*XSL_ALL(3,SL)
                      END DO
                      A = DYDLX*DZDLY - DYDLY*DZDLX
                      B = DXDLX*DZDLY - DXDLY*DZDLX
                      C = DXDLX*DYDLY - DXDLY*DYDLX
            
                      DETJ=SQRT( A**2 + B**2 + C**2)
            !          inv_jac(1,1)=DXDLX; inv_jac(1,2)=DXDLY; inv_jac(1,3)=DXDLZ
            !          inv_jac(2,1)=DyDLX; inv_jac(2,2)=DyDLY; inv_jac(2,3)=DyDLZ
            !          inv_jac(3,1)=DzDLX; inv_jac(3,2)=DzDLY; inv_jac(3,3)=DzDLZ
            !          inv_jac=inv_jac/detj 
                      SDETWE(GI)=DETJ*SWEIGH(GI)
                      SAREA=SAREA+SDETWE(GI)
            
                      ! Calculate the normal at the Gauss pts...
                      ! Perform x-product. N=T1 x T2
                      CALL NORMGI(NORMXN_ALL(GI,1),NORMXN_ALL(GI,2),NORMXN_ALL(GI,3), &
                           DXDLX,DYDLX,DZDLX, DXDLY,DYDLY,DZDLY, &
                           NORMX_ALL(1),NORMX_ALL(2),NORMX_ALL(3))
                   END DO
                else ! 2D...
                   DO GI=1,SNGI
                      DXDLX=0.
                      DXDLY=0.
                      DYDLX=0.
                      DYDLY=0.
                      DZDLX=0.
                      ! DZDLY=1 is to calculate the normal.
                      DZDLY=1.
                      DO SL=1,SNLOC
                         DXDLX=DXDLX + SNLX(GI,1,SL)*XSL_ALL(1,SL)
                         DYDLX=DYDLX + SNLX(GI,1,SL)*XSL_ALL(2,SL)
                      END DO
                      DETJ=SQRT( DXDLX**2 + DYDLX**2 )
                      SDETWE(GI)=DETJ*SWEIGH(GI)
                      SAREA=SAREA+SDETWE(GI)
                      RUB3=0.0
                      RUB4=0.0
                      CALL NORMGI(NORMXN_ALL(GI,1),NORMXN_ALL(GI,2),RUB3, &
                           DXDLX,DYDLX,DZDLX, DXDLY,DYDLY,DZDLY, &
                           NORMX_ALL(1),NORMX_ALL(2),RUB4)
                   END DO
            !       print *,'XSL_ALL:',XSL_ALL
            !       print *,'SNLX:',snlx
                endif
            
                RETURN
            
              END SUBROUTINE det_snlx_all
            
            
            
              SUBROUTINE NORMGI( NORMXN, NORMYN, NORMZN, &
                   DXDLX, DYDLX, DZDLX, DXDLY, DYDLY, DZDLY, &
                   NORMX, NORMY, NORMZ)
                ! Calculate the normal at the Gauss pts
                ! Perform x-product. N=T1 x T2
                implicit none
                REAL, intent( inout ) :: NORMXN, NORMYN, NORMZN
                REAL, intent( in )    :: DXDLX, DYDLX, DZDLX, DXDLY, DYDLY, DZDLY
                REAL, intent( in )    :: NORMX, NORMY, NORMZ
                ! Local variables
                REAL :: RN, SIRN
            
                CALL XPROD1( NORMXN, NORMYN, NORMZN, &
                     DXDLX, DYDLX, DZDLX, &
                     DXDLY, DYDLY, DZDLY )
            
                RN = SQRT( NORMXN**2 + NORMYN**2 + NORMZN**2 )
            
                SIRN = SIGN( 1.0 / RN, NORMXN * NORMX + NORMYN * NORMY + NORMZN * NORMZ )
            
                NORMXN = SIRN * NORMXN
                NORMYN = SIRN * NORMYN
                NORMZN = SIRN * NORMZN
            
                RETURN
            
              END SUBROUTINE NORMGI
            
            
            
              SUBROUTINE XPROD1( AX, AY, AZ, &
                   BX, BY, BZ, &
                   CX, CY, CZ )
                implicit none
                REAL, intent( inout ) :: AX, AY, AZ
                REAL, intent( in )    :: BX, BY, BZ, CX, CY, CZ
            
                ! Perform x-product. a=b x c
                AX =    BY * CZ - BZ * CY
                AY = -( BX * CZ - BZ * CX )
                AZ =    BX * CY - BY * CX
            
                RETURN
              END subroutine XPROD1
            
            
            
            
                     subroutine get_shape_funs_spec(n, nlx, nlx_lxx, nlxx, weight, nlx_nod, &
                      nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, face_sn, face_sn2, face_snlx, face_sweigh, &
                      npoly, ele_type ) 
                    implicit none 
            ! nloc=no of local nodes per element
            ! ngi=no of quadrature points 
            ! ndim=no of dimensions. 
                    integer, intent(in) :: nloc, snloc, sngi, ngi, ndim, nface, max_face_list_no
            ! shape functions....
            ! if .not.got_shape_funs then get the shape functions else assume we have them already
            ! n, nlx are the volume shape functions and their derivatives in local coordinates.
            ! weight are the weights of the quadrature points.
            ! nlx_nod are the derivatives of the local coordinates at the nods. 
            ! nlx_lxx = the 3rd order local derivatives at the nodes. 
            ! face info:
            ! face_ele(iface, ele) = given the face no iface and element no return the element next to 
            ! the surface or if negative return the negative of the surface element number between element ele and face iface.
            ! face_list_no(iface, ele) returns the possible origantation number which defines the numbering 
            ! of the non-zeros of the nabouting element.  
                    real, intent(inout) :: n(ngi,nloc), nlx(ngi,ndim,nloc), nlxx(ngi,nloc), nlx_lxx(ngi,ndim,nloc), weight(ngi)
                    real, intent(inout) :: nlx_nod(nloc,ndim,nloc)
                    real, intent(inout) :: face_sn(sngi,snloc,nface), face_sn2(sngi,snloc,max_face_list_no)
                    real, intent(inout) :: face_snlx(sngi,ndim,snloc,nface), face_sweigh(sngi,nface) 
            ! npoly=order of polynomial in Cartesian space; ele_type=type of element including order of poly. 
                    integer, intent(in) :: npoly,ele_type
            
            ! form the shape functions...
                    call get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                      
            ! Calculate high order derivatives of shape functions nlx_lxx, nlxx 
            ! and also calculate node-wise deriavtives of shape functions nlx_nod. 
                    call get_high_order_shape_funs(n, nlx, nlx_lxx, nlxx, &
                           weight, nlx_nod, nloc, ngi, ndim, &
                           npoly, ele_type) 
            
                    end subroutine get_shape_funs_spec
            
            
            
            
                    subroutine get_high_order_shape_funs(n, nlx, nlx_lxx, nlxx, &
                           weight, nlx_nod, nloc, ngi, ndim, &
                           npoly, ele_type) 
            ! ********************************************************************
            ! Calculate high order derivatives of shape functions nlx_lxx, nlxx 
            ! and also calculate node-wise deriavtives of shape functions nlx_nod. 
            ! ********************************************************************
                    implicit none 
            ! nloc=no of local nodes per element
            ! ngi=no of quadrature points 
            ! ndim=no of dimensions. 
                    integer, intent(in) :: nloc, ngi, ndim, npoly, ele_type
            ! shape functions....
            ! if .not.got_shape_funs then get the shape functions else assume we have them already
            ! n, nlx are the volume shape functions and their derivatives in local coordinates.
            ! weight are the weights of the quadrature points.
            ! nlx_nod are the derivatives of the local coordinates at the nods. 
            ! nlx_lxx = the 3rd order local derivatives in local coords.
            ! nlxx = the 2rd order local derivatives or Laplacian in local coords. 
                    real, intent(in) :: n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi)
                    real, intent(inout) :: nlx_lxx(ngi,ndim,nloc),  nlxx(ngi,nloc)
                    real, intent(inout) :: nlx_nod(nloc,ndim,nloc)
            ! local variables...
                    integer iloc,jloc,idim
                    real, allocatable :: nn(:,:), nn_inv(:,:), nnlx(:,:,:) 
                    real, allocatable :: mat(:,:),mat2(:,:), x(:),b(:) 
                    real, allocatable :: vec(:),sol(:),rhs_nod_lxx(:)
                    
                    allocate(nn(nloc,nloc), nn_inv(nloc,nloc), nnlx(nloc,nloc,ndim) )
                    allocate(mat(nloc,nloc),mat2(nloc,nloc), x(nloc),b(nloc) )
                    allocate(vec(nloc),sol(nloc),rhs_nod_lxx(nloc))
            
            ! Calculate high order derivatives of shape functions nlx_lxx, nlxx 
            ! and also calculate node-wise deriavtives of shape functions nlx_nod: 
            
            ! Calculate nodal values of nlx, that is nlx_nod:
            ! form nn
                    do iloc=1,nloc
                       do jloc=1,nloc
                          nn(iloc,jloc)= sum( n(:,iloc)*n(:,jloc)*weight(:) )
                          do idim=1,ndim
                             nnlx(iloc,jloc,idim)= sum( n(:,iloc)*nlx(:,idim,jloc)*weight(:) )
                          end do
                       end do
                    end do
            ! find nn_inv as its easy to manipulate then although not efficient.
                    nn_inv=nn
                    call matinv(nn_inv,nloc,nloc,MAT,MAT2,X,B)
            
            ! Form nlx_nod
                    do iloc=1,nloc
                    do idim=1,ndim
                       vec(:) = nnlx(iloc,:,idim)
                       nlx_nod(iloc,idim,:) = matmul( nn_inv(:,:), vec(:) )
                    end do
                    end do
            
            ! Form nlxx from nlx_nod...
                    nlxx=0.0
                    do iloc=1,nloc
                       do idim=1,ndim
                          vec(:) = sum( nnlx(iloc,:,idim)*nlx_nod(iloc,idim,:) )
                          sol(:) = matmul( nn_inv(:,:), vec(:) )
                          nlxx(iloc,:) = nlxx(iloc,:) +sol(:) 
                       end do
                    end do
            
            ! Form nlx_lxx: 
                    do iloc=1,nloc
                       rhs_nod_lxx(:)=nlxx(iloc,:)
                       do idim=1,ndim
                          nlx_lxx(:,idim,iloc) = nlx(:,idim,iloc)*rhs_nod_lxx(:) 
                       end do
                    end do
                      
                    end subroutine get_high_order_shape_funs
            
                 
            
            
            
                    subroutine get_shape_funs_with_faces(n, nlx, weight,  &
                           nloc, snloc, sngi, ngi, ndim, nface,max_face_list_no, &
                           face_sn, face_sn2, face_snlx, face_sweigh, &
                           npoly,ele_type) 
                    implicit none 
            ! nloc=no of local nodes per element
            ! ngi=no of quadrature points 
            ! ndim=no of dimensions. 
            ! ele_type= element type
                    integer, intent(in) :: nloc, snloc, sngi, ngi, ndim, nface, max_face_list_no
            ! shape functions....
            ! if .not.got_shape_funs then get the shape functions else assume we have them already
            ! n, nlx are the volume shape functions and their derivatives in local coordinates.
            ! weight are the weights of the quadrature points.
            ! nlx_nod are the derivatives of the local coordinates at the nods. 
            ! nlx_lxx = the 3rd order local derivatives at the nodes. 
            ! face info:
            ! face_ele(iface, ele) = given the face no iface and element no return the element next to 
            ! the surface or if negative return the negative of the surface element number between element ele and face iface.
            ! face_list_no(iface, ele) returns the possible origantation number which defines the numbering 
            ! of the non-zeros of the nabouting element.  
                    real, intent(inout) :: n(ngi,nloc), nlx(ngi,ndim,nloc), weight(ngi)
                    real, intent(inout) :: face_sn(sngi,snloc,nface)
                    real, intent(inout) :: face_sn2(sngi,snloc,max_face_list_no)
                    real, intent(inout) :: face_snlx(sngi,ndim-1,snloc,nface)
                    real, intent(inout) :: face_sweigh(sngi,nface) 
            ! npoly=order of polynomial in Cartesian space; ele_type=type of element including order of poly. 
                    integer, intent(in) :: npoly, ele_type
            ! local variables...
                    integer is_triangle_or_tet
                    parameter(is_triangle_or_tet=100) 
                    integer sndim, suf_ngi, suf_ndim, suf_nloc, ipoly, IQADRA, iface
                    integer idim,siloc
                    logical with_time_slab
                    real, allocatable :: rdum1(:), rdum2(:), rdum3(:) 
                    real, allocatable :: sn(:,:),sn2(:,:),snlx(:,:,:),sweight(:) 
                    real, allocatable :: suf_n(:,:),suf_nlx(:,:,:),suf_weight(:)
            
            ! allocate memory...
                    print *,'just about to allocate'
                    print *,'nloc, sngi, ngi, ndim, nface,max_face_list_no:', &
                             nloc, sngi, ngi, ndim, nface,max_face_list_no
                    print *,'npoly,ele_type:',npoly,ele_type
                    allocate(rdum1(10000), rdum2(10000), rdum3(10000) )
                    print *,'here 1'
                    allocate(sn(sngi,snloc),sn2(sngi,snloc),snlx(sngi,ndim-1,snloc),sweight(sngi) )
                    print *,'here 2'
                    allocate(suf_n(sngi,snloc),suf_nlx(sngi,ndim-1,snloc),suf_weight(sngi) )
                    print *,'here 3'
            
                    ipoly=npoly
            !        IQADRA=IPOLY+1
                    IQADRA=1
            
                    sndim=ndim-1
                    if(ele_type < is_triangle_or_tet) then ! not triangle...
            ! 
                       with_time_slab=.true.
                if( ((nloc==3).or.(nloc==6).or.(nloc==10).or.(nloc==15)) .and.(ndim==2)) then
                   with_time_slab= .false. 
                endif
                if( ((nloc==4).or.(nloc==10).or.(nloc==20).or.(nloc==35)) .and.(ndim==3)) then
                   with_time_slab= .false. 
                endif
            
                       print *,'get_shape_funs'
                       call get_shape_funs(ngi,nloc,ndim,  &
                         weight,n,nlx, ipoly,iqadra, &
                         sngi, snloc, sndim, sweight,sn,snlx, with_time_slab   )
                       print *,'finished get_shape_funs'
                       print *,'sn:',sn
                       print *,'snlx:',snlx
                       print *,'sweight:',sweight
                             do siloc=1,snloc 
                                do idim=1,ndim-1
                   print *,'snlx(:,idim,siloc):',idim,siloc,snlx(:,idim,siloc)
                                end do
                             end do
                       do iface=1,nface
                         face_sn(:,:,iface) = sn(:,:) 
                         face_snlx(:,:,:,iface) = snlx(:,:,:) 
                         face_sweigh(:,iface) = sweight(:) 
                       end do
                       face_sn2(:,:,1:max_face_list_no) = face_sn(:,:,1:max_face_list_no) 
            
                    else 
            !           allocate(rdum1(10000),rdum2(10000),rdum3(10000))
            ! gives a surface triangle with time slab in surface integral. 
                       print *,'going into get_shape_funs ***is a triangle or tet'
                       call get_shape_funs(ngi,nloc,ndim,  &
                          weight,n,nlx, ipoly,iqadra, &
                          sngi, snloc, sndim, sweight,sn,snlx, .false.   )
                       print *,'out of get_shape_funs'
            ! return a surface tet...
                       suf_ngi=NGI/IQADRA
                       suf_ndim=ndim-1
                       suf_nloc=NLOC/(IPOLY+1)
                       call get_shape_funs(suf_ngi,suf_nloc,suf_ndim,  &
                          suf_weight,suf_n,suf_nlx, ipoly,iqadra, &
                          sngi, snloc, sndim, rdum1,rdum2,rdum3, .false.   )
            
                    endif
            
                    end subroutine get_shape_funs_with_faces
                 
            
            
            
                   subroutine get_shape_funs(ngi,nloc,ndim,  &
                         weight,n,nlx, ipoly,iqadra, &
                         sngi, snloc, sndim, sweight,sn,snlx, with_time_slab   )
            ! ***************************************
            ! form volume and surface shape functions
            ! ***************************************
                IMPLICIT NONE
                INTEGER, intent(in) :: sngi, NGI, NLOC, snloc, ndim, sndim
                INTEGER, intent(in) :: IPOLY,IQADRA
                logical, intent(in) :: with_time_slab
                REAL, intent(inout) ::  n(ngi,nloc) 
                REAL, intent(inout) ::  nlx(ngi,ndim,nloc)
                REAL, intent(inout) ::  sn(sngi, snloc) 
                REAL, intent(inout) ::  snlx(sngi, sndim, snloc)  
                real, intent(inout) :: WEIGHT(ngi), sWEIGHT(sngi)
            ! local variables...
                integer mloc, NDNOD, snloc_temp, idim,siloc
                logical square
                real, allocatable :: m(:)
            
                allocate(m(10000)) 
                mloc=1
                SQUARE = .true. 
                if( ((nloc==3).or.(nloc==6).or.(nloc==10).or.(nloc==15)) .and.(ndim==2)) then
                   SQUARE = .false. 
                endif
                if( ((nloc==4).or.(nloc==10).or.(nloc==20).or.(nloc==35)) .and.(ndim==3)) then
                   SQUARE = .false. 
                endif
                 print *,'++++++square=',square
            
                IF(SQUARE) THEN ! Square in up to 4D
            ! volumes
            !       print *,'going into interface_SPECTR NGI,NLOC,ndim:',NGI,NLOC,ndim
                   call interface_SPECTR(NGI,NLOC,WEIGHT,N,NLX, ndim, IPOLY,IQADRA  )
            !       print *,'out of interface_SPECTR'
            ! surfaces...
                   NDNOD =INT((NLOC**(1./real(ndim) ))+0.1)
                   snloc_temp=NDNOD**(ndim-1) 
                   sWEIGHT=0.0; sN=0.0; sNLX=0.0
            !       print *,'surfaces going into interface_SPECTR'
                   call interface_SPECTR(sNGI,sNLOC_temp,sWEIGHT,sN,sNLX, ndim-1, IPOLY,IQADRA  )
            !       print *,'surfaces out of interface_SPECTR'
                    print *,'sNGI,sNLOC_temp,ndim,IPOLY,IQADRA:', &
                             sNGI,sNLOC_temp,ndim,IPOLY,IQADRA
                             do siloc=1,snloc 
                                do idim=1,sndim
                   print *,'snlx(:,idim,siloc):',idim,siloc,snlx(:,idim,siloc)
                                end do
                             end do
                    print *,'sWEIGHT:',sWEIGHT
                    print *,'sndim:',sndim
                   
                ELSE
            ! volume tet plus time slab...
            !       print *,'triangles or tets ipoly,iqadra, with_time_slab:',ipoly,iqadra, with_time_slab
            !       if(.true.) then
            !       else
                   call triangles_tets_with_time( nloc,ngi, ndim, &
                           n,nlx, weight, ipoly,iqadra, with_time_slab) 
            ! surfaces...
            !       print *,'surfaces -tets or triangles...'
                   call triangles_tets_with_time( snloc,sngi, ndim-1, &
                          sn,snlx, sweight, ipoly,iqadra, with_time_slab) 
            !       endif 
                ENDIF
                 return
                 end subroutine get_shape_funs
            
            
            
            
                 subroutine triangles_tets_with_time( nloc,ngi, ndim, &
                              n,nlx, weight, ipoly,iqadra, with_time_slab) 
            ! ****************************************************************************************
                 implicit none
                 integer, intent(in) :: nloc,ngi,ndim, ipoly,iqadra
                 real, intent(inout) :: n(ngi,nloc), nlx(ngi,ndim,nloc) 
                 real, intent(inout) :: weight(ngi)
                 logical, intent(in) :: with_time_slab
            ! local variables...
                 integer nloc_space, ngi_space, ndim_space,   nloc_t, ngi_t, ndim_t
                 logical d3
                 real, allocatable :: l1(:), l2(:), l3(:), l4(:)
                 real, allocatable :: weight_space(:), n_space(:,:), nlx_space(:,:,:)
                 real, allocatable :: weight_t(:), n_t(:,:), nlx_t(:,:,:)
            
                 if(with_time_slab) then ! form a space-time slab.
            
                    nloc_t=nloc/(ipoly+1)
                    NGI_T=IQADRA
            !        ngi_t=ngi/(ipoly+2)
                    ndim_t = 1
            
                    nloc_space=nloc/nloc_t 
                    ngi_space=ngi/ngi_t
                    ndim_space = ndim-1
                    allocate(l1(ngi_space), l2(ngi_space), l3(ngi_space), l4(ngi_space) )
                    allocate(weight_space(ngi_space), n_space(ngi_space,nloc_space), &
                             nlx_space(ngi_space,ndim_space,nloc_space) )
            
                    allocate(weight_t(ngi_t), n_t(ngi_t,nloc_t), nlx_t(ngi_t,ndim_t,nloc_t) )
            
            ! triangles or tetrahedra...
                    call SHATRInew(L1, L2, L3, L4, WEIGHT_space, &
                      NLOC_space,NGI_space,ndim_space,  n_space,nlx_space)
            
            ! extend into time domain...
                    call interface_SPECTR(NGI_t,NLOC_t,WEIGHT_t,N_t,NLX_t, &
                                          ndim_t, IPOLY,IQADRA  )
            
            ! combine-space time...
                    call make_space_time_shape_funs(nloc_space,ngi_space, ndim_space, &
                                                 n_space,nlx_space, weight_space, &
                                                 nloc_t,ngi_t, ndim_t, n_t, nlx_t, weight_t, &
                                                 nloc,ngi, ndim, n, nlx, weight ) 
                 else ! just a triangle or tet without time slab...
            ! triangles or tetrahedra...
                    allocate(l1(ngi), l2(ngi), l3(ngi), l4(ngi) ) 
            !        stop 22221
              !
                    d3=(ndim==3)
                    call TRIQUAold(L1, L2, L3, L4, WEIGHT, D3,NGI)
            
            !        print *,'d3,nloc,ngi,ndim:',d3,nloc,ngi,ndim
            !        print *,'l1,l2,l3:',l1,l2,l3
            !        print *,'weight:',weight
                    call SHATRInew(L1, L2, L3, L4, weight, &
                      nloc,ngi,ndim,  n,nlx)
            !        print *,'n:',n
            !        stop 282
                 endif
            
                 end subroutine triangles_tets_with_time
              ! 
            
            
            
                 subroutine make_space_time_shape_funs(nloc_space,ngi_space, ndim_space, &
                                                       n_space,nlx_space, weight_space, &
                                                       nloc_t,ngi_t, ndim_t, n_t, nlx_t, weight_t, &
                                                       nloc,ngi, ndim, n, nlx, weight ) 
            ! ****************************************************************************************
            ! this sub convolves the space and time shape functions to get space-time shape functions. 
            ! these are returned in n, nlx where nloc=no of local nodes and ngi =no of quadrature pts.
            ! ****************************************************************************************
                 implicit none
                 integer, intent(in) :: nloc_space,nloc_t, ngi_space,ngi_t, nloc,ngi, &
                                        ndim_space,ndim_t, ndim
                 real, intent(in) :: n_space(ngi_space,nloc_space),n_t(ngi_t,nloc_t)
                 real, intent(in) :: nlx_space(ngi_space,ndim_space,nloc_space), &
                                     nlx_t(ngi_t,ndim_t,nloc_t)
                 real, intent(in) :: weight_space(ngi_space), weight_t(ngi_t)
                 real, intent(inout) :: n(ngi,nloc), nlx(ngi,ndim,nloc) 
                 real, intent(inout) :: weight(ngi)
            ! local...
                 integer iloc_space, iloc_t, iloc, gi_space, gi_t, gi, &
                         idim_space, idim_t, idim 
                 
            ! remember sngi>=the needed sngi for a surface element.
            ! similarly for nloc
                 n=0.0
                 nlx=0.0 
                 weight=0.0
                 do iloc_space=1,nloc_space
                    do iloc_t=1,nloc_t
                       iloc=(iloc_t-1)*nloc_space + iloc_space
                       do gi_space=1,ngi_space
                          do gi_t=1,ngi_t
                             gi=(gi_t-1)*ngi_space + gi_space
                             n(gi,iloc) = n_space(gi_space,iloc_space)*n_t(gi_t,iloc_t) 
                             do idim_space=1,ndim_space
                                nlx(gi,idim_space,iloc) = nlx_space(gi_space,idim_space,iloc_space)*n_t(gi_t,iloc_t)
                             end do
                             idim = ndim_space+1
                             nlx(gi,idim,iloc) = n(gi_space,iloc_space)*nlx_t(gi_t,1,iloc_t)
                 end do; end do; end do; end do
            ! the weights...
                 do gi_space=1,ngi_space
                    do gi_t=1,ngi_t
                       gi=(gi_t-1)*ngi_space + gi_space
                       weight(gi) = weight_space(gi_space)*weight_t(gi_t)
                    end do
                 end do
                 end subroutine make_space_time_shape_funs
              ! 
            
            
              ! 
                   subroutine interface_SPECTR(NGI,NLOC,WEIGHT,N,NLX, ndim, IPOLY,IQADRA  )
                IMPLICIT NONE
                INTEGER , intent(in) :: NGI, NLOC, ndim
                INTEGER , intent(in) :: IPOLY,IQADRA
                REAL, dimension(ngi,nloc), intent(inout) ::  N
                REAL, dimension(ngi,ndim,nloc), intent(inout) ::  NLX   
                real, dimension(ngi), intent(inout) :: WEIGHT
            ! local variables...
                logical d2,d3,d4
                integer mloc,idim
                real, allocatable :: m(:),NLX_TEMP(:,:,:)
            
                allocate(m(10000),NLX_TEMP(NGI,4,nloc)) 
                mloc=nloc ! 1
                d2=.false.; d3=.false.; d4=.false.
                if(ndim==2) d2=.true.
                if(ndim==3) d3=.true.
                if(ndim==4) d4=.true.
            
            !    IF(SQUARE) THEN ! Square in up to 4D
            ! volumes
                   print *,'going into SPECTR'
                   call SPECTR(NGI,NLOC,MLOC, &
                   &      M,WEIGHT,N,NLX_temp(:,1,:),NLX_temp(:,2,:), &
                          NLX_temp(:,3,:),NLX_temp(:,4,:),D4,D3,D2, IPOLY,IQADRA  )
                   print *,'out of SPECTR'
            
                do idim=1,ndim
                   nlx(:,idim,:) = nlx_temp(:,idim,:) 
                end do
            
                end subroutine interface_SPECTR
            
            
            
            
              SUBROUTINE SPECTR(NGI,NLOC,MLOC, &
                          M,WEIGHT,N,NLX, & 
                          NLY,NLZ,NLT,D4,D3,D2, IPOLY,IQADRA  )
                IMPLICIT NONE
                INTEGER, intent(in) :: NGI, NLOC, MLOC
                INTEGER, intent(in) :: IPOLY,IQADRA
                REAL, dimension(ngi,nloc), intent(inout) ::  M, N, NLX, NLY, NLZ, NLT
                real, dimension(ngi), intent(inout) :: WEIGHT
                logical, intent(in) :: d2,d3,d4
                !Local variables
                REAL :: RGPTWE
                REAL , dimension (300) :: WEIT,NODPOS,QUAPOS
                INTEGER :: GPOI
                LOGICAL :: DIFF,NDIFF
                INTEGER :: NDGI,NDNOD,NMDNOD,IGR,IGQ,IGP,KNOD,JNOD,INOD,ILOC,lnod,igs
                REAL :: LXGP,LYGP,LZGP,LTGP
            ! SPECFU is a real function
                real :: SPECFU
                ! This subroutine defines a spectal element.
                ! IPOLY defines the element type and IQADRA the quadrature.
                ! In 2-D the spectral local node numbering is as..
                ! 7 8 9
                ! 4 5 6
                ! 1 2 3
                ! For 3-D...
                ! lz=-1
                ! 3 4
                ! 1 2
                ! and for lz=1
                ! 7 8
                ! 5 6
            
                !ewrite(3,*)'inside SPECTR IPOLY,IQADRA', IPOLY,IQADRA
                !
                DIFF=.TRUE.
                NDIFF=.FALSE.
                IF(D4) THEN
                   NDGI  =INT((NGI**(1./4.))+0.1)
                   NDNOD =INT((NLOC**(1./4.))+0.1)
                   NMDNOD=INT((MLOC**(1./4.))+0.1)
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   !ewrite(3,*)'about to go into inside GTROOT IPOLY,IQADRA',IPOLY,IQADRA
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NDNOD)
                   !ewrite(3,*)'outside GTROOT'
                   do  IGS=1,NDGI! Was loop 101
                   do  IGR=1,NDGI! Was loop 101
                      do  IGQ=1,NDGI! Was loop 101
                         do  IGP=1,NDGI! Was loop 101
                            GPOI=IGP + (IGQ-1)*NDGI + (IGR-1)*NDGI*NDGI + (IGS-1)*NDGI*NDGI*NDGI
                            !
                            !           WEIGHT(GPOI)
                            !     &        =RGPTWE(IGP,NDGI,.TRUE.)*RGPTWE(IGQ,NDGI,.TRUE.)
                            !     &        *RGPTWE(IGR,NDGI,.TRUE.)
                            WEIGHT(GPOI)=WEIT(IGP)*WEIT(IGQ)*WEIT(IGR)*WEIT(IGS)
                            !
                            LXGP=QUAPOS(IGP)
                            LYGP=QUAPOS(IGQ)
                            LZGP=QUAPOS(IGR)
                            LTGP=QUAPOS(IGS)
                            ! NB If TRUE in function RGPTWE then return the Gauss-pt weight
                            ! else return the Gauss-pt.
                            !
                            do  LNOD=1,NDNOD! Was loop 20
                            do  KNOD=1,NDNOD! Was loop 20
                               do  JNOD=1,NDNOD! Was loop 20
                                  do  INOD=1,NDNOD! Was loop 20
                                     ILOC=INOD + (JNOD-1)*NDNOD + (KNOD-1)*NDNOD*NDNOD + &
                                         (LNOD-1)*NDNOD*NDNOD*NDNOD
                                     !
                                     N(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LZGP,KNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LTGP,KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                     NLX(GPOI,ILOC) = &
                                          SPECFU(DIFF,LXGP, INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LZGP,KNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LTGP,KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                     NLY(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF, LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LZGP,KNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LTGP,KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                     NLZ(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF,LZGP, KNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF,LTGP, KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                     NLT(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF,LZGP, KNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF,LtGP, KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                  end do ! Was loop 20
                               end do ! Was loop 20
                            end do ! Was loop 20
                            end do ! Was loop 20
                         end do ! Was loop 101
                      end do ! Was loop 101
                   end do ! Was loop 101
                   end do ! Was loop 101
                   !
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   !ewrite(3,*)'2about to go into inside GTROOT IPOLY,IQADRA',IPOLY,IQADRA
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NMDNOD)
                   !ewrite(3,*)'2out of GTROOT'
            
                   do  IGS=1,NDGI! Was loop 102
                   do  IGR=1,NDGI! Was loop 102
                      do  IGQ=1,NDGI! Was loop 102
                         do  IGP=1,NDGI! Was loop 102
                            GPOI=IGP + (IGQ-1)*NDGI + (IGR-1)*NDGI*NDGI &
                                + (IGS-1)*NDGI*NDGI*NDGI
                            !
                            LXGP=QUAPOS(IGP)
                            LYGP=QUAPOS(IGQ)
                            LZGP=QUAPOS(IGR)
                            LTGP=QUAPOS(IGS)
            
                            do  LNOD=1,NMDNOD! Was loop 30
                            do  KNOD=1,NMDNOD! Was loop 30
                               do  JNOD=1,NMDNOD! Was loop 30
                                  do  INOD=1,NMDNOD! Was loop 30
                                     ILOC=INOD + (JNOD-1)*NMDNOD + (KNOD-1)*NMDNOD*NMDNOD &
                                         + (LNOD-1)*NMDNOD*NMDNOD*NMDNOD
                                     !
                                     M(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NMDNOD,IPOLY,NODPOS)  &
                                          *SPECFU(NDIFF,LYGP,JNOD,NMDNOD,IPOLY,NODPOS) &
                                          *SPECFU(NDIFF,LZGP,KNOD,NMDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LtGP,LNOD,NMDNOD,IPOLY,NODPOS)
                                     !
                                  end do ! Was loop 30
                               end do ! Was loop 30
                            end do ! Was loop 30
                            end do ! Was loop 30
                         end do ! Was loop 102
                      end do ! Was loop 102
                   end do ! Was loop 102
                   end do ! Was loop 102
                ENDIF ! ENDIF IF(D4) THEN
            
                IF(D3) THEN
                   NDGI  =INT((NGI**(1./3.))+0.1)
                   NDNOD =INT((NLOC**(1./3.))+0.1)
                   NMDNOD=INT((MLOC**(1./3.))+0.1)
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   !ewrite(3,*)'about to go into inside GTROOT IPOLY,IQADRA',IPOLY,IQADRA
                   print *,'volume 3d before GTROOT'
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NDNOD)
                   print *,'volume 3d after GTROOT'
                   !ewrite(3,*)'outside GTROOT'
                   do  IGR=1,NDGI! Was loop 101
                      do  IGQ=1,NDGI! Was loop 101
                         do  IGP=1,NDGI! Was loop 101
                            GPOI=IGP + (IGQ-1)*NDGI + (IGR-1)*NDGI*NDGI
                            !
                            !           WEIGHT(GPOI)
                            !     &        =RGPTWE(IGP,NDGI,.TRUE.)*RGPTWE(IGQ,NDGI,.TRUE.)
                            !     &        *RGPTWE(IGR,NDGI,.TRUE.)
                            WEIGHT(GPOI)=WEIT(IGP)*WEIT(IGQ)*WEIT(IGR)
                            !
                            LXGP=QUAPOS(IGP)
                            LYGP=QUAPOS(IGQ)
                            LZGP=QUAPOS(IGR)
                            ! NB If TRUE in function RGPTWE then return the Gauss-pt weight
                            ! else return the Gauss-pt.
                            !
                            do  KNOD=1,NDNOD! Was loop 20
                               do  JNOD=1,NDNOD! Was loop 20
                                  do  INOD=1,NDNOD! Was loop 20
                                     ILOC=INOD + (JNOD-1)*NDNOD + (KNOD-1)*NDNOD*NDNOD
                                     !
                                     N(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LZGP,KNOD,NDNOD,IPOLY,NODPOS)
            !            print *,'GPOI,iloc,N(GPOI,ILOC):',GPOI,iloc,N(GPOI,ILOC)
                                     !
                                     NLX(GPOI,ILOC) = &
                                          SPECFU(DIFF,LXGP, INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LZGP,KNOD,NDNOD,IPOLY,NODPOS)
            !            print *,'GPOI,iloc,NLX(GPOI,ILOC):',GPOI,iloc,NLX(GPOI,ILOC)
                                     !
                                     NLY(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF, LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LZGP,KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                     NLZ(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)&
                                          *SPECFU(DIFF,LZGP, KNOD,NDNOD,IPOLY,NODPOS)
                                     !
                                  end do ! Was loop 20
                               end do ! Was loop 20
                            end do ! Was loop 20
                         end do ! Was loop 101
                      end do ! Was loop 101
                   end do ! Was loop 101
                   !
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   !ewrite(3,*)'2about to go into inside GTROOT IPOLY,IQADRA',IPOLY,IQADRA
                   print *,'surface 3d before GTROOT'
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NMDNOD)
                   print *,'surface 3d after GTROOT'
                   !ewrite(3,*)'2out of GTROOT'
                   do  IGR=1,NDGI! Was loop 102
                      do  IGQ=1,NDGI! Was loop 102
                         do  IGP=1,NDGI! Was loop 102
                            GPOI=IGP + (IGQ-1)*NDGI + (IGR-1)*NDGI*NDGI
                            !
                            LXGP=QUAPOS(IGP)
                            LYGP=QUAPOS(IGQ)
                            LZGP=QUAPOS(IGR)
            
                            do  KNOD=1,NMDNOD! Was loop 30
                               do  JNOD=1,NMDNOD! Was loop 30
                                  do  INOD=1,NMDNOD! Was loop 30
                                     ILOC=INOD + (JNOD-1)*NMDNOD + (KNOD-1)*NMDNOD*NMDNOD
                                     !
                                     M(GPOI,ILOC) = &
                                          SPECFU(NDIFF,LXGP,INOD,NMDNOD,IPOLY,NODPOS)  &
                                          *SPECFU(NDIFF,LYGP,JNOD,NMDNOD,IPOLY,NODPOS) &
                                          *SPECFU(NDIFF,LZGP,KNOD,NMDNOD,IPOLY,NODPOS)
                                     !
                                  end do ! Was loop 30
                               end do ! Was loop 30
                            end do ! Was loop 30
                         end do ! Was loop 102
                      end do ! Was loop 102
                   end do ! Was loop 102
                   print *,'still 3d'
                ENDIF
                !
                IF(D2) THEN
            !       return
                   print *,'here 1.1'
                   NDGI  =INT((NGI**(1./2.))+0.1)
                   NDNOD =INT((NLOC**(1./2.))+0.1)
                   NMDNOD=INT((MLOC**(1./2.))+0.1)
                   print *,'ndgi,ndnod,nmdnod:',ndgi,ndnod,nmdnod
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   print *,'here 1.2'
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NDNOD)
                   print *,'here 1.3'
            !       return
                   do  IGQ=1,NDGI! Was loop 10
                      do  IGP=1,NDGI! Was loop 10
                         GPOI=IGP + (IGQ-1)*NDGI
                         !
                         WEIGHT(GPOI)=WEIT(IGP)*WEIT(IGQ)
                         !
                         LXGP=QUAPOS(IGP)
                         LYGP=QUAPOS(IGQ)
                         ! NB If TRUE in function RGPTWE then return the Gauss-pt weight
                         ! else return the Gauss-pt.
                         !
                         do  JNOD=1,NDNOD! Was loop 120
                            do  INOD=1,NDNOD! Was loop 120
                               ILOC=INOD + (JNOD-1)*NDNOD
                               !
                               N(GPOI,ILOC) = &
                                    SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS) &
                                    *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)
                               !
                               NLX(GPOI,ILOC) = &
                                    SPECFU(DIFF, LXGP,INOD,NDNOD,IPOLY,NODPOS) &
                                    *SPECFU(NDIFF,LYGP,JNOD,NDNOD,IPOLY,NODPOS)
                               !
                               NLY(GPOI,ILOC) = &
                                    SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS) &
                                    *SPECFU(DIFF, LYGP,JNOD,NDNOD,IPOLY,NODPOS)
                               !
                            end do ! Was loop 120
                         end do ! Was loop 120
                      end do ! Was loop 10
                   end do ! Was loop 10
                   print *,'here 1.4'
            !       return
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NMDNOD)
                   print *,'here 1.5'
                   do  IGQ=1,NDGI! Was loop 11
                      do  IGP=1,NDGI! Was loop 11
                         GPOI=IGP + (IGQ-1)*NDGI
                         LXGP=QUAPOS(IGP)
                         LYGP=QUAPOS(IGQ)
                         do  JNOD=1,NMDNOD! Was loop 130
                            do  INOD=1,NMDNOD! Was loop 130
                               ILOC=INOD + (JNOD-1)*NMDNOD
                               !
                               M(GPOI,ILOC) = &
                                    SPECFU(NDIFF,LXGP,INOD,NMDNOD,IPOLY,NODPOS) &
                                    *SPECFU(NDIFF,LYGP,JNOD,NMDNOD,IPOLY,NODPOS)
                               !
                            end do ! Was loop 130
                         end do ! Was loop 130
                         !
                      end do ! Was loop 11
                   end do ! Was loop 11
                   print *,'here 1.6 d2=',d2
                ENDIF
                !
                !
                IF((.NOT.D2).AND.(.NOT.D3).and.(.not.D4)) THEN
                   NDGI  =NGI
                   NDNOD =NLOC
                   NMDNOD=MLOC
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NDNOD)
                   !ewrite(3,*)'NDGI,NDNOD,NLOC:',NDGI,NDNOD,NLOC
                   !ewrite(3,*)'WEIT(1:ndgi):',WEIT(1:ndgi)
                   !ewrite(3,*)'NODPOS(1:ndnod):',NODPOS(1:ndnod)
                   !ewrite(3,*)'QUAPOS(1:ndgi):',QUAPOS(1:ndgi)
                   do  IGP=1,NDGI! Was loop 1000
                      GPOI=IGP
                      !
                      WEIGHT(GPOI)=WEIT(IGP)
                      !
                      LXGP=QUAPOS(IGP)
                      ! NB If TRUE in function RGPTWE then return the Gauss-pt weight
                      ! else return the Gauss-pt.
                      !
                      do  INOD=1,NDNOD! Was loop 12000
                         ILOC=INOD
                         !
                         N(GPOI,ILOC) = &
                              SPECFU(NDIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)
                         !
                         NLX(GPOI,ILOC) = &
                              SPECFU(DIFF, LXGP,INOD,NDNOD,IPOLY,NODPOS)
                         !ewrite(3,*)'ILOC,GPOI,N(GPOI,ILOC),NLX(GPOI,ILOC):', &
                         !         ILOC,GPOI,N(GPOI,ILOC),NLX(GPOI,ILOC)
                         !
                      end do ! Was loop 12000
                   end do ! Was loop 1000
                   !ewrite(3,*)'n WEIGHT:',WEIGHT
                   !
                   ! Find the roots of the quadrature points and nodes
                   ! also get the weights.
                   !ewrite(3,*)'this is for m which we dont care about:'
                   CALL GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NMDNOD)
                   do  IGP=1,NDGI! Was loop 1100
                      GPOI=IGP
                      LXGP=QUAPOS(IGP)
                      do  INOD=1,NMDNOD! Was loop 13000
                         ILOC=INOD
                         !
                         M(GPOI,ILOC) = &
                              SPECFU(NDIFF,LXGP,INOD,NMDNOD,IPOLY,NODPOS)
                         !
                      end do ! Was loop 13000
                      !
                   end do ! Was loop 1100
                   !ewrite(3,*)'...finished this is for m which we dont care about:'
                ENDIF
                print *,'just leaving spectr'
              END SUBROUTINE SPECTR
            
            
            
            
              SUBROUTINE GTROOT(IPOLY,IQADRA,WEIT,NODPOS,QUAPOS,NDGI,NDNOD)
                IMPLICIT NONE
                INTEGER , intent(in) :: IPOLY,IQADRA,NDGI,NDNOD
                REAL , dimension(NDNOD), intent(inout) :: NODPOS
                REAL , dimension(NDGI), intent(inout) :: WEIT,QUAPOS
                !Local variables
                LOGICAL :: GETNDP
                !     This sub returns the weights WEIT the quadrature points QUAPOS and
                !     the node points NODPOS.
                !     NODAL POISTIONS ******
                !     NB if GETNDP then find the nodal positions
            !    print *,'IQADRA=',IQADRA
            !    stop 38
                GETNDP=.TRUE.
                !     Compute standard Lagrange nodal points
                IF(IQADRA.EQ.1) CALL LAGROT(NODPOS,NODPOS,NDNOD,GETNDP)
                !     Compute Chebyshev-Gauss-Lobatto nodal points.
                IF(IQADRA.EQ.2) CALL CHEROT(NODPOS,NODPOS,NDNOD,GETNDP)
                IF(IQADRA.EQ.3) CALL CHEROT(NODPOS,NODPOS,NDNOD,GETNDP)
                !     Compute Legendre-Gauss-Lobatto nodal points.
                IF(IQADRA.EQ.4) CALL LEGROT(NODPOS,NODPOS,NDNOD,GETNDP)
                !
                !     QUADRATURE************
                GETNDP=.FALSE.
                !     Compute standard Gauss quadrature. weits and points
                IF(IQADRA.EQ.1) CALL LAGROT(WEIT,QUAPOS,NDGI,GETNDP)
                !     Compute Chebyshev-Gauss-Lobatto quadrature.
                IF(IQADRA.EQ.2) CALL CHEROT(WEIT,QUAPOS,NDGI,GETNDP)
                IF(IQADRA.EQ.3) CALL CHEROT(WEIT,QUAPOS,NDGI,GETNDP)
                !     Compute Legendre-Gauss-Lobatto quadrature.
                IF(IQADRA.EQ.4) CALL LEGROT(WEIT,QUAPOS,NDGI,GETNDP)
              END SUBROUTINE GTROOT
            
            
            
            
              REAL FUNCTION SPECFU(DIFF,LXGP,INOD,NDNOD,IPOLY,NODPOS)
                LOGICAL , intent(in):: DIFF
                INTEGER , intent(in) :: INOD,NDNOD,IPOLY
                REAL , intent(inout) :: LXGP
                real, dimension(NDNOD), intent(inout) :: NODPOS
                !     INOD contains the node at which the polynomial is associated with
                !     LXGP is the position at which the polynomial is to be avaluated.\
                !     If(DIFF) then find the D poly/DX.
            ! local variables (functions)
                real LAGRAN,CHEBY1,CHEBY2,LEGEND
                !
                IF(IPOLY.EQ.1) SPECFU=LAGRAN(DIFF,LXGP,INOD,NDNOD,NODPOS)
            !         print *,'ipoly,NODPOS:',ipoly,NODPOS
            !          stop 2921
                !
                IF(IPOLY.EQ.2) SPECFU=CHEBY1(DIFF,LXGP,INOD,NDNOD,NODPOS)
                !
                IF(IPOLY.EQ.3) SPECFU=CHEBY2(DIFF,LXGP,INOD,NDNOD,NODPOS)
                !
                IF(IPOLY.EQ.4) SPECFU=LEGEND(DIFF,LXGP,INOD,NDNOD,NODPOS)
              END FUNCTION SPECFU
            
            
            
              SUBROUTINE CHEROT(WEIT,QUAPOS,NDGI,GETNDP)
                IMPLICIT NONE
                INTEGER , intent(in) :: NDGI
                REAL, dimension(NDGI), intent(inout) :: WEIT, QUAPOS
                LOGICAL , intent(in) :: GETNDP
                !     This computes the weight and points for Chebyshev-Gauss-Lobatto quadrature.
                !     See page 67 of:Spectral Methods in Fluid Dynamics, C.Canuto
                !     IF(GETNDP) then get the POSITION OF THE NODES
                !     AND DONT BOTHER WITH THE WEITS.
                !Local variables
                real , PARAMETER :: PIE=3.141569254
                INTEGER :: IG,J
                !
                IF(.NOT.GETNDP) THEN
                   !     THE WEIGHTS...
                   WEIT(1)       =PIE/(2.*(NDGI-1))
                   WEIT(NDGI)=PIE/(2.*(NDGI-1))
                   do IG=2,NDGI-1
                      WEIT(IG)   =PIE/(NDGI-1)
                   END DO
                ENDIF
                !
                !     The quad points...
                do IG=1,NDGI
                   J=IG-1
                   QUAPOS(IG)=COS(PIE*REAL(J)/REAL(NDGI-1))
                END DO
              END SUBROUTINE CHEROT
            
            
            
            
              SUBROUTINE LEGROT(WEIT,QUAPOS,NDGI,GETNDP)
                IMPLICIT NONE
                !     This computes the weight and points for Chebyshev-Gauss-Lobatto quadrature.
                !     See page 69 of:Spectral Methods in Fluid Dynamics, C.Canuto
                !     IF(GETNDP) then get the POSITION OF THE NODES
                !     AND DONT BOTHER WITH THE WEITS.
                INTEGER , intent(in) :: NDGI
                REAL , dimension(NDGI) , intent(inout) :: WEIT,QUAPOS
                LOGICAL , intent(in) :: GETNDP
                !Local variables
                INTEGER :: N,IG
                real :: plegen
                !     Work out the root's i.e the quad positions first.
                CALL LROOTS(QUAPOS,NDGI)
                IF(.NOT.GETNDP) THEN
                   !     THE WEIGHTS...
                   N=NDGI-1
                   do IG=1,NDGI
                      WEIT(IG)=2./(REAL(N*(N+1))*PLEGEN(QUAPOS(IG),NDGI-1)**2)
                   END DO
                ENDIF
              END SUBROUTINE LEGROT
            
            
            
              real function PLEGEN(LX,K)
                REAL , intent(in):: LX
                INTEGER , intent(in) :: K
                !Local variables
                REAL :: R
                INTEGER :: L
                R=0.
                DO L=0,INT(K/2)
                   R=R+((-1)**L)*binomial_coefficient(K,L) &
                                  *binomial_coefficient(2*K-2*L,K)*LX**(K-2*L)
                END DO
                PLEGEN=R/REAL(2**K)
              end function plegen
            
            
            
              real function binomial_coefficient(K,L)
                !<! Calculate binomial coefficients
                integer factorial
            
                INTEGER K,L
                binomial_coefficient=factorial(K)/(factorial(L)*factorial(K-L))
            
              end function binomial_coefficient
            
            
            
              SUBROUTINE LROOTS(QUAPOS,NDGI)
                IMPLICIT NONE
                INTEGER, intent(in) :: NDGI
                REAL , dimension(NDGI), intent(inout) :: QUAPOS
                !Local variables
                REAL ALPHA,BETA,RKEEP
                INTEGER N,I
                !     This sub works out the Gauss-Lobatto-Legendre roots.
                ALPHA = 0.
                BETA   = 0.
                !
                N=NDGI-1
                CALL JACOBL(N,ALPHA,BETA,QUAPOS)
                !     Now reverse ordering.
                do I=1,INT(0.1+ NDGI/2)
                   RKEEP=QUAPOS(I)
                   QUAPOS(I)=QUAPOS(NDGI+1-I)
                   QUAPOS(NDGI+1-I)=RKEEP
                END DO
              END SUBROUTINE LROOTS
            
            
            
            
              REAL FUNCTION CHEBY1(DIFF,LX,INOD,NDNOD,NODPOS)
                IMPLICIT NONE
                INTEGER, intent(in) :: NDNOD,INOD
                REAL, intent(in) :: LX
                real, dimension(NDNOD), intent(in) :: NODPOS
                LOGICAL, intent(in)  ::  DIFF
                !Local variables
                LOGICAL  ::  DIFF2
                real :: RNX
                real tcheb
                !     If DIFF then returns the spectral function DIFFERENTIATED W.R.T X
                !     associated.
                !     This function returns the spectral function associated
                !     with node INOD at POINT LX
                !     NDNOD=no of nodes in 1-D.
                !     NDGI=no of Gauss pts in 1-D.
                !     NB The nodes are at the points COS(pie*J/2.) j=0,..,ndgi-1
                REAL CJ,CN,HX,XPT
                INTEGER NX,N
            
                NX=NDNOD-1
                RNX=REAL(NX)
                DIFF2=.FALSE.
                !
                CJ=1.
                IF((INOD.EQ.1).OR.(INOD.EQ.NDNOD)) CJ=2.
                HX=0.
                !
                CN=2.
                N=0
                XPT=NODPOS(INOD)
                HX=HX + ( (2./RNX)/(CJ*CN) )*TCHEB(N,XPT,.FALSE.,DIFF2)&
                     &     *TCHEB(N,LX,DIFF,DIFF2)
                CN=1.
                do  N=1,NX-1! Was loop 10
                   HX=HX + ( (2./RNX)/(CJ*CN) )*TCHEB(N,XPT,.FALSE.,DIFF2)&
                        &        *TCHEB(N,LX,DIFF,DIFF2)
                end do ! Was loop 10
                CN=2.
                N=NX
                HX=HX + ( (2./RNX)/(CJ*CN))*TCHEB(N,XPT,.FALSE.,DIFF2)&
                     &     *TCHEB(N,LX,DIFF,DIFF2)
                CHEBY1=HX
              END FUNCTION CHEBY1
            
            
            
            
              REAL FUNCTION CHEBY2(DIFF,LX,INOD,NDNOD,NODPOS)
                IMPLICIT NONE
                INTEGER , intent(in) :: NDNOD,INOD
                REAL, dimension(NDNOD), intent(in) :: NODPOS
                LOGICAL , intent(in) :: DIFF
                REAL, intent(in) :: LX
                !Local variables
                real :: R,RR,RCONST
                real :: tcheb
                !     If DIFF then returns the spectral function DIFFERENTIATED W.R.T X
                !     associated.
                !     This function returns the spectral function associated
                !     with node INOD at POINT LX
                !     NDNOD=no of nodes in 1-D.
                !     NDGI=no of Gauss pts in 1-D.
                !     NB The nodes are at the points COS(pie*J/2.) j=0,..,ndgi-1
                REAL CJ,CN,HX,XPT
                IF(.NOT.DIFF) THEN
                   IF(ABS(LX-NODPOS(INOD)).LT.1.E-10) THEN
                      CHEBY2=1.
                   ELSE
                      R=(-1.)**(INOD)*(1.-LX**2)&
                           &       *TCHEB(NDNOD-1,LX,.TRUE.,.FALSE.)
                      CJ=1.
                      IF((INOD.EQ.1).OR.(INOD.EQ.NDNOD)) CJ=2.
                      R=R/(CJ*(NDNOD-1)**2 *(LX-NODPOS(INOD)) )
                      CHEBY2=R
                   ENDIF
                ELSE
                   IF(ABS(LX-NODPOS(INOD)).LT.1.E-10) THEN
                      IF(ABS(LX+1.).LT.1.E-10) THEN
                         CHEBY2= (2.*(NDNOD-1)**2+1)/6.
                      ELSE
                         IF(ABS(LX-1.).LT.1.E-10) THEN
                            CHEBY2=-(2.*(NDNOD-1)**2+1)/6.
                         ELSE
                            CHEBY2=-LX/(2.*(1.-LX**2))
                         ENDIF
                      ENDIF
                   ELSE
                      R=(-1.)**(INOD)*(1.-LX**2)&
                           &          *TCHEB(NDNOD-1,LX,.FALSE.,.TRUE.)
                      CJ=1.
                      IF((INOD.EQ.1).OR.(INOD.EQ.NDNOD)) CJ=2.
                      R=R/(CJ*(NDNOD-1)**2 *(LX-NODPOS(INOD)) )
                      RR=(-1.)**(INOD)*TCHEB(NDNOD-1,LX,.TRUE.,.FALSE.)&
                           &           /(CJ*REAL(NDNOD-1)**2)
                      RCONST=-(2*LX+(1.-LX**2)/(LX-NODPOS(INOD) ) )&
                           &              /(LX-NODPOS(INOD))
                      RR=RR*RCONST
                      CHEBY2=RR
                   ENDIF
                ENDIF
              END FUNCTION CHEBY2
            
            
            
              REAL FUNCTION TCHEB(N,XPT,DIFF,DIFF2)
                !      use math_utilities
                IMPLICIT NONE
                LOGICAL , intent(in) :: DIFF,DIFF2
                integer, intent(in) :: N
                real, intent(in) :: XPT
                !Local variables
                REAL :: DDT,DT,T,TTEMP,TM1,DTM1,DTEMP,R,RR
                INTEGER :: K,L
                INTEGER :: NI
                integer :: factorial
                ! If DIFF then return the n'th Chebyshef polynomial
                ! differentiated w.r.t x.
                ! If DIFF2 then form the 2'nd derivative.
                ! This sub returns the value of the K'th Chebyshef polynomial at a
                ! point XPT.
                !
                ! This formula can be found in:Spectral Methods for Fluid Dynamics, page 66
                K=N
                !
                IF((.NOT.DIFF).AND.(.NOT.DIFF2)) THEN
                   IF(N.EQ.0) T=1.
                   IF(N.EQ.1) T=XPT
                   IF(N.GT.1) THEN
                      TM1=1.
                      T=XPT
                      do  NI=2,N! Was loop 110
                         TTEMP=T
                         T=2.*XPT*TTEMP - TM1
                         TM1=TTEMP
                      end do ! Was loop 110
                   ENDIF
                   TCHEB=T
                ENDIF
                !
                IF(DIFF.AND.(.NOT.DIFF2)) THEN
                   ! This part forms the differential w.r.t x.
                   IF(N.EQ.0) DT=0.
                   IF(N.EQ.1) THEN
                      T=XPT
                      DT=1.
                   ENDIF
                   IF(N.EQ.2) THEN
                      T=2.*XPT*XPT -1
                      DT=4.*XPT
                   ENDIF
                   IF(N.GT.2) THEN
                      TM1=XPT
                      DTM1=1.
                      T=2.*XPT*XPT -1
                      DT=4.*XPT
                      do  NI=2,N! Was loop 10
                         TTEMP=T
                         T=2.*XPT*TTEMP - TM1
                         TM1=TTEMP
                         !
                         DTEMP=DT
                         DT=2.*XPT*DTEMP+2.*TTEMP-DTM1
                         DTM1=DTEMP
                      end do ! Was loop 10
                   ENDIF
                   TCHEB=DT
                ENDIF
                !
                IF(DIFF2) THEN
                   IF(N.LE.1) THEN
                      DDT=0.
                   ELSE
                      R=0.
                      do  L=0,INT(0.1+K/2)! Was loop 50
                         RR=(-1.)**K*factorial(K-L-1)/(factorial(L)*factorial(K-2*L))
                         RR=RR*2**(K-2*L)
                         ! The following is for 2'nd derivative.
                         RR=RR*(K-2.*L)*(K-2.*L-1)*XPT**(K-2*L-2)
                         R=R+RR
                      end do ! Was loop 50
                      DDT=R*REAL(K)*0.5
                   ENDIF
                   TCHEB=DDT
                ENDIF
              END FUNCTION TCHEB
            
            
            
              recursive function factorial(n) result(f)
                ! Calculate n!
                integer :: f
                integer, intent(in) :: n
            
                if (n==0) then
                   f=1
                else
                   f=n*factorial(n-1)
                end if
            
              end function factorial
            
            
            
              REAL FUNCTION LEGEND(DIFF,LX,INOD,NDNOD,NODPOS)
                INTEGER , intent(in) :: INOD,NDNOD
                REAL, dimension(NDNOD), intent(in) :: NODPOS
                REAL, intent(in) :: LX
                LOGICAL , intent(in) :: DIFF
                !     If DIFF then returns the spectral function DIFFERENTIATED W.R.T X
                !     associated.
                !     This function returns the spectral function associated
                !     with node INOD at POINT LX
                !     NDNOD=no of nodes in 1-D.
                !     NDGI=no of Gauss pts in 1-D.
                !     NB The nodes are at the points COS(pie*J/2.) j=0,..,ndgi-1
                REAL CJ,CN,HX,XPT
                LEGEND=1.
              END FUNCTION LEGEND
            
            
            
            ! ************************************************************************
            ! *********TRIANGLES AND TETS ********************************************
            ! ************************************************************************
            
            
            
            
              SUBROUTINE SHATRInew(L1, L2, L3, L4, WEIGHT, &
                   NLOC,NGI,ndim,  N,NLX_ALL)
                ! Interface to SHATRIold using the new style variables
                IMPLICIT NONE
                INTEGER , intent(in) :: NLOC,NGI,ndim
                REAL , dimension(ngi), intent(in) :: L1, L2, L3, L4
                REAL , dimension(ngi), intent(inout) :: WEIGHT
                REAL , dimension(ngi, nloc ), intent(inout) ::N
                real, dimension (ngi,ndim,nloc), intent(inout) :: NLX_ALL
            ! local variables...
                REAL Nold(nloc, ngi ),NLXold(nloc, ngi ),NLYold(nloc, ngi ),NLZold(nloc, ngi )
                integer iloc
            
            !      print *,'**going into SHATRIold...'
            !      print *,'just before ndim,nloc,ngi:',ndim,nloc,ngi
            !    call SHATRIold(L1, L2, L3, L4, WEIGHT, size(NLX_ALL,1)==3, &
                call SHATRIold(L1, L2, L3, L4, WEIGHT, ndim==3, &
                     NLOC,NGI,  &
                     Nold,NLXold,NLYold,NLZold)
            !         N,NLX_ALL(:,1,:),NLX_ALL(:,2,:),NLX_ALL(:,ndim,:))
                do iloc=1,nloc
                   N(:,iloc) = Nold(iloc,:)
                   NLX_ALL(:,1,iloc)=NLXold(iloc,:)
                   NLX_ALL(:,2,iloc)=NLYold(iloc,:)
                   if(ndim==3) NLX_ALL(:,3,iloc) = NLZold(iloc,:)
                end do
            !    print *,'n:',n
            !    print *,'nlx_all:',nlx_all
            !    print *,'nloc,ngi:',nloc,ngi
            !    print *,'leaving SHATRInew'
            
              end subroutine SHATRInew
              !
              !
              SUBROUTINE SHATRIold(L1, L2, L3, L4, WEIGHT, D3, &
                   NLOC,NGI,  &
                   N,NLX,NLY,NLZ)
                ! Work out the shape functions and there derivatives...
                IMPLICIT NONE
                INTEGER , intent(in) :: NLOC,NGI
                LOGICAL , intent(in) :: D3
                REAL , dimension(ngi), intent(in) :: L1, L2, L3, L4
                REAL , dimension(ngi), intent(inout) :: WEIGHT
                REAL , dimension(nloc, ngi ), intent(inout) ::N,NLX,NLY,NLZ
                ! Local variables...
                INTEGER ::  GI
                !
                IF(.NOT.D3) THEN
                   ! Assume a triangle...
                   !
                   IF(NLOC.EQ.1) THEN
                      Loop_Gi_Nloc1: DO GI=1,NGI
                         N(1,GI)=1.0
                         NLX(1,GI)=0.0
                         NLY(1,GI)=0.0
                      end DO Loop_Gi_Nloc1
                   ELSE IF((NLOC.EQ.3).OR.(NLOC.EQ.4)) THEN
                      Loop_Gi_Nloc3_4: DO GI=1,NGI
                         N(1,GI)=L1(GI)
                         N(2,GI)=L2(GI)
                         N(3,GI)=L3(GI)
                         !
                         NLX(1,GI)=1.0
                         NLX(2,GI)=0.0
                         NLX(3,GI)=-1.0
                         !
                         NLY(1,GI)=0.0
                         NLY(2,GI)=1.0
                         NLY(3,GI)=-1.0
                         IF(NLOC.EQ.4) THEN
                            ! Bubble function...
                            !alpha == 1 behaves better than the correct value of 27. See Osman et al. 2019
                            N(4,GI)  =1. * L1(GI)*L2(GI)*L3(GI)
                            NLX(4,GI)=1. * L2(GI)*(1.-L2(GI))-2.*L1(GI)*L2(GI)
                            NLY(4,GI)=1. * L1(GI)*(1.-L1(GI))-2.*L1(GI)*L2(GI)
                         ENDIF
                      end DO Loop_Gi_Nloc3_4
                   ELSE IF((NLOC.EQ.6).OR.(NLOC.EQ.7)) THEN
                      Loop_Gi_Nloc_6_7: DO GI=1,NGI
                         N(1,GI)=(2.*L1(GI)-1.)*L1(GI)
                         N(2,GI)=(2.*L2(GI)-1.)*L2(GI)
                         N(3,GI)=(2.*L3(GI)-1.)*L3(GI)
                         !
                         N(4,GI)=4.*L1(GI)*L2(GI)
                         N(5,GI)=4.*L2(GI)*L3(GI)
                         N(6,GI)=4.*L1(GI)*L3(GI)
            
                         !
                         ! nb L1+L2+L3+L4=1
                         ! x-derivative...
                         NLX(1,GI)=4.*L1(GI)-1.
                         NLX(2,GI)=0.
                         NLX(3,GI)=-4.*(1.-L2(GI))+4.*L1(GI) + 1.
                         !
                         NLX(4,GI)=4.*L2(GI)
                         NLX(5,GI)=-4.*L2(GI)
                         NLX(6,GI)=4.*(1.-L2(GI))-8.*L1(GI)
                         !
                         ! y-derivative...
                         NLY(1,GI)=0.
                         NLY(2,GI)=4.*L2(GI)-1.0
                         NLY(3,GI)=-4.*(1.-L1(GI))+4.*L2(GI) + 1.
                         !
                         NLY(4,GI)=4.*L1(GI)
                         NLY(5,GI)=4.*(1.-L1(GI))-8.*L2(GI)
                         NLY(6,GI)=-4.*L1(GI)
                         IF(NLOC.EQ.7) THEN
                            ! Bubble function...
                            N(7,GI)  =L1(GI)*L2(GI)*L3(GI)
                            NLX(7,GI)=L2(GI)*(1.-L2(GI))-2.*L1(GI)*L2(GI)
                            NLY(7,GI)=L1(GI)*(1.-L1(GI))-2.*L1(GI)*L2(GI)
                         ENDIF
                      END DO Loop_Gi_Nloc_6_7
                      ! ENDOF IF(NLOC.EQ.6) THEN...
                   ELSE IF(NLOC==10) THEN ! Cubic triangle...
                      ! get the shape functions for a cubic triangle...
                      call shape_triangle_cubic( l1, l2, l3, l4, weight, d3, &
                           nloc, ngi, &
                           n, nlx, nly, nlz )
            
                   ELSE ! has not found the element shape functions
                      stop 811
                   ENDIF
                   !
                   ! ENDOF IF(.NOT.D3) THEN
                ENDIF
                !
                !
                IF(D3) THEN
                   ! Assume a tet...
                   ! This is for 5 point quadrature.
                   IF((NLOC.EQ.10).OR.(NLOC.EQ.11)) THEN
                      Loop_Gi_Nloc_10_11: DO GI=1,NGI
                         !ewrite(3,*)'gi,L1(GI),L2(GI),L3(GI),L4(GI):',gi,L1(GI),L2(GI),L3(GI),L4(GI)
                         N(1,GI)=(2.*L1(GI)-1.)*L1(GI)
                         N(3,GI)=(2.*L2(GI)-1.)*L2(GI)
                         N(5,GI)=(2.*L3(GI)-1.)*L3(GI)
                         N(10,GI)=(2.*L4(GI)-1.)*L4(GI)
            
                         !if(L1(GI).gt.-1.93) ewrite(3,*)'gi,L1(GI), L2(GI), L3(GI), L4(GI),N(1,GI):', &
                         !                            gi,L1(GI), L2(GI), L3(GI), L4(GI),N(1,GI)
                         !
                         !
                         N(2,GI)=4.*L1(GI)*L2(GI)
                         N(6,GI)=4.*L1(GI)*L3(GI)
                         N(7,GI)=4.*L1(GI)*L4(GI)
                         !
                         N(4,GI) =4.*L2(GI)*L3(GI)
                         N(9,GI) =4.*L3(GI)*L4(GI)
                         N(8,GI)=4.*L2(GI)*L4(GI)
                         ! nb L1+L2+L3+L4=1
                         ! x-derivative...
                         NLX(1,GI)=4.*L1(GI)-1.
                         NLX(3,GI)=0.
                         NLX(5,GI)=0.
                         NLX(10,GI)=-4.*(1.-L2(GI)-L3(GI))+4.*L1(GI) + 1.
                         !if(L1(GI).gt.-1.93) ewrite(3,*)'Nlx(1,GI):', &
                         !     Nlx(1,GI)
                         !
                         NLX(2,GI)=4.*L2(GI)
                         NLX(6,GI)=4.*L3(GI)
                         NLX(7,GI)=4.*(L4(GI)-L1(GI))
                         !
                         NLX(4,GI) =0.
                         NLX(9,GI) =-4.*L3(GI)
                         NLX(8,GI)=-4.*L2(GI)
                         !
                         ! y-derivative...
                         NLY(1,GI)=0.
                         NLY(3,GI)=4.*L2(GI)-1.0
                         NLY(5,GI)=0.
                         NLY(10,GI)=-4.*(1.-L1(GI)-L3(GI))+4.*L2(GI) + 1.
                         !
                         NLY(2,GI)=4.*L1(GI)
                         NLY(6,GI)=0.
                         NLY(7,GI)=-4.*L1(GI)
                         !
                         NLY(4,GI) =4.*L3(GI)
                         NLY(9,GI) =-4.*L3(GI)
                         NLY(8,GI)=4.*(1-L1(GI)-L3(GI))-8.*L2(GI)
                         !
                         ! z-derivative...
                         NLZ(1,GI)=0.
                         NLZ(3,GI)=0.
                         NLZ(5,GI)=4.*L3(GI)-1.
                         NLZ(10,GI)=-4.*(1.-L1(GI)-L2(GI))+4.*L3(GI) + 1.
                         !
                         NLZ(2,GI)=0.
                         NLZ(6,GI)=4.*L1(GI)
                         NLZ(7,GI)=-4.*L1(GI)
                         !
                         NLZ(4,GI) =4.*L2(GI)
                         NLZ(9,GI) =4.*(1.-L1(GI)-L2(GI))-8.*L3(GI)
                         NLZ(8,GI)=-4.*L2(GI)
                         IF(NLOC.EQ.11) THEN
                            ! Bubble function...
                            N(11,GI)  =L1(GI)*L2(GI)*L3(GI)*L4(GI)
                            NLX(11,GI)=L2(GI)*L3(GI)*(1.-L2(GI)-L3(GI))-2.*L1(GI)*L2(GI)*L3(GI)
                            NLY(11,GI)=L1(GI)*L3(GI)*(1.-L1(GI)-L3(GI))-2.*L1(GI)*L2(GI)*L3(GI)
                            NLZ(11,GI)=L1(GI)*L2(GI)*(1.-L1(GI)-L2(GI))-2.*L1(GI)*L2(GI)*L3(GI)
                         ENDIF
                         !
                      end DO Loop_Gi_Nloc_10_11
                      ! ENDOF IF(NLOC.EQ.10) THEN...
                   ENDIF
                   !
                   IF((NLOC.EQ.4).OR.(NLOC.EQ.5)) THEN
                      Loop_Gi_Nloc_4_5: DO GI=1,NGI
                         N(1,GI)=L1(GI)
                         N(2,GI)=L2(GI)
                         N(3,GI)=L3(GI)
                         N(4,GI)=L4(GI)
                         !
                         NLX(1,GI)=1.0
                         NLX(2,GI)=0
                         NLX(3,GI)=0
                         NLX(4,GI)=-1.0
                         !
                         NLY(1,GI)=0.0
                         NLY(2,GI)=1.0
                         NLY(3,GI)=0.0
                         NLY(4,GI)=-1.0
                         !
                         NLZ(1,GI)=0.0
                         NLZ(2,GI)=0.0
                         NLZ(3,GI)=1.0
                         NLZ(4,GI)=-1.0
                         IF(NLOC.EQ.5) THEN
                            ! Bubble function ...
                            !alpha == 50 behaves better than the correct value of 256. See Osman et al. 2019
                            N(5,GI)  = 50. * L1(GI)*L2(GI)*L3(GI)*L4(GI)
                            NLX(5,GI)= 50. * L2(GI)*L3(GI)*(1.-L2(GI)-L3(GI))  &
                                     -2.*L1(GI)*L2(GI)*L3(GI)
                            NLY(5,GI)= 50. * L1(GI)*L3(GI)*(1.-L1(GI)-L3(GI))  &
                                     -2.*L1(GI)*L2(GI)*L3(GI)
                            NLZ(5,GI)= 50. * L1(GI)*L2(GI)*(1.-L1(GI)-L2(GI))  &
                                     -2.*L1(GI)*L2(GI)*L3(GI)
                         ENDIF
                      end DO Loop_Gi_Nloc_4_5
                   ENDIF
                   !
                   IF(NLOC.EQ.1) THEN
                      Loop_Gi_Nloc_1: DO GI=1,NGI
                         N(1,GI)=1.0
                         NLX(1,GI)=0.0
                         NLY(1,GI)=0.0
                         NLZ(1,GI)=0.0
                      end DO Loop_Gi_Nloc_1
                   ENDIF
                   !
                   ! ENDOF IF(D3) THEN...
                ENDIF
                !
                RETURN
              END SUBROUTINE SHATRIold
              !
              !
              !
              !
              SUBROUTINE TRIQUAold(L1, L2, L3, L4, WEIGHT, D3,NGI)
                ! This sub calculates the local corrds L1, L2, L3, L4 and
                ! weights at the quadrature points.
                ! If D3 it does this for 3Dtetrahedra elements else
                ! triangular elements.
                IMPLICIT NONE
                INTEGER , intent(in):: NGI
                LOGICAL , intent(in) :: D3
                REAL , dimension(ngi) , intent(inout) ::L1, L2, L3, L4, WEIGHT
                ! Local variables...
                REAL :: ALPHA,BETA
                REAL :: ALPHA1,BETA1
                REAL :: ALPHA2,BETA2
                real :: rsum
                INTEGER I
                !
                IF(D3) THEN
                   ! this is for a tetrahedra element...
                   ! This is for one point.
                   IF(NGI.EQ.1) THEN
                      ! Degree of precision is 1
                      DO I=1,NGI
                         L1(I)=0.25
                         L2(I)=0.25
                         L3(I)=0.25
                         L4(I)=0.25
                         WEIGHT(I)=1.0
                      END DO
                   ENDIF
            
                   IF(NGI.EQ.4) THEN
                      ! Degree of precision is 2
                      ALPHA=0.58541020
                      BETA=0.13819660
                      DO I=1,NGI
                         L1(I)=BETA
                         L2(I)=BETA
                         L3(I)=BETA
                         L4(I)=BETA
                         WEIGHT(I)=0.25
                      END DO
                      L1(1)=ALPHA
                      L2(2)=ALPHA
                      L3(3)=ALPHA
                      L4(4)=ALPHA
                   ENDIF
            
                   IF(NGI.EQ.5) THEN
                      ! Degree of precision is 3
                      L1(1)=0.25
                      L2(1)=0.25
                      L3(1)=0.25
                      L4(1)=0.25
                      WEIGHT(1)=-4./5.
                      !
                      DO I=2,NGI
                         L1(I)=1./6.
                         L2(I)=1./6.
                         L3(I)=1./6.
                         L4(I)=1./6.
                         WEIGHT(I)=9./20.
                      END DO
                      L1(2)=0.5
                      L2(3)=0.5
                      L3(4)=0.5
                      L4(5)=0.5
                   ENDIF
                   !
                   IF(NGI.EQ.11) THEN
                      ! Degree of precision is 4
                      ALPHA=(1.+SQRT(5./14.))/4.0
                      BETA =(1.-SQRT(5./14.))/4.0
                      I=1
                      L1(I)=0.25
                      L2(I)=0.25
                      L3(I)=0.25
                      WEIGHT(I)=-6.*74.0/5625.0
                      DO I=2,5
                         L1(I)=1./14.
                         L2(I)=1./14.
                         L3(I)=1./14.
                         WEIGHT(I)=6.*343./45000.
                      END DO
                      L1(2)=11./14.
                      L2(3)=11./14.
                      L3(4)=11./14.
                      DO I=6,11
                         L1(I)=ALPHA
                         L2(I)=ALPHA
                         L3(I)=ALPHA
                         WEIGHT(I)=6.*56.0/2250.0
                      END DO
                      L3(6)=BETA
                      L2(7)=BETA
                      L2(8)=BETA
                      L3(8)=BETA
                      L1(9)=BETA
                      L1(10)=BETA
                      L3(10)=BETA
                      L1(11)=BETA
                      L2(11)=BETA
                      ! ENDOF IF(NGI.EQ.11) THEN...
                   ENDIF
            
                    if (NGI == 15) then!Fith order quadrature
                      ! Degree of precision is 5
                     L1=(/0.2500000000000000, 0.0000000000000000, 0.3333333333333333, &
                         0.3333333333333333, 0.3333333333333333, &
                         0.7272727272727273, 0.0909090909090909, 0.0909090909090909, &
                         0.0909090909090909, 0.4334498464263357, &
                         0.0665501535736643, 0.0665501535736643, 0.0665501535736643, &
                         0.4334498464263357, 0.4334498464263357/)
                     L2=(/0.2500000000000000, 0.3333333333333333, 0.3333333333333333, &
                         0.3333333333333333, 0.0000000000000000, &
                         0.0909090909090909, 0.0909090909090909, 0.0909090909090909, &
                         0.7272727272727273, 0.0665501535736643, &
                         0.4334498464263357, 0.0665501535736643, 0.4334498464263357, &
                         0.0665501535736643, 0.4334498464263357/)
                     L3=(/0.2500000000000000, 0.3333333333333333, 0.3333333333333333, &
                         0.0000000000000000, 0.3333333333333333, &
                         0.0909090909090909, 0.0909090909090909, 0.7272727272727273, &
                         0.0909090909090909, 0.0665501535736643, &
                         0.0665501535736643, 0.4334498464263357, 0.4334498464263357, &
                         0.4334498464263357, 0.0665501535736643/)
                     !We divide the weights later by 6
                     WEIGHT=(/0.1817020685825351, 0.0361607142857143, 0.0361607142857143, &
                         0.0361607142857143, 0.0361607142857143, &
                         0.0698714945161738, 0.0698714945161738, 0.0698714945161738, &
                         0.0698714945161738, 0.0656948493683187, &
                         0.0656948493683187, 0.0656948493683187, 0.0656948493683187, &
                         0.0656948493683187, 0.0656948493683187/)
                   end if
            
            
                   if (NGI == 45) then!Eighth order quadrature, for bubble shape functions or P3
                     !Obtained from: https://people.sc.fsu.edu/~jburkardt/datasets/quadrature_rules_tet/quadrature_rules_tet.html
                     !Here to get triangle quadrature sets:
                     !https://people.sc.fsu.edu/~jburkardt/datasets/quadrature_rules_tri/quadrature_rules_tri.html
                     ! Degree of precision is 8
                    L1=(/0.2500000000000000,0.6175871903000830,0.1274709365666390,0.1274709365666390,&
                    0.1274709365666390,0.9037635088221031,&
                    0.0320788303926323,0.0320788303926323,0.0320788303926323,0.4502229043567190,&
                    0.0497770956432810,0.0497770956432810,&
                    0.0497770956432810,0.4502229043567190,0.4502229043567190,0.3162695526014501,&
                    0.1837304473985499,0.1837304473985499,&
                    0.1837304473985499,0.3162695526014501,0.3162695526014501,0.0229177878448171,&
                    0.2319010893971509,0.2319010893971509,&
                    0.5132800333608811,0.2319010893971509,0.2319010893971509,0.2319010893971509,&
                    0.0229177878448171,0.5132800333608811,&
                    0.2319010893971509,0.0229177878448171,0.5132800333608811,0.7303134278075384,&
                    0.0379700484718286,0.0379700484718286,&
                    0.1937464752488044,0.0379700484718286,0.0379700484718286,0.0379700484718286,&
                    0.7303134278075384,0.1937464752488044,&
                    0.0379700484718286,0.7303134278075384,0.1937464752488044/)
                    L2=(/0.2500000000000000,0.1274709365666390,0.1274709365666390,0.1274709365666390,&
                    0.6175871903000830,0.0320788303926323,&
                    0.0320788303926323,0.0320788303926323,0.9037635088221031,0.0497770956432810,&
                    0.4502229043567190,0.0497770956432810,&
                    0.4502229043567190,0.0497770956432810,0.4502229043567190,0.1837304473985499,&
                    0.3162695526014501,0.1837304473985499,&
                    0.3162695526014501,0.1837304473985499,0.3162695526014501,0.2319010893971509,&
                    0.0229177878448171,0.2319010893971509,&
                    0.2319010893971509,0.5132800333608811,0.2319010893971509,0.0229177878448171,&
                    0.5132800333608811,0.2319010893971509,&
                    0.5132800333608811,0.2319010893971509,0.0229177878448171,0.0379700484718286,&
                    0.7303134278075384,0.0379700484718286,&
                    0.0379700484718286,0.1937464752488044,0.0379700484718286,0.7303134278075384,&
                    0.1937464752488044,0.0379700484718286,&
                    0.1937464752488044,0.0379700484718286,0.7303134278075384/)
                    L3=(/0.2500000000000000,0.1274709365666390,0.1274709365666390,0.6175871903000830,&
                    0.1274709365666390,0.0320788303926323,&
                    0.0320788303926323,0.9037635088221031,0.0320788303926323,0.0497770956432810,&
                    0.0497770956432810,0.4502229043567190,&
                    0.4502229043567190,0.4502229043567190,0.0497770956432810,0.1837304473985499,&
                    0.1837304473985499,0.3162695526014501,&
                    0.3162695526014501,0.3162695526014501,0.1837304473985499,0.2319010893971509,&
                    0.2319010893971509,0.0229177878448171,&
                    0.2319010893971509,0.2319010893971509,0.5132800333608811,0.5132800333608811,&
                    0.2319010893971509,0.0229177878448171,&
                    0.0229177878448171,0.5132800333608811,0.2319010893971509,0.0379700484718286,&
                    0.0379700484718286,0.7303134278075384,&
                    0.0379700484718286,0.0379700484718286,0.1937464752488044,0.1937464752488044,&
                    0.0379700484718286,0.7303134278075384,&
                    0.7303134278075384,0.1937464752488044,0.0379700484718286/)
                    !We divide the weights later by 6
                    WEIGHT=(/-0.2359620398477557,0.0244878963560562,0.0244878963560562,0.0244878963560562,&
                    0.0244878963560562,0.0039485206398261,&
                    0.0039485206398261,0.0039485206398261,0.0039485206398261,0.0263055529507371,&
                    0.0263055529507371,0.0263055529507371,&
                    0.0263055529507371,0.0263055529507371,0.0263055529507371,0.0829803830550589,&
                    0.0829803830550589,0.0829803830550589,&
                    0.0829803830550589,0.0829803830550589,0.0829803830550589,0.0254426245481023,&
                    0.0254426245481023,0.0254426245481023,&
                    0.0254426245481023,0.0254426245481023,0.0254426245481023,0.0254426245481023,&
                    0.0254426245481023,0.0254426245481023,&
                    0.0254426245481023,0.0254426245481023,0.0254426245481023,0.0134324384376852,&
                    0.0134324384376852,0.0134324384376852,&
                    0.0134324384376852,0.0134324384376852,0.0134324384376852,0.0134324384376852,&
                    0.0134324384376852,0.0134324384376852,&
                    0.0134324384376852,0.0134324384376852,0.0134324384376852/)
                  end if
            
                   DO I=1,NGI
                      L4(I)=1.0-L1(I)-L2(I)-L3(I)
                   END DO
            
                   ! Now multiply by 1/6. to get weigts correct...
                   DO I=1,NGI
                      WEIGHT(I)=WEIGHT(I)/6.
                   END DO
                   ! ENDOF IF(D3) THEN...
                ENDIF
                !
                IF(.NOT.D3) THEN
                   ! 2-D TRAINGULAR ELEMENTS...
                   IF(NGI.EQ.1) THEN
                      ! LINEAR
                      I=1
                      L1(I)=1./3.
                      L2(I)=1./3.
                      WEIGHT(I)=1.0
            !          WEIGHT(I)=0.5 !************************ISSUE WITH WEIGHTS
                   ENDIF
                   !
                   IF(NGI.EQ.3) THEN
                      ! QUADRASTIC
                      DO I=1,NGI
                         L1(I)=0.5
                         L2(I)=0.5
                         WEIGHT(I)=1.0/3.0
                      END DO
                      L1(2)=0.0
                      L2(3)=0.0
                   ENDIF
                   !
                   IF(NGI.EQ.4) THEN
                      ! CUBIC
                      I=1
                      L1(I)=1./3.
                      L2(I)=1./3.
                      WEIGHT(I)=-27./48.
                      DO I=2,NGI
                         L1(I)=0.2
                         L2(I)=0.2
                         WEIGHT(I)=25./48.
                      END DO
                      L1(1)=0.6
                      L2(2)=0.6
                   ENDIF
                   !
                   IF(NGI.EQ.7) THEN
                      ! QUNTIC
                      ALPHA1=0.0597158717
                      BETA1 =0.4701420641
                      ALPHA2=0.7974269853
                      BETA2 =0.1012865073
                      I=1
                      L1(I)=1./3.
                      L2(I)=1./3.
                      WEIGHT(I)=0.225
                      DO I=2,4
                         L1(I)=BETA1
                         L2(I)=BETA1
                         WEIGHT(I)=0.1323941527
                      END DO
                      L1(2)=ALPHA1
                      L2(4)=ALPHA1
                      DO I=5,7
                         L1(I)=BETA2
                         L2(I)=BETA2
                         WEIGHT(I)=0.1259391805
                      END DO
                      L1(5)=ALPHA2
                      L2(6)=ALPHA2
                      ! ENDOF IF(NGI.EQ.7) THEN...
                   ENDIF
            
                   IF(NGI.EQ.14) THEN
                      ! 5th order quadrature set...
                      L1(1) = 6.943184420297371E-002
                      L1(2) = 6.943184420297371E-002
                      L1(3) = 6.943184420297371E-002
                      L1(4) = 6.943184420297371E-002
                      L1(5) = 6.943184420297371E-002
                      L1(6) = 0.330009478207572
                      L1(7) = 0.330009478207572
                      L1(8) = 0.330009478207572
                      L1(9) = 0.330009478207572
                      L1(10) = 0.669990521792428
                      L1(11) = 0.669990521792428
                      L1(12) = 0.669990521792428
                      L1(13) = 0.930568155797026
                      L1(14) = 0.930568155797026
                      ! local coord 1:
                      L2(1) = 4.365302387072518E-002
                      L2(2) = 0.214742881469342
                      L2(3) = 0.465284077898513
                      L2(4) = 0.715825274327684
                      L2(5) = 0.886915131926301
                      L2(6) = 4.651867752656094E-002
                      L2(7) = 0.221103222500738
                      L2(8) = 0.448887299291690
                      L2(9) = 0.623471844265867
                      L2(10) = 3.719261778493340E-002
                      L2(11) = 0.165004739103786
                      L2(12) = 0.292816860422638
                      L2(13) = 1.467267513102734E-002
                      L2(14) = 5.475916907194637E-002
                      ! local coord 2:
                      WEIGHT(1) = 1.917346464706755E-002
                      WEIGHT(2) = 3.873334126144628E-002
                      WEIGHT(3) = 4.603770904527855E-002
                      WEIGHT(4) = 3.873334126144628E-002
                      WEIGHT(5) = 1.917346464706755E-002
                      WEIGHT(6) = 3.799714764789616E-002
                      WEIGHT(7) = 7.123562049953998E-002
                      WEIGHT(8) = 7.123562049953998E-002
                      WEIGHT(9) = 3.799714764789616E-002
                      WEIGHT(10) = 2.989084475992800E-002
                      WEIGHT(11) = 4.782535161588505E-002
                      WEIGHT(12) = 2.989084475992800E-002
                      WEIGHT(13) = 6.038050853208200E-003
                      WEIGHT(14) = 6.038050853208200E-003
                      rsum=SUM(WEIGHT(1:NGI))
                      WEIGHT(1:NGI)=WEIGHT(1:NGI)/RSUM
                      ! ENDOF IF(NGI.EQ.14) THEN...
                   ENDIF
            ! 
                   if(ngi==44) then ! (n=9)
                      L1(1) = 1.985507175123191E-002
                      L1(2) = 1.985507175123191E-002
                      L1(3) = 1.985507175123191E-002
                      L1(4) = 1.985507175123191E-002
                      L1(5) = 1.985507175123191E-002
                      L1(6) = 1.985507175123191E-002
                      L1(7) = 1.985507175123191E-002
                      L1(8) = 1.985507175123191E-002
                      L1(9) = 1.985507175123191E-002
                      L1(10) = 0.101666761293187
                      L1(11) = 0.101666761293187
                      L1(12) = 0.101666761293187
                      L1(13) = 0.101666761293187
                      L1(14) = 0.101666761293187
                      L1(15) = 0.101666761293187
                      L1(16) = 0.101666761293187
                      L1(17) = 0.101666761293187
                      L1(18) = 0.237233795041836
                      L1(19) = 0.237233795041836
                      L1(20) = 0.237233795041836
                      L1(21) = 0.237233795041836
                      L1(22) = 0.237233795041836
                      L1(23) = 0.237233795041836
                      L1(24) = 0.237233795041836
                      L1(25) = 0.408282678752175
                      L1(26) = 0.408282678752175
                      L1(27) = 0.408282678752175
                      L1(28) = 0.408282678752175
                      L1(29) = 0.408282678752175
                      L1(30) = 0.408282678752175
                      L1(31) = 0.591717321247825
                      L1(32) = 0.591717321247825
                      L1(33) = 0.591717321247825
                      L1(34) = 0.591717321247825
                      L1(35) = 0.591717321247825
                      L1(36) = 0.762766204958164
                      L1(37) = 0.762766204958164
                      L1(38) = 0.762766204958164
                      L1(39) = 0.762766204958164
                      L1(40) = 0.898333238706813
                      L1(41) = 0.898333238706813
                      L1(42) = 0.898333238706813
                      L1(43) = 0.980144928248768
                      L1(44) = 0.980144928248768
            
            !L2(1)...
                      L2(1) = 1.560378988162790E-002
                      L2(2) = 8.035663927218221E-002
                      L2(3) = 0.189476014677302
                      L2(4) = 0.331164789916112
                      L2(5) = 0.490072464124384
                      L2(6) = 0.648980138332656
                      L2(7) = 0.790668913571466
                      L2(8) = 0.899788288976586
                      L2(9) = 0.964541138367140
                      L2(10) = 1.783647091104033E-002
                      L2(11) = 9.133063094134081E-002
                      L2(12) = 0.213115003430640
                      L2(13) = 0.366773901111335
                      L2(14) = 0.531559337595478
                      L2(15) = 0.685218235276173
                      L2(16) = 0.807002607765473
                      L2(17) = 0.880496767795773
                      L2(18) = 1.940938228235618E-002
                      L2(19) = 9.857563833019303E-002
                      L2(20) = 0.226600619520678
                      L2(21) = 0.381383102479082
                      L2(22) = 0.536165585437487
                      L2(23) = 0.664190566627971
                      L2(24) = 0.743356822675808
                      L2(25) = 1.997947907913758E-002
                      L2(26) = 0.100234137152044
                      L2(27) = 0.225261107830170
                      L2(28) = 0.366456213417655
                      L2(29) = 0.491483184095780
                      L2(30) = 0.571737842168687
                      L2(31) = 1.915257191055202E-002
                      L2(32) = 9.421749319819557E-002
                      L2(33) = 0.204141339376088
                      L2(34) = 0.314065185553979
                      L2(35) = 0.389130106841623
                      L2(36) = 1.647157989702492E-002
                      L2(37) = 7.828940091495819E-002
                      L2(38) = 0.158944394126877
                      L2(39) = 0.220762215144811
                      L2(40) = 1.145801331145764E-002
                      L2(41) = 5.083338064659329E-002
                      L2(42) = 9.020874798172894E-002
                      L2(43) = 4.195870365439417E-003
                      L2(44) = 1.565920138579250E-002
            
            ! WEIGHT(1)...
                      WEIGHT(1) = 2.015983497663207E-003
                      WEIGHT(2) = 4.480916044841641E-003
                      WEIGHT(3) = 6.464359484621604E-003
                      WEIGHT(4) = 7.747662769908149E-003
                      WEIGHT(5) = 8.191474625434276E-003
                      WEIGHT(6) = 7.747662769908149E-003
                      WEIGHT(7) = 6.464359484621604E-003
                      WEIGHT(8) = 4.480916044841641E-003
                      WEIGHT(9) = 2.015983497663207E-003
                      WEIGHT(10) = 5.055663745070170E-003
                      WEIGHT(11) = 1.110639128725685E-002
                      WEIGHT(12) = 1.566747257514398E-002
                      WEIGHT(13) = 1.811354111938598E-002
                      WEIGHT(14) = 1.811354111938598E-002
                      WEIGHT(15) = 1.566747257514398E-002
                      WEIGHT(16) = 1.110639128725685E-002
                      WEIGHT(17) = 5.055663745070170E-003
                      WEIGHT(18) = 7.745946956361961E-003
                      WEIGHT(19) = 1.673231410555364E-002
                      WEIGHT(20) = 2.284153446586376E-002
                      WEIGHT(21) = 2.500282281756943E-002
                      WEIGHT(22) = 2.284153446586376E-002
                      WEIGHT(23) = 1.673231410555364E-002
                      WEIGHT(24) = 7.745946956361961E-003
                      WEIGHT(25) = 9.191827856850984E-003
                      WEIGHT(26) = 1.935542449754594E-002
                      WEIGHT(27) = 2.510431683577024E-002
                      WEIGHT(28) = 2.510431683577024E-002
                      WEIGHT(29) = 1.935542449754594E-002
                      WEIGHT(30) = 9.191827856850984E-003
                      WEIGHT(31) = 8.770885597453929E-003
                      WEIGHT(32) = 1.771853503082167E-002
                      WEIGHT(33) = 2.105991205229386E-002
                      WEIGHT(34) = 1.771853503082167E-002
                      WEIGHT(35) = 8.770885597453929E-003
                      WEIGHT(36) = 6.471997505236908E-003
                      WEIGHT(37) = 1.213345702759751E-002
                      WEIGHT(38) = 1.213345702759751E-002
                      WEIGHT(39) = 6.471997505236908E-003
                      WEIGHT(40) = 3.140105492486528E-003
                      WEIGHT(41) = 5.024168787978471E-003
                      WEIGHT(42) = 3.140105492486528E-003
                      WEIGHT(43) = 5.024749628293684E-004
                      WEIGHT(44) = 5.024749628293684E-004
                   endif ! if(ngi=44) then
            ! 
                   if(ngi==49) then ! (n=7)
                      L1(1) = 0.2500000000D+00
                      L1(2) = 0.1485387122D+00
                      L1(3) = 0.3514612878D+00
                      L1(4) = 0.6461720360D-01
                      L1(5) = 0.4353827964D+00
                      L1(6) = 0.1272302191D-01
                      L1(7) = 0.4872769781D+00
                      L1(8) = 0.3514612878D+00
                      L1(9) = 0.2088224283D+00
                      L1(10) = 0.4941001474D+00
                      L1(11) = 0.9084178238D-01
                      L1(12) = 0.6120807933D+00
                      L1(13) = 0.1788659867D-01
                      L1(14) = 0.6850359770D+00
                      L1(15) = 0.1485387122D+00
                      L1(16) = 0.8825499604D-01
                      L1(17) = 0.2088224283D+00
                      L1(18) = 0.3839262482D-01
                      L1(19) = 0.2586847995D+00
                      L1(20) = 0.7559445160D-02
                      L1(21) = 0.2895179792D+00
                      L1(22) = 0.4353827964D+00
                      L1(23) = 0.2586847995D+00
                      L1(24) = 0.6120807933D+00
                      L1(25) = 0.1125328752D+00
                      L1(26) = 0.7582327176D+00
                      L1(27) = 0.2215753944D-01
                      L1(28) = 0.8486080534D+00
                      L1(29) = 0.6461720360D-01
                      L1(30) = 0.3839262482D-01
                      L1(31) = 0.9084178238D-01
                      L1(32) = 0.1670153200D-01
                      L1(33) = 0.1125328752D+00
                      L1(34) = 0.3288504390D-02
                      L1(35) = 0.1259459028D+00
                      L1(36) = 0.4872769781D+00
                      L1(37) = 0.2895179792D+00
                      L1(38) = 0.6850359770D+00
                      L1(39) = 0.1259459028D+00
                      L1(40) = 0.8486080534D+00
                      L1(41) = 0.2479854268D-01
                      L1(42) = 0.9497554135D+00
                      L1(43) = 0.1272302191D-01
                      L1(44) = 0.7559445160D-02
                      L1(45) = 0.1788659867D-01
                      L1(46) = 0.3288504390D-02
                      L1(47) = 0.2215753944D-01
                      L1(48) = 0.6475011465D-03
                      L1(49) = 0.2479854268D-01
            ! 
            ! L2(1) = 
                      L2(1) = 0.5000000000D+00
                      L2(2) = 0.7029225757D+00
                      L2(3) = 0.2970774243D+00
                      L2(4) = 0.8707655928D+00
                      L2(5) = 0.1292344072D+00
                      L2(6) = 0.9745539562D+00
                      L2(7) = 0.2544604383D-01
                      L2(8) = 0.5000000000D+00
                      L2(9) = 0.7029225757D+00
                      L2(10) = 0.2970774243D+00
                      L2(11) = 0.8707655928D+00
                      L2(12) = 0.1292344072D+00
                      L2(13) = 0.9745539562D+00
                      L2(14) = 0.2544604383D-01
                      L2(15) = 0.5000000000D+00
                      L2(16) = 0.7029225757D+00
                      L2(17) = 0.2970774243D+00
                      L2(18) = 0.8707655928D+00
                      L2(19) = 0.1292344072D+00
                      L2(20) = 0.9745539562D+00
                      L2(21) = 0.2544604383D-01
                      L2(22) = 0.5000000000D+00
                      L2(23) = 0.7029225757D+00
                      L2(24) = 0.2970774243D+00
                      L2(25) = 0.8707655928D+00
                      L2(26) = 0.1292344072D+00
                      L2(27) = 0.9745539562D+00
                      L2(28) = 0.2544604383D-01
                      L2(29) = 0.5000000000D+00
                      L2(30) = 0.7029225757D+00
                      L2(31) = 0.2970774243D+00
                      L2(32) = 0.8707655928D+00
                      L2(33) = 0.1292344072D+00
                      L2(34) = 0.9745539562D+00
                      L2(35) = 0.2544604383D-01
                      L2(36) = 0.5000000000D+00
                      L2(37) = 0.7029225757D+00
                      L2(38) = 0.2970774243D+00
                      L2(39) = 0.8707655928D+00
                      L2(40) = 0.1292344072D+00
                      L2(41) = 0.9745539562D+00
                      L2(42) = 0.2544604383D-01
                      L2(43) = 0.5000000000D+00
                      L2(44) = 0.7029225757D+00
                      L2(45) = 0.2970774243D+00
                      L2(46) = 0.8707655928D+00
                      L2(47) = 0.1292344072D+00
                      L2(48) = 0.9745539562D+00
                      L2(49) = 0.2544604383D-01
            ! 
            ! WEIGHT(1)...
                      WEIGHT(1) = 0.2183621219D-01
                      WEIGHT(2) = 0.1185259869D-01
                      WEIGHT(3) = 0.2804474024D-01
                      WEIGHT(4) = 0.3777048400D-02
                      WEIGHT(5) = 0.2544928909D-01
                      WEIGHT(6) = 0.3442812316D-03
                      WEIGHT(7) = 0.1318557174D-01
                      WEIGHT(8) = 0.1994866947D-01
                      WEIGHT(9) = 0.1082804890D-01
                      WEIGHT(10) = 0.2562052651D-01
                      WEIGHT(11) = 0.3450556783D-02
                      WEIGHT(12) = 0.2324942860D-01
                      WEIGHT(13) = 0.3145212381D-03
                      WEIGHT(14) = 0.1204579851D-01
                      WEIGHT(15) = 0.1994866947D-01
                      WEIGHT(16) = 0.1082804890D-01
                      WEIGHT(17) = 0.2562052651D-01
                      WEIGHT(18) = 0.3450556783D-02
                      WEIGHT(19) = 0.2324942860D-01
                      WEIGHT(20) = 0.3145212381D-03
                      WEIGHT(21) = 0.1204579851D-01
                      WEIGHT(22) = 0.1461316874D-01
                      WEIGHT(23) = 0.7931962886D-02
                      WEIGHT(24) = 0.1876802249D-01
                      WEIGHT(25) = 0.2527665748D-02
                      WEIGHT(26) = 0.1703110194D-01
                      WEIGHT(27) = 0.2303989213D-03
                      WEIGHT(28) = 0.8824011376D-02
                      WEIGHT(29) = 0.1461316874D-01
                      WEIGHT(30) = 0.7931962886D-02
                      WEIGHT(31) = 0.1876802249D-01
                      WEIGHT(32) = 0.2527665748D-02
                      WEIGHT(33) = 0.1703110194D-01
                      WEIGHT(34) = 0.2303989213D-03
                      WEIGHT(35) = 0.8824011376D-02
                      WEIGHT(36) = 0.6764926484D-02
                      WEIGHT(37) = 0.3671971955D-02
                      WEIGHT(38) = 0.8688347794D-02
                      WEIGHT(39) = 0.1170141347D-02
                      WEIGHT(40) = 0.7884268950D-02
                      WEIGHT(41) = 0.1066593969D-03
                      WEIGHT(42) = 0.4084931154D-02
                      WEIGHT(43) = 0.6764926484D-02
                      WEIGHT(44) = 0.3671971955D-02
                      WEIGHT(45) = 0.8688347794D-02
                      WEIGHT(46) = 0.1170141347D-02
                      WEIGHT(47) = 0.7884268950D-02
                      WEIGHT(48) = 0.1066593969D-03
                      WEIGHT(49) = 0.4084931154D-02
                   endif ! if(ngi=49) then
                   !
                   DO I=1,NGI
                      L3(I)=1.0-L1(I)-L2(I)
                   END DO
                   ! ENDOF IF(.NOT.D3) THEN...
                ENDIF
                weight=0.5*weight ! *********big change
                !
                RETURN
              END subroutine TRIQUAold
              !
              !
            
            
            
              subroutine shape_triangle_cubic( l1, l2, l3, l4, weight, d3, &
                   nloc, ngi, &
                   n, nlx, nly, nlz )
                implicit none
                integer, intent( in ) :: nloc, ngi
                real, dimension( ngi ), intent( in ) :: l1, l2, l3, l4, weight
                logical, intent( in ) :: d3
                real, dimension( nloc, ngi ), intent( inout ) :: n, nlx, nly, nlz
                ! Local variables
                logical :: base_order
                integer :: gi, ndim, cv_ele_type_dummy, u_nloc_dummy
                real, dimension( :, : ), allocatable :: cvn_dummy, un_dummy, unlx_dummy, &
                     unly_dummy, unlz_dummy
                real, dimension( : ), allocatable :: cvweigh_dummy
                real :: a,b
            
                !ewrite(3,*)'In shatri d3,nloc=',d3,nloc
                if(nloc.ne.10) then ! wrong element type
                   stop 28213
                endif
            ! The node the numbering is:
                        !  3
                        !  | \
                        !  8  7
                        !  |   \
                        !  9 10 6
                        !  |     \
                        !  1-4-5--2
            
                ! cubic triangle...
                do gi = 1, ngi
                   ! corner nodes...
                   n( 1, gi ) = 0.5*( 3. * l1( gi ) - 1. ) * (3. * l1( gi )   -2.) *  l1( gi )
                   n( 2, gi ) = 0.5*( 3. * l2( gi ) - 1. ) * (3. * l2( gi )   -2.) *  l2( gi )
                   n( 3, gi ) = 0.5*( 3. * l3( gi ) - 1. ) * (3. * l3( gi )   -2.) *  l3( gi )
                   ! mid side nodes...
                   n( 4, gi ) = (9./2.)*l1( gi )*l2( gi )*( 3. * l1( gi ) - 1. )
                   n( 5, gi ) = (9./2.)*l2( gi )*l1( gi )*( 3. * l2( gi ) - 1. )
            
                   n( 6, gi ) = (9./2.)*l2( gi )*l3( gi )*( 3. * l2( gi ) - 1. )
                   n( 7, gi ) = (9./2.)*l3( gi )*l2( gi )*( 3. * l3( gi ) - 1. )
            
                   n( 8, gi ) = (9./2.)*l3( gi )*l1( gi )*( 3. * l3( gi ) - 1. )
                   n( 9, gi ) = (9./2.)*l1( gi )*l3( gi )*( 3. * l1( gi ) - 1. )
                   ! central node...
                   n( 10, gi ) = 27.*l1( gi )*l2( gi )*l3( gi )
            
                   ! x-derivative (nb. l1 + l2 + l3  = 1 )
                   ! corner nodes...
                   nlx( 1, gi ) = 0.5*( 27. * l1( gi )**2  - 18. *  l1( gi ) + 2. )
                   nlx( 2, gi ) = 0.0
                   nlx( 3, gi ) = 0.5*( 27. * l3( gi )**2  - 18. *  l3( gi ) + 2. )   *  (-1.0)
                   ! mid side nodes...
                   nlx( 4, gi ) = (9./2.)*(6.*l1( gi )*l2( gi )  - l2( gi ) )
                   nlx( 5, gi ) = (9./2.)*l2( gi )*( 3. * l2( gi ) - 1. )
            
                   nlx( 6, gi ) = - (9./2.)*l2( gi )*( 3. * l2( gi ) - 1. )
                   nlx( 7, gi ) = (9./2.)*(   -l2(gi)*( 6.*l3(gi) -1. )    )
            
                   nlx( 8, gi ) = -(9./2.)*( l1( gi )*(6.*l3(gi)-1.) + l3(gi)*(3.*l3(gi)-1.)  )
                   nlx( 9, gi ) = (9./2.)*(  l3(gi)*(3.*l1(gi)-1.) -l1(gi)*(3.*l1(gi)-1.)  )
                   ! central node...
                   nlx( 10, gi ) = 27.*l2( gi )*( 1. - 2.*l1(gi)  - l2( gi ) )
            
                   ! y-derivative (nb. l1 + l2 + l3  = 1 )
                   ! corner nodes...
                   nly( 1, gi ) = 0.0
                   nly( 2, gi ) = 0.5*( 27. * l2( gi )**2  - 18. *  l2( gi ) + 2.  )
                   nly( 3, gi ) = 0.5*( 27. * l3( gi )**2  - 18. *  l3( gi ) + 2.  )   *  (-1.0)
                   ! mid side nodes...
                   nly( 4, gi ) = (9./2.)*l1( gi )*( 3. * l1( gi ) - 1. )
                   nly( 5, gi ) = (9./2.)*l1( gi )*( 6. * l2( gi ) - 1. )
            
                   nly( 6, gi ) = (9./2.)*( l3( gi )*( 6. * l2( gi ) - 1. ) -l2(gi)*( 3.*l2(gi)-1. )  )
                   nly( 7, gi ) = (9./2.)*( -l2( gi )*( 6. * l3( gi ) - 1. ) +l3(gi)*(3.*l3(gi)-1.)  )
            
                   nly( 8, gi ) = -(9./2.)*l1( gi )*( 6. * l3( gi ) - 1. )
                   nly( 9, gi ) = -(9./2.)*l1( gi )*( 3. * l1( gi ) - 1. )
                   ! central node...
                   nly( 10, gi ) = 27.*l1( gi )*( 1. - 2.*l2(gi)  - l1( gi ) )
                end do
            
              end subroutine shape_triangle_cubic
            
            
                      
            !
            ! 
                   SUBROUTINE MATINV(A,N,NMAX,MAT,MAT2,X,B)
            ! This sub finds the inverse of the matrix A and puts it back in A. 
            ! MAT, MAT2 & X,B are working vectors. 
                   IMPLICIT NONE
                   INTEGER N,NMAX
                   REAL A(NMAX,NMAX),MAT(N,N),MAT2(N,N),X(N),B(N)
            ! Local variables
                   INTEGER ICOL,IM,JM
            
            
                     DO IM=1,N
                       DO JM=1,N
                         MAT(IM,JM)=A(IM,JM)
                       END DO
                     END DO
            ! Solve MAT X=B (NB MAT is overwritten).  
                   CALL SMLINN_FACTORIZE(MAT,X,B,N,N)
            !
                   DO ICOL=1,N
            !
            ! Form column ICOL of the inverse. 
                     DO IM=1,N
                       B(IM)=0.
                     END DO
                     B(ICOL)=1.0
            ! Solve MAT X=B (NB MAT is overwritten).  
                   CALL SMLINN_SOLVE_LU(MAT,X,B,N,N)
            ! X contains the column ICOL of inverse
                     DO IM=1,N
                       MAT2(IM,ICOL)=X(IM)
                     END DO 
            !
                  END DO
            !
            ! Set A to MAT2
                     DO IM=1,N
                       DO JM=1,N
                         A(IM,JM)=MAT2(IM,JM)
                       END DO
                     END DO
                   RETURN
                   END SUBROUTINE MATINV
            !
            !
            !     
                  
                    SUBROUTINE SMLINN_FACTORIZE(A,X,B,NMX,N)
                    IMPLICIT NONE
                    INTEGER NMX,N
                    REAL A(NMX,NMX),X(NMX),B(NMX)
                    REAL R
                    INTEGER K,I,J
            !     Form X = A^{-1} B
            !     Useful subroutine for inverse
            !     This sub overwrites the matrix A. 
                    DO K=1,N-1
                       DO I=K+1,N
                          A(I,K)=A(I,K)/A(K,K)
                       END DO
                       DO J=K+1,N
                          DO I=K+1,N
                             A(I,J)=A(I,J) - A(I,K)*A(K,J)
                          END DO
                       END DO
                    END DO
            !     
                  if(.false.) then
            !     Solve L_1 x=b
                    DO I=1,N
                       R=0.
                       DO J=1,I-1
                          R=R+A(I,J)*X(J)
                       END DO
                       X(I)=B(I)-R
                    END DO
            !     
            !     Solve U x=y
                    DO I=N,1,-1
                       R=0.
                       DO J=I+1,N
                          R=R+A(I,J)*X(J)
                       END DO
                       X(I)=(X(I)-R)/A(I,I)
                    END DO
                  endif
                    RETURN
                    END SUBROUTINE SMLINN_FACTORIZE
            !     
            !     
                  
                    SUBROUTINE SMLINN_SOLVE_LU(A,X,B,NMX,N)
                    IMPLICIT NONE
                    INTEGER NMX,N
                    REAL A(NMX,NMX),X(NMX),B(NMX)
                    REAL R
                    INTEGER K,I,J
            !     Form X = A^{-1} B
            !     Useful subroutine for inverse
            !     This sub overwrites the matrix A. 
                   if(.false.) then
                    DO K=1,N-1
                       DO I=K+1,N
                          A(I,K)=A(I,K)/A(K,K)
                       END DO
                       DO J=K+1,N
                          DO I=K+1,N
                             A(I,J)=A(I,J) - A(I,K)*A(K,J)
                          END DO
                       END DO
                    END DO
                   endif
            !     
            !     Solve L_1 x=b
                    DO I=1,N
                       R=0.
                       DO J=1,I-1
                          R=R+A(I,J)*X(J)
                       END DO
                       X(I)=B(I)-R
                    END DO
            !     
            !     Solve U x=y
                    DO I=N,1,-1
                       R=0.
                       DO J=I+1,N
                          R=R+A(I,J)*X(J)
                       END DO
                       X(I)=(X(I)-R)/A(I,I)
                    END DO
                    RETURN
                    END SUBROUTINE SMLINN_SOLVE_LU
            !     
            !       
            
            
            !     
                  SUBROUTINE JACOBL(N,ALPHA,BETA,XJAC)
                  IMPLICIT NONE
            !     COMPUTES THE GAUSS-LOBATTO COLLOCATION POINTS FOR JACOBI POLYNOMIALS
            !     
            !     N:       DEGREE OF APPROXIMATION
            !     ALPHA:   PARAMETER IN JACOBI WEIGHT
            !     BETA:    PARAMETER IN JACOBI WEIGHT
            !     
            !     XJAC:    OUTPUT ARRAY WITH THE GAUSS-LOBATTO ROOTS
            !     THEY ARE ORDERED FROM LARGEST (+1.0) TO SMALLEST (-1.0)
            !     
                  INTEGER N
                  REAL ALPHA,BETA
            !      IMPLICIT REAL(A-H,O-Z)
            !      REAL XJAC(1)
                  REAL XJAC(N+1)
                  REAL ALP,BET,RV
                  REAL PNP1P,PDNP1P,PNP,PDNP,PNM1P,PDNM1,PNP1M,PDNP1M,PNM,PDNM,PNM1M
                  REAL DET,RP,RM,A,B,DTH,CD,SD,CS,SS,X,PNP1,PDNP1,PN,PDN,PNM1,POLY
                  REAL PDER,RECSUM,DELX,CSSAVE
                  INTEGER NP,NH,J,K,JM,I,NPP
                  COMMON /JACPAR/ALP,BET,RV
                  INTEGER KSTOP
                  DATA KSTOP/10/
                  REAL EPS
                  DATA EPS/1.0E-12/
                  ALP = ALPHA
                  BET =BETA
                  RV = 1 + ALP
                  NP = N+1
            !
            !  COMPUTE THE PARAMETERS IN THE POLYNOMIAL WHOSE ROOTS ARE DESIRED
            !
                  CALL JACOBF(NP,PNP1P,PDNP1P,PNP,PDNP,PNM1P,PDNM1,1.0)
                  CALL JACOBF(NP,PNP1M,PDNP1M,PNM,PDNM,PNM1M,PDNM1,-1.0)
                  DET = PNP*PNM1M-PNM*PNM1P
                  RP = -PNP1P
                  RM = -PNP1M
                  A = (RP*PNM1M-RM*PNM1P)/DET
                  B = (RM*PNP-RP*PNM)/DET
            !
                  XJAC(1) = 1.0
                  NH = (N+1)/2
            !
            !  SET-UP RECURSION RELATION FOR INITIAL GUESS FOR THE ROOTS
            !
                  DTH = 3.14159265/(2*N+1)
                  CD = COS(2.*DTH)
                  SD = SIN(2.*DTH)
                  CS = COS(DTH)
                  SS = SIN(DTH)
            !
            !  COMPUTE THE FIRST HALF OF THE ROOTS BY POLYNOMIAL DEFLATION
            !
                  do  J=2,NH! Was loop 39
                     X = CS
                  do  K=1,KSTOP! Was loop 29
                        CALL JACOBF(NP,PNP1,PDNP1,PN,PDN,PNM1,PDNM1,X)
                        POLY = PNP1+A*PN+B*PNM1
                        PDER = PDNP1+A*PDN+B*PDNM1
                        RECSUM = 0.0
                        JM = J-1
                  do  I=1,JM! Was loop 27
                           RECSUM = RECSUM+1.0/(X-XJAC(I))
                  end do ! Was loop 27
            28          CONTINUE
                        DELX = -POLY/(PDER-RECSUM*POLY)
                        X = X+DELX
                        IF(ABS(DELX) .LT. EPS) GO TO 30
                  end do ! Was loop 29
            30       CONTINUE
                     XJAC(J) = X
                     CSSAVE = CS*CD-SS*SD
                     SS = CS*SD+SS*CD
                     CS = CSSAVE
                  end do ! Was loop 39
                  XJAC(NP) = -1.0
                  NPP = N+2
            !
            ! USE SYMMETRY FOR SECOND HALF OF THE ROOTS
            !
                  do  I=2,NH! Was loop 49
                     XJAC(NPP-I) = -XJAC(I)
                  end do ! Was loop 49
                  IF(N .NE. 2*(N/2)) RETURN
                  XJAC(NH+1) = 0.0
                  RETURN
                  END SUBROUTINE JACOBL
            
            
            !     
            !     
            !     
                  REAL FUNCTION LAGRAN(DIFF,LX,INOD,NDNOD,NODPOS)
                  IMPLICIT NONE
            !     This return the Lagrange poly assocaited with node INOD at point LX
            !     If DIFF then send back the value of this poly differentiated. 
                  LOGICAL DIFF
                  INTEGER INOD,NDNOD
                  REAL LX,NODPOS(0:NDNOD-1)
                  REAL DENOMI,OVER,OVER1
                  INTEGER N,K,I,JJ
            !     ewrite(3,*) 'inside lagran'
            !     ewrite(3,*) 'DIFF,LX,INOD,NDNOD,NODPOS:',
            !     &            DIFF,LX,INOD,NDNOD,NODPOS
            !
                  N=NDNOD-1
                  K=INOD-1
            !     
                  DENOMI=1.
                  do I=0,K-1
                     DENOMI=DENOMI*(NODPOS(K)-NODPOS(I))
                  END DO
                  do I=K+1,N
                     DENOMI=DENOMI*(NODPOS(K)-NODPOS(I))
                  END DO
            !     
                  IF(.NOT.DIFF) THEN
                     OVER=1.
                  do I=0,K-1
                        OVER=OVER*(LX-NODPOS(I))
                     END DO
                  do I=K+1,N
                        OVER=OVER*(LX-NODPOS(I))
                     END DO
                     LAGRAN=OVER/DENOMI
                  ELSE
                     OVER=0.
                  do JJ=0,N
                        IF(JJ.NE.K) THEN
                           OVER1=1.
                  do I=0,K-1
                              IF(JJ.NE.I) OVER1=OVER1*(LX-NODPOS(I))
                           END DO
                  do I=K+1,N
                              IF(JJ.NE.I) OVER1=OVER1*(LX-NODPOS(I))
                           END DO
                           OVER=OVER+OVER1
                        ENDIF
                     END DO
                     LAGRAN=OVER/DENOMI
                  ENDIF
            !     
            !     ewrite(3,*) 'FINISHED LAGRAN'
                  END
                  
            
            
                  SUBROUTINE LAGROT(WEIT,QUAPOS,NDGI,GETNDP)
            !        use RGPTWE_module
                  IMPLICIT NONE
            !     This computes the weight and points for standard Gaussian quadrature.
            !     IF(GETNDP) then get the POSITION OF THE NODES 
            !     AND DONT BOTHER WITH THE WEITS.
                  INTEGER NDGI
                  REAL WEIT(NDGI),QUAPOS(NDGI)
                  LOGICAL GETNDP
                  LOGICAL WEIGHT
                  INTEGER IG
            ! real function...
                  real RGPTWE
            !     
                  IF(.NOT.GETNDP) THEN
                     WEIGHT=.TRUE.
                     do IG=1,NDGI
                        WEIT(IG)=RGPTWE(IG,NDGI,WEIGHT)
                     END DO
            !     
                     WEIGHT=.FALSE.
                     do IG=1,NDGI
                        QUAPOS(IG)=RGPTWE(IG,NDGI,WEIGHT)
                     END DO
                  ELSE
                     IF(NDGI.EQ.1) THEN
                        QUAPOS(1)=0.
                     ELSE
                        do IG=1,NDGI
                           QUAPOS(IG)= -1+2.*REAL(IG-1)/REAL(NDGI-1)
                        END DO
                     ENDIF
                  ENDIF
                  END SUBROUTINE LAGROT
            
            
            
            
            
              REAL FUNCTION RGPTWE(IG,ND,WEIGHT)
                IMPLICIT NONE
                !     NB If WEIGHT is TRUE in function RGPTWE then return the Gauss-pt weight 
                !     else return the Gauss-pt. 
                !     NB there are ND Gauss points we are looking for either the 
                !     weight or the x-coord of the IG'th Gauss point. 
                INTEGER IG,ND
                LOGICAL WEIGHT
            
                IF(WEIGHT) THEN
                   if(ND==19) GO TO 19000
                   GO TO (10,20,30,40,50,60,70,80,90,100) ND
                   !     +++++++++++++++++++++++++++++++
                   !     For N=1 +++++++++++++++++++++++
            10     CONTINUE
                   RGPTWE=2.0
                   GO TO 1000
                   !     For N=2 +++++++++++++++++++++++
            20     CONTINUE
                   RGPTWE=1.0
                   GO TO 1000
                   ! For N=3 +++++++++++++++++++++++
            30     CONTINUE
                   GO TO (11,12,11) IG
            11     RGPTWE= 0.555555555555556
                   GO TO 1000
            12     RGPTWE= 0.888888888888889
                   GO TO 1000
                   ! For N=4 +++++++++++++++++++++++
            40     CONTINUE
                   GO TO (21,22,22,21) IG
            21     RGPTWE= 0.347854845137454
                   GO TO 1000
            22     RGPTWE= 0.652145154862546
                   GO TO 1000
                   ! For N=5 +++++++++++++++++++++++
            50     CONTINUE
                   GO TO (31,32,33,32,31) IG
            31     RGPTWE= 0.236926885056189
                   GO TO 1000
            32     RGPTWE= 0.478628670499366
                   GO TO 1000
            33     RGPTWE= 0.568888888888889
                   GO TO 1000
                   ! For N=6 +++++++++++++++++++++++
            60     CONTINUE
                   GO TO (41,42,43,43,42,41) IG
            41     RGPTWE= 0.171324492379170
                   GO TO 1000
            42     RGPTWE= 0.360761573048139
                   GO TO 1000
            43     RGPTWE= 0.467913934572691
                   GO TO 1000
                   ! For N=7 +++++++++++++++++++++++
            70     CONTINUE
                   GO TO (51,52,53,54,53,52,51) IG
            51     RGPTWE= 0.129484966168870
                   GO TO 1000
            52     RGPTWE= 0.279705391489277
                   GO TO 1000
            53     RGPTWE= 0.381830050505119
                   GO TO 1000
            54     RGPTWE= 0.417959183673469
                   GO TO 1000
                   ! For N=8 +++++++++++++++++++++++
            80     CONTINUE
                   GO TO (61,62,63,64,64,63,62,61) IG
            61     RGPTWE= 0.101228536290376
                   GO TO 1000
            62     RGPTWE= 0.222381034453374
                   GO TO 1000
            63     RGPTWE= 0.313706645877877
                   GO TO 1000
            64     RGPTWE= 0.362683783378362
                   GO TO 1000
                   ! For N=9 +++++++++++++++++++++++
            90     CONTINUE
                   GO TO (71,72,73,74,75,74,73,72,71) IG
            71     RGPTWE= 0.081274388361574
                   GO TO 1000
            72     RGPTWE= 0.180648160694857
                   GO TO 1000
            73     RGPTWE= 0.260610696402935
                   GO TO 1000
            74     RGPTWE= 0.312347077040003
                   GO TO 1000
            75     RGPTWE= 0.330239355001260
                   GO TO 1000
                   ! For N=10 +++++++++++++++++++++++
            100    CONTINUE
                   GO TO (81,82,83,84,85,85,84,83,82,81) IG
            81     RGPTWE= 0.066671344308688
                   GO TO 1000
            82     RGPTWE= 0.149451349150581
                   GO TO 1000
            83     RGPTWE= 0.219086362515982
                   GO TO 1000
            84     RGPTWE= 0.269266719309996
                   GO TO 1000
            85     RGPTWE= 0.295524224714753
                   GO TO 1000
                   ! For N=19 +++++++++++++++++++++++
            19000  CONTINUE
                   GO TO (9991,9992,9993,9994,9995,9996,9997,9998,9999, 91000,  &
                          9999,9998,9997,9996,9995,9994,9993,9992,9991) IG
            9991     RGPTWE= 0.0194617882297265
                   GO TO 1000
            9992     RGPTWE= 0.0448142267656996
                   GO TO 1000
            9993     RGPTWE= 0.0690445427376412
                   GO TO 1000
            9994     RGPTWE= 0.0914900216224500
                   GO TO 1000
            9995     RGPTWE= 0.1115666455473340
                   GO TO 1000
            9996     RGPTWE= 0.1287539625393362
                   GO TO 1000
            9997     RGPTWE= 0.1426067021736066
                   GO TO 1000
            9998     RGPTWE= 0.1527660420658597
                   GO TO 1000
            9999     RGPTWE= 0.1589688433939543
                   GO TO 1000
            91000     RGPTWE= 0.1610544498487837
                   GO TO 1000
            ! 
            1000   CONTINUE
                ELSE
                   IF(ND==19) GOTO 1090
                   GO TO (210,220,230,240,250,260,270,280,290,200) ND
                   ! +++++++++++++++++++++++++++++++
                   ! For N=1 +++++++++++++++++++++++ THE GAUSS POINTS...
            210    CONTINUE
                   RGPTWE=0.0
                   GO TO 2000
                   ! For N=2 +++++++++++++++++++++++
            220    CONTINUE
                   RGPTWE= 0.577350269189626
                   GO TO 2000
                   ! For N=3 +++++++++++++++++++++++
            230    CONTINUE
                   GO TO (211,212,211) IG
            211    RGPTWE= 0.774596669241483
                   GO TO 2000
            212    RGPTWE= 0.0
                   GO TO 2000
                   ! For N=4 +++++++++++++++++++++++
            240    CONTINUE
                   GO TO (221,222,222,221) IG
            221    RGPTWE= 0.861136311594953
                   GO TO 2000
            222    RGPTWE= 0.339981043584856
                   GO TO 2000
                   ! For N=5 +++++++++++++++++++++++
            250    CONTINUE
                   GO TO (231,232,233,232,231) IG
            231    RGPTWE= 0.906179845938664
                   GO TO 2000
            232    RGPTWE= 0.538469310105683
                   GO TO 2000
            233    RGPTWE= 0.0
                   GO TO 2000
                   ! For N=6 +++++++++++++++++++++++
            260    CONTINUE
                   GO TO (241,242,243,243,242,241) IG
            241    RGPTWE= 0.932469514203152
                   GO TO 2000
            242    RGPTWE= 0.661209386466265
                   GO TO 2000
            243    RGPTWE= 0.238619186083197
                   GO TO 2000
                   ! For N=7 +++++++++++++++++++++++
            270    CONTINUE
                   GO TO (251,252,253,254,253,252,251) IG
            251    RGPTWE= 0.949107912342759
                   GO TO 2000
            252    RGPTWE= 0.741531185599394
                   GO TO 2000
            253    RGPTWE= 0.405845151377397
                   GO TO 2000
            254    RGPTWE= 0.0
                   GO TO 2000
                   ! For N=8 +++++++++++++++++++++++
            280    CONTINUE
                   GO TO (261,262,263,264,264,263,262,261) IG
            261    RGPTWE= 0.960289856497536
                   GO TO 2000
            262    RGPTWE= 0.796666477413627
                   GO TO 2000
            263    RGPTWE= 0.525532409916329
                   GO TO 2000
            264    RGPTWE= 0.183434642495650
                   GO TO 2000
                   ! For N=9 +++++++++++++++++++++++
            290    CONTINUE
                   GO TO (271,272,273,274,275,274,273,272,271) IG
            271    RGPTWE= 0.968160239507626
                   GO TO 2000
            272    RGPTWE= 0.836031107326636
                   GO TO 2000
            273    RGPTWE= 0.613371432700590
                   GO TO 2000
            274    RGPTWE= 0.324253423403809
                   GO TO 2000
            275    RGPTWE= 0.0
                   GO TO 2000
                   ! For N=10 +++++++++++++++++++++++
            200    CONTINUE
                   GO TO (281,282,283,284,285,285,284,283,282,281) IG
            281    RGPTWE= 0.973906528517172
                   GO TO 2000
            282    RGPTWE= 0.865063366688985
                   GO TO 2000
            283    RGPTWE= 0.679409568299024
                   GO TO 2000
            284    RGPTWE= 0.433395394129247
                   GO TO 2000
            285    RGPTWE= 0.148874338981631
                   GO TO 2000
                   !
                   ! For N=19 +++++++++++++++++++++++
            1090    CONTINUE
                   GO TO (181,182,183,184,185,186,187,188,189, 190, &
                          189,188,187,186,185,184,183,182,181) IG
            181    RGPTWE= 0.9924068438435844
                   GO TO 2000
            182    RGPTWE= 0.9602081521348300
                   GO TO 2000
            183    RGPTWE= 0.9031559036148179
                   GO TO 2000
            184    RGPTWE= 0.8227146565371428
                   GO TO 2000
            185    RGPTWE= 0.7209661773352294
                   GO TO 2000
            186    RGPTWE= 0.6005453046616810
                   GO TO 2000
            187    RGPTWE= 0.4645707413759609
                   GO TO 2000
            188    RGPTWE= 0.3165640999636298
                   GO TO 2000
            189    RGPTWE= 0.1603586456402254
                   GO TO 2000
            190    RGPTWE= 0.0
                   GO TO 2000
            ! 
            2000   CONTINUE
                   IF(IG.LE.INT((ND/2)+0.1)) RGPTWE=-RGPTWE
                ENDIF
            ! the web link provides extensive list of 
            ! https://pomax.github.io/bezierinfo/legendre-gauss.html
              END FUNCTION RGPTWE
            
            
            
            
            
                  SUBROUTINE JACOBF(N,POLY,PDER,POLYM1,PDERM1,POLYM2,PDERM2,X)
                  IMPLICIT NONE
            !     
            !     COMPUTES THE JACOBI POLYNOMIAL (POLY) AND ITS DERIVATIVE
            !     (PDER) OF DEGREE  N  AT  X
            !     
                  INTEGER N
                  REAL APB,POLY,PDER,POLYM1,PDERM1,POLYM2,PDERM2,X
            !     IMPLICIT REAL(A-H,O-Z)
                  COMMON /JACPAR/ALP,BET,RV
                  REAL ALP,BET,RV,POLYLST,PDERLST,A1,A2,B3,A3,A4
                  REAL POLYN,PDERN,PSAVE,PDSAVE
                  INTEGER K
                  APB = ALP+BET
                  POLY = 1.0
                  PDER = 0.0
                  IF(N .EQ. 0) RETURN
                  POLYLST = POLY
                  PDERLST = PDER
                  POLY = RV * X
                  PDER = RV
                  IF(N .EQ. 1) RETURN
                  do K=2,N
                     A1 = 2.*K*(K+APB)*(2.*K+APB-2.)
                     A2 = (2.*K+APB-1.)*(ALP**2-BET**2)
                     B3 = (2.*K+APB-2.)
                     A3 = B3*(B3+1.)*(B3+2.)
                     A4 = 2.*(K+ALP-1)*(K+BET-1.)*(2.*K+APB)
                     POLYN = ((A2+A3*X)*POLY-A4*POLYLST)*A1
                     PDERN = ((A2+A3*X)*PDER-A4*PDERLST+A3*POLY)*A1
                     PSAVE = POLYLST
                     PDSAVE = PDERLST
                     POLYLST = POLY
                     POLY = POLYN
                     PDERLST = PDER
                     PDER = PDERN
                  END DO
                  POLYM1 = POLYLST
                  PDERM1 = PDERLST
                  POLYM2 = PSAVE
                  PDERM2 = PDSAVE
                  RETURN
                  END SUBROUTINE JACOBF
            
            
            
                  SUBROUTINE MAIN1
                     IMPLICIT NONE 
                     INTEGER iuse_starting_node, graph_trim, ncurve, nonods, ncola
                     integer, allocatable :: fina(:),cola(:)
                     integer, allocatable :: ncurve_whichd(:,:), ncurve_space_fill_curve_numbering(:,:)
           ! read from disc...
                     print *,'reading file_cola'
                     open(27,file='file_cola')
                     read(27,*) iuse_starting_node, graph_trim, ncurve, nonods, ncola
                     allocate( fina(nonods+1), cola(ncola) ) 
                     read(27,*) fina(1:nonods+1)
                     read(27,*) cola(1:ncola) 
                     close(27)
                     print *,'finished reading file_cola'
                     print *,'iuse_starting_node, graph_trim, ncurve, nonods, ncola:', &
                              iuse_starting_node, graph_trim, ncurve, nonods, ncola
                     print *,'fina(1:10):',fina(1:10)
                     print *,'cola(1:10):',cola(1:10)
           
           !            ncurve=2
           !            iuse_starting_node=0 ! use starting node from end of previous space filling curve if >0
           ! -ve graph_trim then use matrix to deter decomposition.
           ! -3 works well. 4 also works welll (default) 
           !            graph_trim=-10 ! graph trimming options abs >3 <9 max trim  and =(0 or 10) no trim (=1 is best for trimming)
                       allocate( ncurve_whichd(nonods,ncurve), ncurve_space_fill_curve_numbering(nonods,ncurve) )
                       call ncurve_python_subdomain_space_filling_curve( ncurve_whichd,  &
                         ncurve_space_fill_curve_numbering,  cola,fina, iuse_starting_node, graph_trim, ncurve, nonods,ncola)
           
                       call write_disc_curve(ncurve_whichd, ncurve_space_fill_curve_numbering, ncurve, nonods)
           
                     stop 
                     END SUBROUTINE MAIN1
             

                  subroutine write_disc_cola(cola, fina, starting_node, graph_trim, ncurve, nonods, ncola)
                    !*******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: starting_node, graph_trim, ncurve, nonods, ncola
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                    
                              open(27,file='file_cola')
                              write(27,*) starting_node, graph_trim, ncurve, nonods, ncola
                              write(27,*) fina(1:nonods+1)
                              write(27,*) cola(1:ncola) 
                              close(27)
                              end subroutine write_disc_cola
                    
                    
                    
                              subroutine read_disc_curve(ncurve_whichd, ncurve_space_fill_curve_numbering, ncurve, nonods)
                    !*******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: ncurve, nonods
                              INTEGER, INTENT(out) :: ncurve_whichd(nonods,ncurve)
                              INTEGER, INTENT(out) :: ncurve_space_fill_curve_numbering(nonods,ncurve)
                              open(27,file='file_curve')
                              ! read from disc
                                 read(27,*) ncurve_whichd 
                                 read(27,*) ncurve_space_fill_curve_numbering
                              close(27)
                              end subroutine read_disc_curve
                    
                    
                              subroutine write_disc_curve(ncurve_whichd, ncurve_space_fill_curve_numbering, ncurve, nonods)
                    !*******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: ncurve, nonods
                              INTEGER, INTENT(in) :: ncurve_whichd(nonods,ncurve)
                              INTEGER, INTENT(in) :: ncurve_space_fill_curve_numbering(nonods,ncurve)
                              open(27,file='file_curve')
                              ! output to disc
                                 write(27,*) ncurve_whichd
                                 write(27,*) ncurve_space_fill_curve_numbering
                              close(27)
                              end subroutine write_disc_curve
                    
                    
                    
                              SUBROUTINE MAIN2
                    !          use procs127, only : TEST_R_I, PYTHON_SET_UP_RECBIS 
                              IMPLICIT NONE 
                    
                    !         integer, parameter :: nx=100, ny=100
                    !         integer, parameter :: nx=1560, ny=1200
                    !         integer, parameter :: nx=100, ny=1
                    !         integer, parameter :: nx=4, ny=4
                    !         integer, parameter :: nx=8, ny=8
                    !         integer, parameter :: nx=16, ny=16
                             integer, parameter :: nx=16, ny=700
                    !         integer, parameter :: nx=4, ny=35
                    !         integer, parameter :: nx=4, ny=35
                    !         integer, parameter :: nx=16, ny=160
                    !         integer, parameter :: nx=128, ny=128
                    !         integer, parameter :: nx=256, ny=256
                    !         integer, parameter :: nx=512, ny=512
                    !         integer, parameter :: nx=1024, ny=1024
                    !         integer, parameter :: nonods=nx*ny, nsplt=8
                    !         integer, parameter :: nonods=nx*ny, nsplt=12
                             integer, parameter :: nonods=nx*ny
                             integer, parameter :: mx_ncola = 50*nonods
                            
                             integer fina(nonods+1),cola(mx_ncola),whichd(nonods)
                             integer space_fill_curve_numbering(nonods), diff_valancy(nonods)   
                             integer count,nod,col,ISUB,ncola,iexact
                             INTEGER ISUB_MAX, ISUB_MIN, idivid,nlevel
                             INTEGER havwnod, havmat, na, nonods_dg, ncolm_dg, nloc, ele,k, i,j,ii,jj, kloc, nsplt, level 
                             integer icurve,ncurve, starting_node, long_nonods, iuse_starting_node, iii,jjj, graph_trim
                             real dx,dy,x_wide,y_wide, xloc(3),yloc(3)
                             real, allocatable :: wnod(:), a(:), coordinates(:,:)
                             integer, allocatable :: findm_dg(:),colm_dg(:), SPLEVS(:)
                             integer, allocatable :: ncurve_whichd(:,:), ncurve_space_fill_curve_numbering(:,:)
                             integer, allocatable :: long_ncurve_space_fill_curve_numbering(:)  
                             integer, allocatable :: long_new2old(:) 
                             LOGICAL EXACT,test_calc_sparse
                    
                    ! 2**nsplit=no of subdomains >= nonods 
                             if(.false.) then
                                nsplt=4
                             else
                                do i=1,10000
                                   nsplt=i
                                   if(2**nsplt>=nonods) exit
                                end do
                    !            nsplt=nsplt+1
                             endif
                              print *,'nonods,nsplt=',nonods,nsplt
                             allocate(SPLEVS(nsplt))        
                    
                             test_calc_sparse=.true.
                             if(test_calc_sparse) then
                    ! ordering of the triangle elements (nx=2,ny=2): 
                    ! 3  2     6   9  8      12    + 12 to each
                    ! 1     4  5   7     10  11    + 12 to each
                    ! 3  2     6   9  8      12
                    ! 1     4  5   7     10  11
                               nloc=3
                               nonods_dg=nx*ny*2*nloc
                    !           nonods2=(nx+1)*(ny+1)
                               allocate(coordinates(nonods_dg,3)) 
                               allocate(findm_dg(nonods_dg+1),colm_dg(20*nonods_dg))
                               x_wide=1.0
                               y_wide=1.0
                               dx=x_wide/nx
                               dy=y_wide/ny
                               do j=1,ny
                                  do i=1,nx
                                     do ii=1,2
                                        ele=2*((j-1)*nx + i -1) +ii
                                        if(ii==1) then
                                           xloc(1) = dx*(i-1) 
                                           xloc(2) = dx*(i-1) + dx
                                           xloc(3) = dx*(i-1) 
                                           yloc(1) = dy*(j-1) 
                                           yloc(2) = dy*(j-1) + dy
                                           yloc(3) = dy*(j-1) + dy
                                        else
                                           xloc(1) = dx*(i-1) 
                                           xloc(2) = dx*(i-1) + dx
                                           xloc(3) = dx*(i-1) + dx
                                           yloc(1) = dy*(j-1) 
                                           yloc(2) = dy*(j-1) 
                                           yloc(3) = dy*(j-1) + dy
                                        endif
                                        do kloc=1,nloc
                                           k = (ele-1)*nloc + kloc
                                           coordinates(k,1)=xloc(kloc)
                                           coordinates(k,2)=yloc(kloc)
                                           coordinates(k,3)=0.0
                    !                       print *,'ele,kloc,k,coords:',ele,kloc,k,coordinates(k,1),coordinates(k,2)
                                        end do
                                     end do
                                  end do
                               end do
                    ! Get the sparcity...
                               print *,'entering FORM_SPARE_MATRIC_FROM_PTS nonods_dg',nonods_dg
                    !           call FORM_SPARE_MATRIC_FROM_PTS( findm_dg,colm_dg,ncolm_dg, coordinates, nonods_dg )
                               print *,'finished out of FORM_SPARE_MATRIC_FROM_PTS'
                    !           print *,'findm_dg:',findm_dg
                               do k=1,-nonods_dg
                                  print *,'k=',k
                                  print *,'coords:',coordinates(k,1),coordinates(k,2)
                                  print *,'coln:',(colm_dg(count),count=findm_dg(k),findm_dg(k+1)-1) 
                               end do
                    !           stop 123
                             endif
                                     
                    
                              count=0
                              do j=1,ny
                              do i=1,nx
                                 nod = (j-1)*nx + i 
                                 fina(nod)=count+1
                    
                                 if(.true.) then ! 9 or 25 point stencil
                                    do jj=-1,1,1 ! 9 point stencil
                                    do ii=-1,1,1
                    !                do jj=-2,2,1 ! 25 point stencil
                    !                do ii=-2,2,1
                                    if(.not. ((abs(ii)==2).and.(abs(jj)==2)) ) then
                                       iii=i+ii
                                       jjj=j+jj
                                       col = (jjj-1)*nx + iii 
                    !                   col=nod+ii + jj*nx
                                       if((col.ge.1).and.(col.le.nonods)) then
                                       if((jjj.ge.1).and.(jjj.le.ny)) then
                                       if((iii.ge.1).and.(iii.le.nx)) then
                                          count=count+1
                                          cola(count)=col
                                       endif
                                       endif
                                       endif
                                    endif ! if(.not. ((abs(ii)==2).and.(abs(jj)==2)) ) then
                                    end do
                                    end do
                                 else ! 5 pt stencil in 2d...
                                   if(j.ne.1) then
                                    col=nod-nx
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                   if(i.ne.1) then
                                    col=nod-1
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                    col=nod
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   if(i.ne.nx) then
                                    col=nod+1
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                   if(j.ne.ny) then
                                    col=nod+nx
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                 endif
                    
                              end do
                              end do
                              fina(nonods+1)=count+1
                              ncola=count
                    
                              allocate(wnod(nonods))
                              exact=.true. ! exact node balance in each subdomain
                              iexact=1
                    !          exact=.false. ! exact node balance in each subdomain
                              havmat=0
                              na=ncola*havmat+1
                              allocate(A(ncola*havmat+1))
                              havwnod=2
                              wnod=1.0
                              ii=1
                              na=0
                    !          wnod(1:nonods/2)=10.0
                    
                    !          print *,'fina:',fina
                    !          print *,'cola:',cola
                    
                              SPLEVS(:)=2
                    !          SPLEVS(1)=5
                    !          SPLEVS(2)=2
                    !          SPLEVS(3)=2
                    !          SPLEVS(4)=2
                    !          SPLEVS(5)=2
                    !          SPLEVS(6)=2
                    !          SPLEVS(7)=2
                    !          SPLEVS(8)=2
                    
                    !          SPLEVS(9)=2
                    !          SPLEVS(10)=2
                             starting_node=0
                             if(.true.) then
                                ncurve=1
                    !            ncurve=2
                                iuse_starting_node=0 ! use starting node from end of previous space filling curve if >0
                    ! -ve graph_trim then use matrix to deter decomposition.
                    ! -3 works well. 4 also works welll (default) 
                                graph_trim=-10 ! graph trimming options abs >3 <9 max trim  and =(0 or 10) no trim (=1 is best for trimming)
                                iuse_starting_node=-1 ! use the rapid within subroutine mehtod
                    !            graph_trim=100 ! rapid SFC generation method 
                                allocate( ncurve_whichd(nonods,ncurve), ncurve_space_fill_curve_numbering(nonods,ncurve) )
                                call ncurve_python_subdomain_space_filling_curve( ncurve_whichd,  &
                                  ncurve_space_fill_curve_numbering,  cola,fina, iuse_starting_node, graph_trim, ncurve, nonods,ncola)
                    ! trim the space filling curve to remove issolated nodes and if continuous SFC then only have 1 start and finish node.
                                allocate( long_ncurve_space_fill_curve_numbering(nonods*ncurve) )
                                allocate( long_new2old(nonods*ncurve) )
                                print *,'going into ncurve_space_filling_curve_long_vec'
                                call ncurve_space_filling_curve_long_vec(long_ncurve_space_fill_curve_numbering, long_new2old, &
                                               long_nonods, ncurve_space_fill_curve_numbering, cola,fina, nonods,ncola, ncurve)
                                print *,'nonods, ncurve, long_nonods:',nonods, ncurve, long_nonods
                                if(nonods.lt.200) then
                                   print *,'long_ncurve_space_fill_curve_numbering(1:long_nonods):', &
                                            long_ncurve_space_fill_curve_numbering(1:long_nonods)
                                   print *,'long_new2old(1:long_nonods):', long_new2old(1:long_nonods)
                                endif
                                do icurve=1,ncurve
                                   print *,'space_fill_curve_numbering for curve:', icurve,' :'
                                   do j=1,ny
                                      PRINT *,ncurve_space_fill_curve_numbering( (j-1)*nx +1: j*nx, icurve)
                                   end do
                                   call calc_diff_valancy(diff_valancy,ncurve_space_fill_curve_numbering(:,icurve), &
                                           cola,fina, nonods,ncola )
                                   print *,'max diference to neighbout node on SFC:'
                                   do j=1,ny
                                      PRINT *,diff_valancy( (j-1)*nx +1: j*nx)
                                   end do
                                   print *,'quality of SFC sum(diff_valancy(:)-1):',sum(diff_valancy(:)-1)
                                   print *,'quality of SFC sum(min(2,diff_valancy(:))-1):',sum(min(2,diff_valancy(:))-1)
                                end do
                    
                                level=3
                                print *,'subdomains for level',level,' :'
                                do i=1,10000
                                   nsplt=i
                                   if(2**nsplt>=nonods) exit
                                end do
                    !            nsplt=nsplt+1
                                nlevel=nsplt
                                idivid = 2**(nlevel-level+1) 
                                print *,'idivid=',idivid
                                do icurve=1,ncurve
                                   print *,'ncurve_whichd for curve:', icurve,' :'
                                   do j=1,ny
                                      PRINT *, ( (ncurve_whichd( (j-1)*nx +1: j*nx, icurve)-1) / idivid ) +1
                                   end do
                                end do
                                   print *,'ncurve_whichd difference:'
                                   do j=1,ny
                                      PRINT *, ((ncurve_whichd( (j-1)*nx +1: j*nx, 1)-1) / idivid ) +1  &
                                            - (((ncurve_whichd( (j-1)*nx +1: j*nx, 2)-1) / idivid ) +1)
                                   end do
                    
                                stop 788
                             else if(.false.) then
                               stop 292
                    !          call python_subdomain_space_filling_curve( whichd,  &
                    !                          space_fill_curve_numbering,  cola,fina, cola,fina, ncola,ncola, nonods, starting_node)
                             else
                    
                    !          print *,'before recbis a:',a
                    
                              call PYTHON_SET_UP_RECBIS(WHICHD, SPLEVS,FINA,COLA, &
                                  &    WNOD,a, havwnod,havmat,iexact, NSPLT,NCOLA,NONODS,na )
                    
                    !          call swap_subdomains(ncola, cola,fina, whichd, nonods,starting_node,nsub)  
                    !          stop 383
                              call space_filling_curve_from_ddm(ncola, cola,fina, whichd, nonods, &
                                              space_fill_curve_numbering,starting_node)
                             endif
                    
                    
                    
                    !              &    NSPLT,NCOLA,NONODS, havwnod,WNOD,exact, havmat,a )
                    
                    
                              PRINT *,'MAXVAL(WHICHD(:)):',MAXVAL(WHICHD(:))
                    
                              ISUB_MAX=0
                              ISUB_MIN=100000000
                              DO ISUB=1,MAXVAL(WHICHD(:))
                                 COUNT=0
                                 DO NOD=1,NONODS
                                    IF(WHICHD(NOD).EQ.ISUB) COUNT = COUNT+1
                                 END DO
                    !             PRINT *,'ISUB,COUNT:',ISUB,COUNT
                                 ISUB_MAX=MAX(ISUB_MAX,COUNT)
                                 ISUB_MIN=MIN(ISUB_MIN,COUNT)
                              END DO
                              PRINT *,'ISUB_MAX, ISUB_MIN:',ISUB_MAX, ISUB_MIN
                    
                    !          PRINT *,'WHICHD:',WHICHD
                              print *,'nonods=',nonods
                              PRINT *,'WHICHD:'
                    
                              do j=1,ny
                                 PRINT *,WHICHD( (j-1)*nx +1: j*nx)
                              end do
                    
                    ! 
                    !          ndim=2
                    !          call space_filling_curve_from_ddm(ncola, cola,fina, whichd, nonods, x_all, ndim, &
                    !                          space_fill_curve_numbering)
                    ! impove subdomains for space filling curve generation. 
                              PRINT *,'after optimizing WHICHD:'
                    
                              do j=1,ny
                                 PRINT *,WHICHD( (j-1)*nx +1: j*nx)
                              end do
                              print *,'space_fill_curve_numbering:'
                              do j=1,ny
                                 PRINT *,space_fill_curve_numbering( (j-1)*nx +1: j*nx)
                              end do
                    
                    
                              STOP
                    !          END PROGRAM MAIN
                              END SUBROUTINE MAIN2
                    ! 
                    ! 
                    ! Python interface: 
                    ! dg_2_cty, no_dg_nods_at_cty_nods, findm_cty,colm_cty,ncolm_cty, nonods_cty 
                    ! = dg_to_cty_sparcity( provided_dg_2_cty, findm_dg,colm_dg, coordinates_dg, provided, provided_nonods_cty, ncolm_dg, nonods_dg ) 
                          subroutine dg_to_cty_sparcity( dg_2_cty, no_dg_nods_at_cty_nods, findm_cty,colm_cty,ncolm_cty, nonods_cty, &
                                 provided_dg_2_cty, findm_dg,colm_dg, coordinates_dg, provided, provided_nonods_cty, ncolm_dg, nonods_dg ) 
                    ! *************************************************************************************
                    ! ****This sub calculates the sparcity of the cty mesh from the dg mesh sparcity ****** 
                    ! *************************************************************************************
                    ! the inputs: 
                    ! findm_dg,colm_dg contain the compact row storage of the DG stencil provided to this sub.
                    ! ncolm_dg = length of colm_dg. 
                    ! nonods_dg = no of DG nodes for the problem = totele*nloc
                    ! coordinates_dg = spatial coordinates
                    ! provided =1 then assume we provide dg_2_cty & nonods_cty rather than calculate them. 
                    ! these variables are in: provided_dg_2_cty,provided_nonods_cty 
                    ! provided=0 then assume we calculate them internally and they appear in dg_2_cty, nonods_cty. 
                    ! 
                    ! the outputs (calculated here): 
                    ! dg_2_cty(nod_dg) = continuous node for a given DG node nod_dg.
                    ! no_dg_nods_at_cty_nods(nod_cty)= the number of DG nodes at continuous node CTY. 
                    ! cty variables...
                    ! findm_cty,colm_cty contain the compact row storage of the cty stencil calculated by this sub.
                    ! ncolm_cty = length of colm_cty. 
                    ! nonods_cty = no of cty nodes for the problem 
                          implicit none
                          integer, INTENT(IN) :: nonods_dg, ncolm_dg
                          integer, INTENT(IN) :: findm_dg(nonods_dg+1),colm_dg(ncolm_dg) 
                          real, INTENT(IN) :: coordinates_dg(nonods_dg,3) 
                          integer, INTENT(IN) :: provided
                          integer, INTENT(IN) :: provided_nonods_cty, provided_dg_2_cty(nonods_dg) 
                          integer, intent(out) :: dg_2_cty(nonods_dg) ! dg node to cty node
                          integer, intent(out) :: no_dg_nods_at_cty_nods(nonods_dg) ! no_cty_nods_at_dg_nods(cty_nod) =no of DG nodes that share a cty nod (cty_nod)
                          integer, INTENT(OUT) :: findm_cty(nonods_dg+1),colm_cty(ncolm_dg)
                          integer, INTENT(OUT) :: nonods_cty, ncolm_cty
                    ! Local variables
                          real toler
                          parameter(toler=1.e-5) 
                          integer, allocatable :: no_cty_nods_surrounded_by_dg_nods(:)
                          integer, allocatable :: no_cty_nods_rows(:)
                          integer, allocatable :: findm_cty_initial(:),colm_cty_initial(:), i_list(:)
                          integer ncolm_cty_initial
                          integer mx_i_list, no_cty_nods, i_dg_nod, n_list, i_cty_nod, count_dg
                          integer j_dg_nod, j_cty_nod, nrow, isearch, i
                          real coord_dg(3), coord_dg2(3) 
                          logical found
                    
                          mx_i_list=10000
                          allocate(i_list(mx_i_list))
                    ! form dg_2_cty...
                          if(provided.ne.0) then
                             nonods_cty=provided_nonods_cty
                             dg_2_cty(1:nonods_dg) = provided_dg_2_cty(1:nonods_dg)
                          else ! if(provided) then
                             dg_2_cty(:)=0
                    
                             no_cty_nods=0
                    
                             do i_dg_nod=1,nonods_dg
                                coord_dg(:)=coordinates_dg(i_dg_nod,:)
                                n_list=0
                                i_cty_nod=0
                                do count_dg=findm_dg(i_dg_nod),findm_dg(i_dg_nod+1)-1
                                   j_dg_nod=colm_dg(count_dg)
                                   coord_dg2(:)=coordinates_dg(j_dg_nod,:)
                                   if( sum(abs(coord_dg(:)-coord_dg2(:))) < toler) then ! same point. 
                                      n_list=n_list+1
                                      i_list(n_list)=j_dg_nod
                                      i_cty_nod=max(i_cty_nod, dg_2_cty(j_dg_nod) )
                                   endif
                                end do
                    
                                if(i_cty_nod==0) then ! generate a new cty node...
                                   no_cty_nods=no_cty_nods+1 
                                   dg_2_cty(i_dg_nod)=no_cty_nods
                                   do i=1,n_list
                                     j_dg_nod =i_list(i)
                                     dg_2_cty(j_dg_nod)=no_cty_nods
                                   end do
                                end if ! if(i_cty_nod==0) then
                             end do ! do i_dg_nod=1,nonods_dg
                    
                             nonods_cty=no_cty_nods
                          end if ! if(provided) then else
                    
                    ! form findm_cty, colm_cty...
                    
                    ! form no_cty_nods_at_dg_nods...
                          no_dg_nods_at_cty_nods=0 !no_dg_nods_at_cty_nods(1:nonods_cty)=0
                          do i_dg_nod=1,nonods_dg
                             i_cty_nod = dg_2_cty(i_dg_nod)
                             no_dg_nods_at_cty_nods(i_cty_nod) = no_dg_nods_at_cty_nods(i_cty_nod) +1 
                          end do
                    ! 
                    ! find: no_cty_nods_surrounded_by_dg_nods - the max no of dg nodes surrounding a continuous node. 
                          allocate(no_cty_nods_surrounded_by_dg_nods(nonods_cty)) 
                          no_cty_nods_surrounded_by_dg_nods(:) = 0
                          do i_dg_nod=1,nonods_dg
                             i_cty_nod = dg_2_cty(i_dg_nod)
                             no_cty_nods_surrounded_by_dg_nods(i_cty_nod) = no_cty_nods_surrounded_by_dg_nods(i_cty_nod) &
                                     + findm_dg(i_dg_nod+1)-findm_dg(i_dg_nod) 
                          end do
                    ! 
                    ! find findm_cty_initial
                          allocate(findm_cty_initial(nonods_cty+1)) 
                          findm_cty_initial(1)=1
                          do i_cty_nod=2,nonods_cty+1
                             findm_cty_initial(i_cty_nod) = findm_cty_initial(i_cty_nod-1) + no_cty_nods_surrounded_by_dg_nods(i_cty_nod-1)
                          end do
                          ncolm_cty_initial=findm_cty_initial(nonods_cty+1)-1
                          allocate(colm_cty_initial(ncolm_cty_initial))
                    ! 
                          allocate(no_cty_nods_rows(nonods_cty)) 
                          no_cty_nods_rows(:) = 0
                          do i_dg_nod=1,nonods_dg
                             i_cty_nod = dg_2_cty(i_dg_nod)
                             do count_dg=findm_dg(i_dg_nod),findm_dg(i_dg_nod+1)-1
                                j_dg_nod=colm_dg(count_dg)
                                j_cty_nod = dg_2_cty(j_dg_nod)
                    ! is j_cty_nod in list
                                found=.false. 
                                do isearch=1,no_cty_nods_rows(i_cty_nod)
                                   if( colm_cty_initial( findm_cty_initial(i_cty_nod)-1 + isearch) == j_cty_nod) found=.true.
                                end do
                                if(.not.found) then
                                   no_cty_nods_rows(i_cty_nod)=no_cty_nods_rows(i_cty_nod)+1
                                   colm_cty_initial( findm_cty_initial(i_cty_nod)-1 + no_cty_nods_rows(i_cty_nod)) = j_cty_nod
                                endif 
                             end do
                          end do
                    ! 
                    ! define findm_cty, colm_cty from: no_cty_nod_rows & colm_cty_initial ***
                    ! find findm
                          findm_cty(1)=1
                          do i_cty_nod=2,nonods_cty+1
                             findm_cty(i_cty_nod) = findm_cty(i_cty_nod-1) + no_cty_nods_rows(i_cty_nod-1)
                          end do
                          ncolm_cty=findm_cty(nonods_cty+1)-1
                    ! form colm_cty
                          do i_cty_nod=1,nonods_cty
                             nrow = findm_cty(i_cty_nod+1) - findm_cty(i_cty_nod)
                             colm_cty( findm_cty(i_cty_nod) : findm_cty(i_cty_nod+1)-1 ) &
                               = colm_cty_initial( findm_cty_initial(i_cty_nod) : findm_cty_initial(i_cty_nod) + nrow -1 )
                    ! perform bubble sort to sort each row in increasing node order. 
                             call gem_ibuble(colm_cty( findm_cty(i_cty_nod) : findm_cty(i_cty_nod+1)-1 ),nrow )
                          end do
                    !       
                          end subroutine dg_to_cty_sparcity
                    
                           
                    
                    ! 
                    ! findm,colm,ncolm = form_spare_matric_from_pts( coordinates, nonods )
                          subroutine form_spare_matric_from_pts( findm,colm,ncolm, coordinates, nonods )
                    ! findm,colm contain the compact row storage of the DG stencil calculated by this sub.
                    ! ncolm = length of colm. 
                    ! nonods = no of DG nodes for the problem = totele*nloc
                    ! coordinates = spatial coordinates
                          implicit none
                          integer, INTENT(IN) :: nonods
                          integer, INTENT(OUT) :: findm(nonods+1),colm(nonods*5*4),ncolm
                          real, INTENT(IN) :: coordinates(nonods,3) 
                    ! Local variables
                          integer idim,num_x,num_y,num_z,ii,jj,kk,isearch,k, count,count2, ihit, ele_k,ele_j, nsur,nloc,totele, iii,ncol_search
                          integer ele_j2,j,j2,jloc,k2,kele,kloc,ncolm0,ndim,nod_j,nod_k,kkloc,ecount,icon,ih
                          real min_norm_dist,max_x_all(3),min_x_all(3)
                          logical d3,found
                          real, allocatable :: x_all(:,:)
                          integer, allocatable :: count_struc(:,:,:), fin_search(:),col_search(:), findrm0(:),colm0(:), ele_nab(:,:), ele_count(:)
                    
                          ALLOCATE(x_all(3,nonods) )
                          x_all(1,:)=coordinates(:,1); x_all(2,:)=coordinates(:,2); x_all(3,:)=coordinates(:,3)
                    
                          do idim=1,3
                             max_x_all(idim) = maxval(x_all(idim,:)) 
                             min_x_all(idim) = minval(x_all(idim,:))  
                          end do
                    
                    ! set up simple search ***************************
                          num_x=201
                          num_y=201
                          num_z=101
                          if(max_x_all(3)-min_x_all(3) < 1.e-8) num_z=1
                          allocate(count_struc(num_x,num_y,num_z))
                          count_struc=0
                    
                    ! find list of nodes in each cell
                          do k=1,nonods
                             ii = 1 + int(  ((x_all(1,k)-min_x_all(1))/(max_x_all(1)-min_x_all(1))) *  float(num_x) )
                             jj = 1 + int(  ((x_all(2,k)-min_x_all(2))/(max_x_all(2)-min_x_all(2))) *  float(num_y) )
                             kk = 1 + int(  ((x_all(3,k)-min_x_all(3))/max(1.e-8, max_x_all(3)-min_x_all(3)) ) *  float(num_z) )
                             ii=min(num_x,max(1,ii)); jj=min(num_y,max(1,jj)); kk=min(num_z,max(1,kk))
                             count_struc(ii,jj,kk)= count_struc(ii,jj,kk) + 1
                          end do
                    
                          allocate(fin_search(num_x*num_y*num_z+1))
                          count = 0
                          do kk =1,num_z
                             do jj =1,num_y
                                do ii =1,num_x 
                                   isearch = (kk-1)*num_x*num_y + (jj-1)*num_x + ii
                                   fin_search(isearch) = count + 1
                    !               if(isearch==20300) print *,'0 - count_struc(ii,jj,kk):',count_struc(ii,jj,kk)
                    !               if(isearch==20301) print *,'1 - count_struc(ii,jj,kk):',count_struc(ii,jj,kk)
                    !               if(isearch==20302) print *,'2 - count_struc(ii,jj,kk):',count_struc(ii,jj,kk)
                                   count = count + count_struc(ii,jj,kk)
                                end do
                             end do
                          end do
                    !         print *,'maxval(count_struc(:,:,:)),minval(count_struc(:,:,:)):',maxval(count_struc(:,:,:)),minval(count_struc(:,:,:))
                    !         print *,'count,num_x*num_y*num_z:',count,num_x*num_y*num_z
                    !         print *,'fin_search(20301),fin_search(20302):',fin_search(20301),fin_search(20302)
                    !        stop 27
                          fin_search( num_x*num_y*num_z + 1 ) = count +1
                          ncol_search=count
                    
                          allocate( col_search(ncol_search) )
                          col_search = 0
                          do k =1, NONODS
                             ii = 1 + int(  ((x_all(1,k)-min_x_all(1))/(max_x_all(1)-min_x_all(1))) *  float(num_x) )
                             jj = 1 + int(  ((x_all(2,k)-min_x_all(2))/(max_x_all(2)-min_x_all(2))) *  float(num_y) )
                             kk = 1 + int(  ((x_all(3,k)-min_x_all(3))/max(1.e-8, max_x_all(3)-min_x_all(3)) ) *  float(num_z) )
                             ii=min(num_x,max(1,ii)); jj=min(num_y,max(1,jj)); kk=min(num_z,max(1,kk))
                             isearch = (kk-1)*num_x*num_y + (jj-1)*num_x + ii
                      
                             do count=fin_search(isearch),  fin_search(isearch+1) -1
                                 if( col_search( count) == k) exit
                                 if( col_search( count) == 0) then
                                    col_search( count )= k
                                    exit
                                 endif
                             end do ! do count=fin_search(isearch),  fin_search(isearch+1) -1
                          end do ! do k =1, NONODS
                    ! end set up simple search***************************
                    
                          d3=  (   (maxval(x_all(3,:))-minval(x_all(3,:))) > 1.e-8   ) ! is this a 2d or 3d simulation.
                    !      print *,'d3,num_z:',d3,num_z
                    !      stop 282
                    !      d3= ( num_z > 1) 
                          ndim=2; if(d3) ndim=3 ! number of dimensions - 2d or 3d
                          nloc=ndim+1 ! no of local nodes per element
                          nsur=ndim+1 ! no of elements surround an element
                          totele = nonods/nloc
                    
                    ! form simple set of pointers 1st.
                          allocate(findrm0(nonods+1), colm0(nloc*(nsur+1)*nonods) ) 
                          count=0
                          do k=1,nonods
                             kele=1 + (k-1)/nloc
                             FINDRM0(k) = count+1
                    !         do kloc=1,nloc 
                    !            count=count+1
                    !            colm0(count) = kloc + (kele-1)*nloc
                    !         end do
                    
                    ! calculate normalization distance from this node k to the other nodes of the element
                             kkloc = k - (kele-1)*nloc 
                             min_norm_dist = 1.e+15 ! determine approx min distance to other nodes of element
                             do kloc=1,kkloc-1,1
                                kk=(kele-1)*nloc +kloc
                                min_norm_dist = min( min_norm_dist, sum(abs( x_all(:,k)-x_all(:,kk) ) ) )
                             end do
                             do kloc=kkloc+1,nloc,1 
                                kk=(kele-1)*nloc +kloc
                                min_norm_dist = min( min_norm_dist, sum(abs( x_all(:,k)-x_all(:,kk) ) ) )
                             end do
                    
                             ii = 1 + int(  ((x_all(1,k)-min_x_all(1))/(max_x_all(1)-min_x_all(1))) *  float(num_x) )
                             jj = 1 + int(  ((x_all(2,k)-min_x_all(2))/(max_x_all(2)-min_x_all(2))) *  float(num_y) )
                             kk = 1 + int(  ((x_all(3,k)-min_x_all(3))/max(1.e-8, max_x_all(3)-min_x_all(3)) ) *  float(num_z) )
                             ii=min(num_x,max(1,ii)); jj=min(num_y,max(1,jj)); kk=min(num_z,max(1,kk))
                    
                             isearch = (kk-1)*num_x*num_y + (jj-1)*num_x + ii
                             do count2=fin_search(isearch), fin_search(isearch+1) - 1
                                kk = col_search(count2) 
                    ! Find close nodes
                    !            if(sum( (x_all(:,k)-x_all(:,kk))* (x_all(:,k)-x_all(:,kk)) )< 1.e-3*min_norm_dist ) then
                                if(sum( abs(x_all(:,k)-x_all(:,kk)) )< (1.e-3)*min_norm_dist ) then
                                   if(k.ne.kk) then
                                      count=count+1
                                      COLM0(count)=kk
                                   endif
                                endif
                             end do ! do count2=fin_search(isearch), fin_search(isearch+1) - 1
                          end do
                    
                          FINDRM0(nonods+1)=count+1
                          NCOLM0=count
                    
                    !      stop 3
                    
                    ! now form the extended element-wise equivalent connectivity from COLM0 and FINDRM0
                          allocate(ele_nab(totele,5)); ele_nab(:,:) = 0
                          do ele_k=1,totele
                             ele_nab(ele_k,1)=ele_k
                          end do
                          allocate(ele_count(totele)); ele_count(:) = 1 
                    
                    ! 1st find element-wise connectivity
                          count=0
                          do ele_k = 1, totele
                          do kloc = 1, nloc
                             k = kloc +  (ele_k-1)*nloc
                             do ecount = FINDRM0(k), FINDRM0(k+1) -1
                                j=COLM0(ecount) 
                                ele_j = 1 + (j-1)/nloc
                    ! have we got element ele_j in the list 
                                found = .false. 
                                do icon=1,ele_count(ele_k) 
                                   if( ele_nab(ele_k,icon) == ele_j) found = .true.
                                end do
                    
                                if(.not.found) then
                    ! Do elements ele_k and ele_j have next to one another nloc-1 nodes are shared.
                    
                                   ihit=0
                                   do kkloc = 1, nloc
                                      kk = kkloc +  (ele_k-1)*nloc
                                      ih=0
                                      do count2 = FINDRM0(kk), FINDRM0(kk+1)-1 
                                         j2 = COLM0(count2) 
                                         
                                         ele_j2 = 1 + (j2-1)/nloc
                                         if(ele_j2==ele_j) ih=1  
                                      end do  
                                      ihit=ihit+ih
                                   end do 
                    
                                   if(ihit == nloc-1) then
                                      ele_count(ele_k) = ele_count(ele_k)+1
                                      ele_nab(ele_k, ele_count(ele_k)) = ele_j
                                   endif
                                endif ! if(.not.found) then
                    
                             end do ! do ele_count = FINDRM0(k), FINDRM0(k+1) -1
                          end do ! do kloc=1,nloc
                          end do ! do ele_k = 1, totele
                    
                          deallocate(findrm0,colm0)
                    !      stop 2921
                    
                    ! from element connectivity form the node connectivity. 
                          count=0
                          do ele_k=1,totele 
                    !         print *,'ele_k,ele_count(ele_k):',ele_k,ele_count(ele_k)
                    !         print *,'ele_nab(ele_k, :):',ele_nab(ele_k, :)
                             do kloc=1,nloc
                                nod_k = (ele_k-1)*nloc + kloc 
                                findm(nod_k)=count+1
                                do iii=1,5
                                   ele_j=ele_nab(ele_k, iii)
                                   if(ele_j.ne.0) then
                    ! form pointer list between ele_k and ele_j
                                      do jloc=1,nloc
                                         nod_j = (ele_j-1)*nloc + jloc 
                                         count=count+1
                                         colm(count)=nod_j
                                      end do
                                   endif ! f(ele_j.ne.0) then
                                end do ! do iii=1,5
                             end do ! do kloc=1,nloc
                          end do ! do ele_k=1,totele
                          findm(nonods+1) = count+1
                          ncolm = count
                    !      print *,'ncolm,nonods,20*nonods:',ncolm,nonods,20*nonods
                    ! arrange colns in colm in assending order with bubble sort
                          do k=1,nonods
                    !         print *,'k,findm(k),findm(k+1)-findm(k):',k,findm(k),findm(k+1)-findm(k)
                             call gem_ibuble(colm(findm(k)),findm(k+1)-findm(k)) 
                    !         print *,'colm:',(colm(count),count=findm(k),findm(k+1)-1)
                          end do
                    !      print *,'finished'
                                      
                          return
                          end subroutine form_spare_matric_from_pts
                    ! 
                    ! 
                    ! 
                    
                              subroutine calc_diff_valancy(diff_valancy, space_fill_curve_numbering, &
                                           cola,fina, nonods,ncola )
                    ! *******************************************************************************************************
                    ! calculate how far the nearest neighbour is on the oroginal mesh through the space filling curve.
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola
                              INTEGER, INTENT(out) :: diff_valancy(nonods)
                              INTEGER, INTENT(in) :: space_fill_curve_numbering(nonods)
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                    ! Local variables 
                    ! if use_starting_node then the starting node is the end of the previous space filling curve
                              integer new_nod, old_nod,count, min_diff,max_diff, col, new_nod2
                              integer ny,nx,j
                    
                              do old_nod=1,nonods
                                 new_nod=space_fill_curve_numbering(old_nod)
                                 min_diff=nonods
                                 max_diff=-nonods
                                 do count=fina(old_nod),fina(old_nod+1)-1
                                    col=cola(count) 
                                    new_nod2 = space_fill_curve_numbering(col)
                    !                if(col.ne.old_nod) then
                                        if( new_nod2-new_nod>0 ) min_diff=min(min_diff, new_nod2-new_nod )
                                        if( new_nod2-new_nod<0 ) max_diff=max(max_diff, new_nod2-new_nod )
                    !                endif
                                 end do
                                 if(new_nod==1) then
                                    diff_valancy(old_nod) = abs(min_diff) 
                                 else if(new_nod==nonods) then
                                    diff_valancy(old_nod) = abs(max_diff) 
                                 else
                                    diff_valancy(old_nod) = max( abs(min_diff), abs(max_diff) )
                                 endif
                    !                diff_valancy(old_nod) = min_diff
                              end do ! do old_nod=1,nonods
                              if(.false.) then
                               nx=4
                               ny=4
                               print *,'diff:'
                                   do j=1,ny
                                      PRINT *,diff_valancy( (j-1)*nx +1: j*nx)
                                   end do
                               stop 383
                              endif
                    
                              end subroutine calc_diff_valancy
                    
                    
                    
                    
                              subroutine ncurve_space_filling_curve_long_vec( long_ncurve_space_fill_curve_numbering, long_new2old, &
                                               long_nonods, ncurve_space_fill_curve_numbering, cola,fina, nonods,ncola, ncurve )
                    ! *******************************************************************************************************
                    ! trim the space filling curve to remove issolated nodes and if continuous SFC then only have 1 start and finish node.
                    ! long_ncurve_space_fill_curve_numbering contains the long vector of new numbering. 
                    ! It also form ncurve space filling curves and puts them in ncurve_space_fill_curve_numbering(nod,icurve)
                    ! in which nod is the node number (original) and icurve is the space filling curve (SFC) number.
                    ! long_nonods = length of long_ncurve_space_fill_curve_numbering - its max value is nonods*ncurve.
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola,ncurve
                              INTEGER, INTENT(out) :: long_nonods
                              INTEGER, INTENT(out) :: long_ncurve_space_fill_curve_numbering(nonods*ncurve)
                              INTEGER, INTENT(out) :: long_new2old(nonods*ncurve)
                              INTEGER, INTENT(in) :: ncurve_space_fill_curve_numbering(nonods,ncurve)
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                    ! Local variables 
                    ! if use_starting_node then the starting node is the end of the previous space filling curve
                              integer icurve, new_nod, old_nod,count, col, istart, new_nod2, new_nod_col
                              logical isolated_node
                              INTEGER, ALLOCATABLE :: new2old(:)
                    
                    !          print *,'just inside ncurve_space_filling_curve_long_vec'
                              allocate(new2old(nonods)) 
                    
                              do old_nod = 1, nonods
                                 new_nod2=ncurve_space_fill_curve_numbering(old_nod,1)
                                 long_new2old(new_nod2) = old_nod
                              end do 
                              new_nod2=nonods
                              long_ncurve_space_fill_curve_numbering(1:nonods)=ncurve_space_fill_curve_numbering(1:nonods,1)
                    
                              do icurve=2,ncurve
                                 do old_nod=1,nonods
                                    new_nod = ncurve_space_fill_curve_numbering(old_nod,icurve)
                                    new2old(new_nod) = old_nod
                                 end do 
                                 istart=1
                    ! miss out node if the end of the last SFC is the same node as the start of the current CSFC
                                 if(long_ncurve_space_fill_curve_numbering(new_nod2)==ncurve_space_fill_curve_numbering(1,icurve)) istart=2
                                 do new_nod=istart,nonods
                    ! see if we have an issolated node. 
                                    old_nod = new2old(new_nod) 
                                    isolated_node=.true.
                    !                new_nod = ncurve_space_fill_curve_numbering(old_nod,icurve)
                                    do count=fina(old_nod),fina(old_nod+1)-1
                                       col=cola(count) 
                                       new_nod_col = ncurve_space_fill_curve_numbering(col,icurve)
                                       if( abs( new_nod_col - new_nod)==1) then 
                                          isolated_node=.false.
                                       endif
                                    end do
                                    if(.not.isolated_node) then
                                       new_nod2=new_nod2+1
                                       long_ncurve_space_fill_curve_numbering(new_nod2)=ncurve_space_fill_curve_numbering(old_nod,icurve)
                                       long_new2old(new_nod2) = old_nod
                                    endif
                                 end do
                              end do ! do icurve=1,ncurve
                              long_nonods=new_nod2
                    !          print *,'just leaving ncurve_space_filling_curve_long_vec'
                    
                              end subroutine ncurve_space_filling_curve_long_vec
                    
                    
                              subroutine testing2331
                              print *,'inside subroutine testing2331'
                              end subroutine testing2331
                    
                    
                              subroutine ncurve_python_subdomain_space_filling_curve( ncurve_whichd,  &
                               ncurve_space_fill_curve_numbering,  cola,fina, iuse_starting_node, graph_trim, ncurve, nonods,ncola)
                    ! *******************************************************************************************************
                    ! This subroutine uses nested disection of the domain into subdomains in order to form 
                    ! a space filling curve: space_fill_curve_numbering. whichd contains the subdomain ordering.
                    ! It also form ncurve space filling curves and puts them in ncurve_space_fill_curve_numbering(nod,icurve)
                    ! in which nod is the node number (original) and icurve is the space filling curve number.
                    ! If iuse_starting_node>0 then use the starting node from the end of the previous space filling curve. 
                    ! If iuse_starting_node=-1 then use the rapid method within the existing routines (RECOMMENDED)
                    ! abs(graph_trim) is the graph trimming option for >1 space filling curve numbers. 
                    ! abs(graph_trim)>3 and <9 are use all the graph trimming (original method).
                    ! if graph_trim<0 use a matrix a and set to large values the graph weights we want to discoursage going through.
                    !          no_trim=.false.; trimmed_graph_for_decomposition_only=.false.; trimmed_graph_for_reorder_only=.false.
                    !          duplicate=.false.; got_a_matrix=.false.
                    !          if(abs(graph_trim)==0).or.(abs(graph_trim)==10)) no_trim=.true.
                    !          if((abs(graph_trim)==1).or.(abs(graph_trim)==2)) then
                    !             trimmed_graph_for_decomposition_only=.true.
                    !             if(abs(graph_trim)==1) duplicate=.true.
                    !          endif
                    !          if(abs(graph_trim)==3) trimmed_graph_for_reorder_only=.true.
                    ! abs(trim_graph)=0 or abs(graph_trip)10 dont trim graph. 
                    ! graph_trim=1 then extended cola to duplicate connections and mimick greater weights for domain decomp only.
                    ! graph_trim=2 trim graph only for domain decomposition
                    ! graph_trim=3 trim graph only for re-ordering optimization (no as good) 
                    ! graph_trim>=4 trim graph for decomposition and reordering. 
                    ! graph_trim=100 then use fast SFC finding method. 
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: iuse_starting_node, graph_trim, ncurve, nonods,ncola
                              INTEGER, INTENT(out) :: ncurve_whichd(nonods,ncurve)
                              INTEGER, INTENT(out) :: ncurve_space_fill_curve_numbering(nonods,ncurve)
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                    
                    ! Local variables 
                              logical weights_from_curve_no
                              parameter( weights_from_curve_no=.true. ) ! form the weights for the graph partitioning based on previous differences from the SFC node no.  
                              logical no_trim, trimmed_graph_for_decomposition_only, trimmed_graph_for_reorder_only
                              logical use_starting_node, found, no_trim_row, duplicate, got_a_matrix
                              logical rapid_method
                    !          parameter( use_starting_node=.true. )
                    !          parameter( use_starting_node=.false. )
                    ! if use_starting_node then the starting node is the end of the previous space filling curve
                              integer ncola2,ncola3,count3, icurve, old_nod,count, new_nod1,new_nod2, col, starting_node
                              integer new_nod, starting_node2, max_diff, col2, count2, iexpand, igot_a_matrix, na
                              integer irapid_within
                              INTEGER, ALLOCATABLE :: fina2(:),fina3(:), cola2(:),cola3(:), new2old(:), old_nod_valancy(:)
                              real, ALLOCATABLE :: a(:)
                    
                    ! graph trimming options
          print *,'just inside ncurve_python_subdomain_space_filling_curve'
                              no_trim=.false.; trimmed_graph_for_decomposition_only=.false.; trimmed_graph_for_reorder_only=.false.
                              duplicate=.false.; got_a_matrix=.false.
                              if((abs(graph_trim)==0).or.(abs(graph_trim)==10)) no_trim=.true.
                              if((abs(graph_trim)==1).or.(abs(graph_trim)==2)) then
                                 trimmed_graph_for_decomposition_only=.true.
                                 if(abs(graph_trim)==1) duplicate=.true.
                              endif
                              rapid_method=.false.
                              if(graph_trim==100) rapid_method=.true.
                              if(abs(graph_trim)==3) trimmed_graph_for_reorder_only=.true.
                              iexpand=1
                              if(duplicate) iexpand=2*ncurve
                    
                              if(graph_trim<0) got_a_matrix=.true.
                              igot_a_matrix=0
                              if(got_a_matrix) igot_a_matrix=1
                              na = ncola*igot_a_matrix
                              allocate(a(na)) 
                              if(got_a_matrix) then
                                 a=1.0
                                 do old_nod=1,nonods
                                    do count=fina(old_nod),fina(old_nod+1)-1
                                       col=cola(count)
                                       if(col==old_nod) a(count)=0.1
                                    end do
                                 end do
                              endif
                    !          print *,'here 1'
                    
                              allocate(fina2(nonods+1),fina3(nonods+1), cola2(iexpand*ncola),cola3(iexpand*ncola) )
                              allocate(new2old(nonods), old_nod_valancy(nonods) )
                              ncola2=ncola
                              cola2(1:ncola2)=cola(1:ncola2)
                              fina2=fina
                              starting_node=0
                    
                              use_starting_node = (iuse_starting_node>0) 
                              irapid_within=0
                              if(iuse_starting_node<0) irapid_within=1
                    
                              do icurve=1,ncurve
                    !             print *,'--icurve=',icurve 
                    
                                 if(rapid_method) then ! CPU rapid method - trim decomposition and re-ordering...
                    !               print *,'here 1.4'
                                    call form_sfc_fast(ncurve_space_fill_curve_numbering(:,icurve), &
                                                       fina2,cola2,nonods,ncola2) 
                                 else if(no_trim) then
!               print *,'here 1.1'
                                    call python_subdomain_space_filling_curve( ncurve_whichd(:,icurve),  &
                                     ncurve_space_fill_curve_numbering(:,icurve), a, cola,fina, cola,fina, &
                                     starting_node, irapid_within, ncola, na, ncola, nonods)
                                 else if(trimmed_graph_for_decomposition_only) then
                    ! original trim - only trim decomposition...
                    !               print *,'here 1.2'
                                    call python_subdomain_space_filling_curve( ncurve_whichd(:,icurve),  &
                                     ncurve_space_fill_curve_numbering(:,icurve), a, cola,fina, cola2,fina2, & 
                                     starting_node, irapid_within, ncola2, na, ncola, nonods)
                                 else if(trimmed_graph_for_reorder_only) then
                    ! otherway around -only trim reordering...
                    !               print *,'here 1.3'
                                    call python_subdomain_space_filling_curve( ncurve_whichd(:,icurve),  &
                                     ncurve_space_fill_curve_numbering(:,icurve), a, cola2,fina2, cola,fina, &
                                     starting_node, irapid_within, ncola, na, ncola2, nonods)
                                 else ! original method - trim decomposition and re-ordering...
                    !               print *,'here 1.4'
                                    call python_subdomain_space_filling_curve( ncurve_whichd(:,icurve),  &
                                     ncurve_space_fill_curve_numbering(:,icurve), a, cola2,fina2, cola2,fina2, &
                                     starting_node, irapid_within, ncola2, na, ncola2, nonods)
                                 endif
                    !               print *,'here 2-1'
                    ! take away the edges from cola2,fina2 which have space filling curve icurve associated with them
                                 if(icurve.ne.ncurve) then
                    ! calculate valancy
                                    do old_nod=1,nonods
                                       count3=0 
                                       do count=fina2(old_nod),fina2(old_nod+1)-1
                                          col=cola2(count)
                                          if(col.ne.old_nod) count3=count3+1
                                       end do
                                       old_nod_valancy(old_nod) = count3
                                    end do
                    ! set the valancy to zero around the end of the last new_nod
                    !                if(use_starting_node) then
                                    if(.false.) then
                                       do old_nod=1,nonods
                                          new_nod = ncurve_space_fill_curve_numbering(old_nod,icurve) 
                                          if(new_nod==nonods) then 
                                          old_nod_valancy(old_nod) = 0
                                          do count=fina2(old_nod),fina2(old_nod+1)-1
                                             col=cola2(count)
                                             do count2=fina2(col),fina2(col+1)-1
                                                col2=cola2(count2)
                    !                            new_nod2 = ncurve_space_fill_curve_numbering(col2,icurve) 
                                                old_nod_valancy(col2) = 0
                                             end do
                                          end do
                                          endif
                                        end do
                                     endif
                                       
                    ! trim down the graph or expand it...
                    !             print *,'old_nod_valancy:',old_nod_valancy
                    !                print *,'here 2'
                                    count3=0
                                    do old_nod=1,nonods
                                       new_nod1 = ncurve_space_fill_curve_numbering(old_nod,icurve) 
                                       fina3(old_nod)=count3+1
                    ! dont trim if we have less than or equal to 3 edge connections (avoids issolated nodes)...
                                       do count=fina2(old_nod),fina2(old_nod+1)-1
                                          col=cola2(count)
                                          new_nod2 = ncurve_space_fill_curve_numbering(col,icurve) 
                                       if(duplicate) then ! duplicate the edge so has a weight of 2
                                          if( abs( new_nod1-new_nod2 ) .ne. 1 )  then ! no direct connection in space filling curve so extend graph...
                                              count3=count3+1
                                              cola3(count3) = col
                    !                      else
                    !                          print *,'trim'
                                          else ! direct connection so expand by two...
                                              count3=count3+1
                                              cola3(count3) = col
                    !                          if(.false.) then ! dont duplicate the diagonal
                                              if(col.ne.old_nod) then ! dont duplicate the diagonal
                                                 count3=count3+1
                                                 cola3(count3) = col
                                                 count3=count3+1
                                                 cola3(count3) = col
                                                 count3=count3+1
                                                 cola3(count3) = col
                                              endif
                                          endif
                                       else
                                          no_trim_row = (old_nod_valancy(old_nod) <=3) .or. (old_nod_valancy(col) <=3) 
                                          if(no_trim_row .or. ( abs( new_nod1-new_nod2 ) .ne. 1 ) ) then ! no direct connection in space filling curve so extend graph...
                                              count3=count3+1
                                              cola3(count3) = col
                    !                      else
                    !                          print *,'trim'
                                          endif
                                       endif ! if(duplicate) then else
                                       end do ! do count=fina2(old_nod),fina2(old_nod+1)-1
                                       if(got_a_matrix) then
                                          do count=fina(old_nod),fina(old_nod+1)-1
                                             col=cola(count)
                                             if(weights_from_curve_no) then
                                                max_diff =  maxval( abs(  ncurve_space_fill_curve_numbering(col,1:icurve) &
                                                                        - ncurve_space_fill_curve_numbering(old_nod,1:icurve) )  ) 
                    !                            a(count) = max( 1.0, ( real(abs( new_nod1-new_nod2 )) )**0.5 )
                    !                            if(ncurve==-2) then
                    !                               a(count) = max( 1.0, sqrt(real(max_diff)) )
                    !                            else
                    !                               a(count) = max( 1.0, (real(max_diff))**0.3333 ) ! 0.3333 is a heristic value
                    !                               a(count) = max( 1.0, (real(max_diff))**0.25 ) ! 0.25 is a heristic value
                    !                               a(count) = max( 1.0, (real(max_diff))**0.2 ) ! 0.2 is a heristic value
                    ! 0.3 is good for 256, 0.7 for 64
                    !                               a(count) = max( 0.1, (real(max_diff))**0.5 ) ! 0.2 is a heristic value
                                                   a(count) = max( 0.1, (real(max_diff))**0.2 ) ! 0.2 is a heristic value
                    !                               a(count) = max( 0.1, max(10.0, (real(max_diff))**0.7) ) ! 0.2 is a heristic value
                    !                               a(count) = max( 0.1, min( (real( max(0.0, max_diff+3.5)))**0.2, 55.25) ) ! 0.2 is a heristic value
                    !                               a(count) = max( 0.1, (real(max_diff))**0.1125 ) ! 0.2 is a heristic value
                    !                               a(count) = max( 1.0, (real(max_diff))**0.175 ) ! 0.2 is a heristic value
                    !                               a(count) = max( 1.0, (real(max_diff))**0.15 ) ! 0.2 is a heristic value
                    !                            endif
                                             else
                                                new_nod2 = ncurve_space_fill_curve_numbering(col,icurve) 
                                                if( abs( new_nod1-new_nod2 ) .ne. 1 )  then ! no direct connection in space filling curve so normal weight.
                                                   a(count) = 1.0
                                                else ! is direct connection in space filling curve so have large weight in a matrix...
                                                   a(count) = 2.0
                    !                            a(count) = 1000.0
                    !                            a(count) = 2.
                    !                            a(count) = 1.025
                                                endif
                                             endif
                                          end do
                                       endif
                                    end do ! do old_nod=1,nonods
                                    ncola3=count3
                                    fina3(nonods+1)=count3+1
                    ! redefine cola2
                                    cola2(1:ncola3) = cola3(1:ncola3)
                                    ncola2=ncola3
                                    fina2=fina3
                    ! starting node is the end of the previous space filling curve
                                    if(use_starting_node) then 
                                    if(duplicate) then
                                       do old_nod=1,nonods
                                          new_nod = ncurve_space_fill_curve_numbering(old_nod,icurve) 
                                          if(new_nod==nonods) then
                                             starting_node2=old_nod
                                             max_diff=0
                                             do count=fina(starting_node2), fina(starting_node2+1)-1
                                                col=cola(count)
                                                new_nod2=ncurve_space_fill_curve_numbering(col,icurve) 
                    !                            if(abs(new_nod2-new_nod)<nonods*15/16) then
                                                if(abs(new_nod2-new_nod)>max_diff) then
                                                if(new_nod2.ne.new_nod) then
                                                   max_diff=abs(new_nod2-new_nod)
                                                   starting_node=col
                                                endif
                                                endif 
                    !                            endif 
                                             end do
                                          endif ! if(new_nod==nonods) then
                                       end do
                    !                   print *,'starting_node,old_nod:',starting_node,old_nod
                                    else
                                       do old_nod=1,nonods
                                          new_nod = ncurve_space_fill_curve_numbering(old_nod,icurve) 
                                          new2old(new_nod) = old_nod
                                       end do
                                       do new_nod=nonods,1,-1
                                          old_nod=new2old(new_nod) 
                    ! dont start with issolated nodes...
                                          if( fina2(old_nod+1)-fina2(old_nod) > 1 ) then
                                             starting_node2 = old_nod
                    ! redefine starting node as a node next to it (starting_node2) that is not on previous space filling curve.
                                             max_diff=0
                                             do count=fina2(starting_node2), fina2(starting_node2+1)-1
                                                col=cola2(count)
                                                new_nod2=ncurve_space_fill_curve_numbering(col,icurve) 
                    !                            if(abs(new_nod2-new_nod)<nonods*15/16) then
                                                if(abs(new_nod2-new_nod)>max_diff) then
                                                   max_diff=abs(new_nod2-new_nod)
                                                   starting_node=col
                                                endif 
                    !                            endif 
                                             end do
                                             if(max_diff<=1) then ! could not find anything try with whole graph
                                                do count=fina(starting_node2), fina(starting_node2+1)-1
                                                   col=cola(count)
                                                   new_nod2=ncurve_space_fill_curve_numbering(col,icurve) 
                                                   if(abs(new_nod2-new_nod)>max_diff) then
                                                      max_diff=abs(new_nod2-new_nod)
                                                      starting_node=col
                                                   endif 
                                                end do
                                             endif
                                             if(max_diff<=1) starting_node=starting_node2
                                             exit
                                          endif 
                                       end do
                                    endif ! if(duplicate) then else
                                    endif ! if(use_starting_node) then
                                 endif ! if(icurve.ne.ncurve) then
                                 
                              end do ! do icurve=1,ncurve
                    !          print *,'here 2'
                              end subroutine ncurve_python_subdomain_space_filling_curve
                    
                    
                    ! Python interface is: 
                    ! nod2sfc_ordering = form_sfc_fast(fina,cola,nonods,ncola) 
                          subroutine form_sfc_fast(nod2sfc_ordering, fina,cola,nonods,ncola) 
                          implicit none
                    !*--SPLIT387
                    !*** Start of declarations inserted by SPAG
                          integer, intent( in ) :: nonods, ncola 
                          integer, intent( in ) :: fina(nonods+1),cola(ncola)
                          integer, intent( out ) :: nod2sfc_ordering(nonods)
                    !*** End of declarations inserted by SPAG
                    ! nod2sfc_ordering(fem node number)=i_sfc_order. Here i_sfc_order is the number of the node meansured along 
                    ! the space filling curve trajectory. 
                    ! nonods=number of finite element nodes in the mesh.
                    ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
                    ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
                    ! call in python: nlevel = calculate_nlevel_sfc(nonods). 
                    ! MXNLEV is the maximum number of multi-grid levels. E.G. 4
                    ! NLEVEL is now the number of multi-grid levels e.g. set to 4.
                    ! NONODS=number of vertices or nodes in the graph to be decomposed.
                    ! WHICHD = domain each node belongs too. THE OUTPUT OF THIS SUB
                    ! A contains the edge weights for the graph partitioning and stored
                    ! using compact row storage in FINA,COLA.
                    ! HAVMAT=1 if we strore the matrix.
                    ! ALSO the compact row storage is in FINA, COLA
                    ! RMEM contains a long real working array e.g. NRMEM=100 * NONODS
                    ! Q,QTEMP contains working arrays.
                    ! BETA controls the crytical temp e.g. BETA=0.9
                    ! ALPHA how BETA is annealed donw e.g. ALPHA=0.98
                    ! TOLER tolerence for the iterations e.g. TOLER=1.E-4
                    ! NCHAIN =maximum no of iterations 3000 is suggested.
                    ! MAXTOT=3*nonods is default.
                    ! IF EXACT balce the no of nodes in each subdomain.
                    ! MAXTOT is the maximum value of TOTNOD allowed.
                          integer, dimension(:), allocatable :: cgrid(:),fin_nonods(:),fina_all_nonods(:)
                          integer, dimension(:), allocatable :: fina_all(:),cola_all(:)
                          integer ncola_all, nonods_all, nlevel 
                          integer max_nonods_all, max_ncola_all, max_nlevel
                    ! 
                          max_nonods_all=5*nonods + 500
                          max_ncola_all=5*ncola
                          max_nlevel=100
                          allocate(cgrid(max_nonods_all),fin_nonods(max_nlevel+1))
                          allocate(fina_all_nonods(max_nlevel+1))
                          allocate(fina_all(max_nonods_all+1),cola_all(max_ncola_all))
                    ! 
                    ! form series of matrices.
                          call sfc_fast_matrix_form(cgrid,   &
                                         fin_nonods,fina_all,cola_all,ncola_all, nonods_all, nlevel, &
                                         fina,cola,ncola, nonods, &
                                         max_nonods_all, max_ncola_all, max_nlevel) 
                    ! formed from subroutine split
                    ! 
                    ! form sfc ordering...
                          call form_fast_sfc_from_multi_grids(nod2sfc_ordering, &
                                         nonods_all,nlevel,   &
                                         cgrid, fina_all,cola_all,ncola_all, &
                                         fin_nonods, &
                                         fina,cola,nonods,ncola)
                    ! 
                          end subroutine form_sfc_fast
                    ! 
                    ! 
                    ! 
                    ! 
                          subroutine form_fast_sfc_from_multi_grids(nod2sfc_ordering, &
                                         nonods_all,nlevel,   &
                                         cgrid, fina_all,cola_all,ncola_all, &
                                         fin_nonods, &
                                         fina,cola,nonods,ncola) 
                    ! formed from subroutine split
                          implicit none
                    !*--SPLIT387
                    !*** Start of declarations inserted by SPAG
                          integer, intent( in ) :: ncola_all, nonods_all, nlevel, nonods, ncola 
                          integer, intent( out ) :: nod2sfc_ordering(nonods)
                          integer, intent( in ) :: cgrid(nonods_all) 
                          integer, intent( in ) :: fin_nonods(nlevel+1)
                          integer, intent( in ) :: fina_all(nonods_all+1)
                          integer, intent( in ) :: cola_all(ncola_all)
                          integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    
                    ! nod2sfc_ordering(fem node number)=i_sfc_order. Here i_sfc_order is the number of the node meansured along 
                    ! the space filling curve trajectory. 
                    ! fin_sfc_nonods(ilevel)=the start of course level ilevel and there 
                    ! are nlevel grids from course to fine. 
                    ! nonods_sfc_all_grids=total number of nodes all in all the grid levels. 
                    ! if(iscale_matrices==1) then assume the matricies have been divided through by mass matrix.
                    ! i_jacobi_on_finest_sfc=1 include sfc relaxation on finnest grid, =0 dont.
                    ! i_jacobi_full_matrix=1 then include Jacobi relaxation on full matrix, =0 dont.
                    ! Default values: iscale_matrices=0, i_jacobi_on_finest_sfc=0, i_jacobi_full_matrix=1
                    ! one must have either i_jacobi_on_finest_sfc=1 and/or i_jacobi_full_matrix=1
                    ! 
                    ! ml is a vector possibly contsining the mass assocated with each cell/node of the original finite mesh. 
                    ! nod2sfc_ordering(i_sfc_order)=fem node number. Here i_sfc_order is the number of the node meansured along 
                    ! the space filling curve trajectory. 
                    ! nonods=number of finite element nodes in the mesh.
                    ! max_nonods_sfc_all_grids = max number of nodes e.g. use 4*nonods.
                    ! max_nlevel= max number of grid levels(e.g.=100). It can also be calculated from the subroutine  
                    ! call in python: nlevel = calculate_nlevel_sfc(nonods)
                    ! 
                    ! fina,cola, ncola are used to define the sparcity pattern of the matrix. 
                    ! ncola=number of potentially none-zeros in the nonods*nonods matrix a.  
                    ! cola(count)=coln of the matrix a associated with entry count of matrix a - that is a(count).  
                    ! fina(inod) start of the inod row of a matrix.
                    ! SUPPOSE THE MESH COMPRISSES OF 2 RECTANGULAR ELEMENTS AS BELOW...
                    !      1-----2-----3
                    !      !     !     !
                    !      !     !     !        ndglno(1:4)=4,5,1,2                ndglno(5:8)=5,6,2,3
                    !      4-----5-----6
                    ! THEN THE MATRIX HAS THE FORM (X is a non-zero entry in the matrix):
                    !           1  2  3  4  5  6 - column
                    ! row 1    (X  X  0  X  X  0)
                    ! row 2    (X  X  X  X  X  X)
                    ! row 3    (0  X  X  0  X  X)
                    ! row 4    (X  X  0  X  X  0)
                    ! row 5    (X  X  X  X  X  X)
                    ! row 6    (0  X  X  0  X  X)
                    ! The comparact row storage only stores the non-zeros. 
                    ! cola(1 )=1, cola(2 )=2, cola(3 )=4, cola(4 )=5,                                *****row 1   fina(1)=1
                    ! cola(5 )=1, cola(6 )=2, cola(7 )=3, cola(8 )=4, cola(9 )=5, cola(10)=6,        *****row 2   fina(2)=5
                    ! cola(11)=2, cola(12)=3, cola(13)=5, cola(14)=6,                                *****row 3   fina(3)=11
                    ! cola(15)=1, cola(16)=2, cola(17)=4, cola(18)=5,                                *****row 4   fina(4)=15
                    ! cola(19)=1, cola(20)=2, cola(21)=3, cola(22)=4, cola(23)=5, cola(24)=6,        *****row 5   fina(5)=19
                    ! cola(25)=2, cola(26)=3, cola(27)=5, cola(28)=6                                 *****row 6   fina(6)=25
                    !                                               
                    ! local storage...
                          integer, dimension(:), allocatable :: mark
                          integer, dimension(:), allocatable :: nod2sfc_ordering_all, inv_nod2sfc_ordering_all
                          integer, dimension(:), allocatable :: valancy
                          integer, dimension(:), allocatable :: sum_surro_coarse_grid_nods, sum_surro_fine_grid_nods
                          integer, dimension(:), allocatable :: no_surro_coarse_grid_nods
                          integer, dimension(:), allocatable :: no_surro_fine_grid_nods
                          integer, dimension(:), allocatable :: priority_nod_list
                          integer, dimension(:), allocatable :: sum_surr_not_coarse, no_surr_not_coarse
                          integer, dimension(:), allocatable :: coarse_sfc_grid, fine_sfc_grid, fgrid
                    ! non arrays...
                          integer impove_level
                          parameter(impove_level=0) 
                          real toler
                          parameter(toler=1.0e-10) 
                          integer ilevel, inod_all_fine, inod_all_coarse, count, jnod_all_fine, inod_sfc_all
                          integer ifound,jfound,nfound, jjnod_all_fine, jbest
                          integer jjjnod_all_fine, inod_sfc_all_coarse, inod_sfc_all_keep
                          integer nx,ny,j
                          real rprior, rprior_keep, rvalancy
                    ! 
                          allocate(mark(nonods_all), nod2sfc_ordering_all(nonods_all))
                          allocate(inv_nod2sfc_ordering_all(nonods_all))
                          allocate(valancy(nonods_all), sum_surro_coarse_grid_nods(nonods_all))
                          allocate(no_surro_coarse_grid_nods(nonods_all))
                          allocate(sum_surro_fine_grid_nods(nonods_all))
                          allocate(no_surro_fine_grid_nods(nonods_all))
                          allocate(priority_nod_list(nonods))
                          allocate(sum_surr_not_coarse(nonods_all), no_surr_not_coarse(nonods_all) ) 
                          allocate(coarse_sfc_grid(nonods_all), fine_sfc_grid(nonods_all))
                          allocate(fgrid(nonods_all))
                    !      nx=16
                    !      ny=16
                          nx=8
                          ny=8
                    !      nx=4
                    !      ny=4
                          mark=0 
                          nod2sfc_ordering_all=0
                          inv_nod2sfc_ordering_all=0
                          sum_surro_fine_grid_nods=0
                          no_surro_coarse_grid_nods=0
                          sum_surr_not_coarse=0
                          no_surr_not_coarse=0
                          coarse_sfc_grid=0 
                          fine_sfc_grid=0
                          fgrid=0
                    !      print *,'cgrid:',cgrid
                    !      coarse_grid(nonods_all)=nonods_all
                    ! set from the previous courser grid. 
                    !      ilevel=nlevel-1
                    !      inod_sfc_all_fine = fin_nonods(ilevel)
                    !      coarse_sfc_grid(inod_sfc_all_fine)=nonods_all 
                    !      inod_sfc_all_fine = fin_nonods(ilevel) + 1
                    !      coarse_sfc_grid(inod_sfc_all_fine)=0
                          print *,'++++++++++++++++++++++++++++++++++++++++++++'
                          print *,'just inside form_fast_sfc_from_multi_grids'
                    !      inod_all_fine=193
                    !      do count = fina_all(inod_all_fine), fina_all(inod_all_fine+1)-1
                    !         jnod_all_fine = cola_all(count) 
                    !         print *,'inod_all_fine,jnod_all_fine:',inod_all_fine,jnod_all_fine
                    !      end do
                    !      stop 29216
                    ! 
                    ! 
                          do inod_all_fine = 1, nonods_all
                    ! define numbers that are used for ordering...
                             valancy(inod_all_fine) = fina_all(inod_all_fine+1) &
                                                      - fina_all(inod_all_fine)
                             inod_all_coarse = cgrid(inod_all_fine) 
                             if(inod_all_coarse.ne.0) fgrid(inod_all_coarse) = inod_all_fine
                          end do
                    !      print *,'nonods_all, nlevel:', nonods_all, nlevel
                          inv_nod2sfc_ordering_all(nonods_all)=nonods_all
                          nod2sfc_ordering_all(nonods_all)    =nonods_all
                    ! 
                          do ilevel=nlevel-1,1,-1
                    ! calculate coarse_grid 
                    !         print *,'ilevel:',ilevel
                    !         print *,'fin_nonods(ilevel+1)-fin_nonods(ilevel):', &
                    !                  fin_nonods(ilevel+1)-fin_nonods(ilevel)
                             inod_sfc_all = fin_nonods(ilevel)-1 ! beginning of current grid.
                    ! want:   inod_sfc_all_coarse = coarse_sfc_grid(inod_sfc_all_fine)
                    !         do inod_sfc_all_coarse = fin_nonods(ilevel+1), fin_nonods(ilevel+2)-1
                    !            inod_all_coarse = inv_nod2sfc_ordering_all(inod_sfc_all_coarse)
                    !            nod2sfc_ordering_all(inod_all_coarse) = inod_sfc_all_coarse
                    !            print *,'inod_sfc_all_coarse, inod_all_coarse, inod_sfc_all_coarse:', &
                    !                     inod_sfc_all_coarse, inod_all_coarse, inod_sfc_all_coarse
                    !         end do
                             do inod_all_fine = fin_nonods(ilevel), fin_nonods(ilevel+1)-1
                                coarse_sfc_grid(inod_all_fine) = 0
                    !            print *,'inod_all_fine,cgrid(inod_all_fine):',inod_all_fine,cgrid(inod_all_fine)
                             end do
                             do inod_all_fine = fin_nonods(ilevel), fin_nonods(ilevel+1)-1
                    !            inod_all_coarse = inv_nod2sfc_ordering_all(inod_sfc_all_coarse)
                                inod_all_coarse = cgrid(inod_all_fine) 
                    !            print *,'inod_all_fine, inod_all_coarse:',inod_all_fine, inod_all_coarse
                    !            inod_sfc_all_fine = 
                                if(inod_all_coarse.ne.0) then
                                   inod_sfc_all_coarse = nod2sfc_ordering_all(inod_all_coarse)
                                   coarse_sfc_grid(inod_all_fine) = inod_sfc_all_coarse
                                   if(inod_sfc_all_coarse==0) then
                                      print *,'inod_sfc_all_coarse, inod_all_fine:', &
                                               inod_sfc_all_coarse, inod_all_fine
                                      stop 2929
                                   endif
                                   fine_sfc_grid(inod_sfc_all_coarse) = inod_all_fine
                                endif
                             end do
                    ! 
                    !         do inod_all_fine = fin_nonods(ilevel), fin_nonods(ilevel+1)-1
                    ! define numbers that are used for ordering...
                    !            valancy(inod_all_fine) = fina_all(inod_all_fine+1) &
                    !                                     - fina_all(inod_all_fine)
                    !         end do
                    ! 
                             do inod_all_fine = fin_nonods(ilevel),fin_nonods(ilevel+1)-1
                                sum_surro_coarse_grid_nods(inod_all_fine)=0
                                do count=fina_all(inod_all_fine),fina_all(inod_all_fine+1)-1
                                   jnod_all_fine = cola_all(count) 
                    ! define numbers that are used for ordering...
                                   sum_surro_coarse_grid_nods(inod_all_fine) &
                                     =sum_surro_coarse_grid_nods(inod_all_fine)+coarse_sfc_grid(jnod_all_fine)
                                   no_surro_coarse_grid_nods(inod_all_fine) &
                                     =no_surro_coarse_grid_nods(inod_all_fine)+1*min(coarse_sfc_grid(jnod_all_fine),1)
                                end do  
                             end do
                    ! 
                    ! Define ordering based on sum_surro_coarse_grid_nods, sum_surro_fine_grid_nods, surr_not_coarse, valancy
                             do inod_sfc_all_coarse = fin_nonods(ilevel+1), fin_nonods(ilevel+2)-1
                                inod_all_fine = fine_sfc_grid(inod_sfc_all_coarse)
                                inod_sfc_all = inod_sfc_all + 1
                                inod_sfc_all_keep = inod_sfc_all
                                inv_nod2sfc_ordering_all(inod_sfc_all) = inod_all_fine
                    !            print *,'inod_sfc_all,inod_all_fine:',inod_sfc_all,inod_all_fine
                                nod2sfc_ordering_all(inod_all_fine) = inod_sfc_all
                    !            print *,'inod_sfc_all,inod_all_fine:',inod_sfc_all,inod_all_fine
                                mark(inod_all_fine) = 1
                    ! 
                                ifound=0
                                do count = fina_all(inod_all_fine), fina_all(inod_all_fine+1)-1
                                   jnod_all_fine = cola_all(count) 
                                   if(mark(jnod_all_fine)==0) then
                                      ifound = ifound + 1
                                      priority_nod_list(ifound) = jnod_all_fine
                                      sum_surr_not_coarse(jnod_all_fine) = 0
                                      no_surr_not_coarse(jnod_all_fine) = 0
                    !                  print *,'ifound,priority_nod_list(ifound), inod_all_fine,jnod_all_fine:', &
                    !                           ifound,priority_nod_list(ifound), inod_all_fine,jnod_all_fine
                                   endif 
                                end do 
                                nfound=ifound
                    !            print *,'nfound=',nfound
                    !            print *,'priority_nod_list(1:nfound):',priority_nod_list(1:nfound)
                    ! 
                    ! find the best nodes 1st in the SFC in terms of priorities. 
                                do ifound=1,nfound
                    !                       iinod_all_fine = priority_nod_list(ifound)
                    ! find the best - lowest no
                                   rprior_keep=-1.e+10
                                   jbest=0
                                   do jfound = 1, nfound 
                                      jnod_all_fine = priority_nod_list(jfound)
                                      if(mark(jnod_all_fine)==0) then
                                         if(ilevel==1) then
                                            rvalancy = 1.0*valancy(jnod_all_fine) 
                                         else
                    !                 print *,'ilevel,ifound,jfound,nfound,jnod_all_fine,fgrid(jnod_all_fine):', &
                    !                          ilevel,ifound,jfound,nfound,jnod_all_fine,fgrid(jnod_all_fine)
                                            rvalancy = 0.0*valancy(jnod_all_fine) +1.0*valancy(fgrid(jnod_all_fine))
                    !                        rvalancy = 1.0*valancy(jnod_all_fine) !+1.0*valancy(fgrid(jnod_all_fine))
                                         endif
                                 if(ifound==1) then
                                         rprior = +100.0*real( sum_surro_coarse_grid_nods(jnod_all_fine) &
                                                     - inod_sfc_all_coarse*no_surro_coarse_grid_nods(jnod_all_fine) ) &
                                                   /real(toler+no_surro_coarse_grid_nods(jnod_all_fine)) &
                                                 +1.0*real( sum_surr_not_coarse(jnod_all_fine) &
                                                        - inod_sfc_all_keep*no_surr_not_coarse(jnod_all_fine) ) &
                                                 - 100.0*rvalancy
                                 else
                                         rprior = +100.0*real( sum_surro_coarse_grid_nods(jnod_all_fine) &
                                                     - inod_sfc_all_coarse*no_surro_coarse_grid_nods(jnod_all_fine) ) &
                                                   /real(toler+no_surro_coarse_grid_nods(jnod_all_fine)) &
                                                 +100.0*real( sum_surr_not_coarse(jnod_all_fine) &
                                                        - inod_sfc_all_keep*no_surr_not_coarse(jnod_all_fine) ) &
                                                 + 0.01*rvalancy 
                                 endif
                                         if(rprior>rprior_keep) then
                                            jbest=jfound
                                            rprior_keep = rprior
                                         endif
                                      endif ! if(mark(jjnod_all_fine)==0) then
                                   end do ! do jfound=1,nfound
                                   if(jbest.ne.0) then
                                      jnod_all_fine = priority_nod_list(jbest)
                                      inod_sfc_all=inod_sfc_all+1
                                      inv_nod2sfc_ordering_all(inod_sfc_all)=jnod_all_fine
                                      nod2sfc_ordering_all(jnod_all_fine)=inod_sfc_all
                    !            print *,'inod_sfc_all,jnod_all_fine:',inod_sfc_all,jnod_all_fine
                                      mark(jnod_all_fine)=1
                    ! update list of surrounding nodes that are not coarse.
                                      do count=fina_all(jnod_all_fine),fina_all(jnod_all_fine+1)-1
                                         jjnod_all_fine = cola_all(count)
                                         sum_surr_not_coarse(jjnod_all_fine) &
                                            = sum_surr_not_coarse(jjnod_all_fine) + inod_sfc_all
                                         no_surr_not_coarse(jjnod_all_fine) &
                                            = no_surr_not_coarse(jjnod_all_fine) + 1
                                      end do
                                   endif ! if(jbest.ne.0) then
                                end do ! do ifound=1,nfound
                    ! 
                              if(.false.) then
                                if((ilevel==1).and.(inod_sfc_all_coarse == fin_nonods(ilevel+1)+1)) then
                    !            if(ilevel==1) then
                                   print *,'inod_sfc_all_coarse=',inod_sfc_all_coarse
                                   print *,'middle of calculating nod2sfc_ordering_all:'
                                   do j=1,ny
                                      print *,nod2sfc_ordering_all( (j-1)*nx +1: j*nx)
                                   end do
                                   print *,'middle of calculating mark:'
                                   do j=1,ny
                                      print *,mark( (j-1)*nx +1: j*nx)
                                   end do
                                   print *,'middle of calculating valancy:'
                                   do j=1,ny
                                      print *,valancy( (j-1)*nx +1: j*nx)
                                   end do
                                   print *,'middle of calculating sum_surr_not_coarse:'
                                   do j=1,ny
                                      print *,sum_surr_not_coarse( (j-1)*nx +1: j*nx)
                                   end do
                          print *,'sum_surro_coarse_grid_nods/no_surro_coarse_grid_nods:'
                          do j=1,ny
                            print *,real(sum_surro_coarse_grid_nods( (j-1)*nx +1: j*nx)) &
                                     /real(no_surro_coarse_grid_nods( (j-1)*nx +1: j*nx))
                          end do
                    !               stop 282
                                endif
                              endif
                                  
                             end do ! do inod_sfc_all_coarse = fin_nonods(ilevel+1), fin_nonods(ilevel+2)-1
                    ! improve sfc for ilevel
                    ! re-arrange sfc at this level. 
                    !         if(ilevel==1) thennlevel
                             if(impove_level.ne.0) then
                             if(ilevel<nlevel-3     ) then
                    !         if(ilevel==-1) then
                                print *,'improving ilevel,nlevel,fin_nonods(ilevel+1)-fin_nonods(ilevel):', &
                                                   ilevel,nlevel,fin_nonods(ilevel+1)-fin_nonods(ilevel)
                                call level_improvement(nod2sfc_ordering_all,inv_nod2sfc_ordering_all, &
                                         nonods_all,nlevel,ilevel,   &
                                         fina_all,cola_all,ncola_all, &
                                         fin_nonods ) 
                             endif
                             endif
                    
                    !         IF (now) then
                    !             Give_bunnies_a_carrot
                    !         ENDIF
                    ! 
                          end do ! do ilevel=nlevel-1,1,-1
                    ! 
                          nod2sfc_ordering(1:nonods) = nod2sfc_ordering_all(1:nonods) ! define curve on finest grid.
                    
                        if(.false.) then
                          print *,'nx,ny:',nx,ny,'          nod2sfc_ordering:'
                          do j=1,ny
                            print *,nod2sfc_ordering( (j-1)*nx +1: j*nx)
                          end do
                          print *,'cgrid:'
                          do j=1,ny
                            print *,cgrid( (j-1)*nx +1: j*nx)
                          end do
                          print *,'sum_surro_coarse_grid_nods:'
                          do j=1,ny
                            print *,sum_surro_coarse_grid_nods( (j-1)*nx +1: j*nx)
                          end do
                          print *,'no_surro_coarse_grid_nods:'
                          do j=1,ny
                            print *,no_surro_coarse_grid_nods( (j-1)*nx +1: j*nx)
                          end do
                          print *,'sum_surro_coarse_grid_nods/no_surro_coarse_grid_nods:'
                          do j=1,ny
                            print *,real(sum_surro_coarse_grid_nods( (j-1)*nx +1: j*nx)) &
                                     /real(no_surro_coarse_grid_nods( (j-1)*nx +1: j*nx))
                          end do
                          stop 3922
                    ! 
                          print *,'just leaving fast_sfc_from_multi_grids'
                        endif
                    !      stop 3922
                          end subroutine form_fast_sfc_from_multi_grids
                    ! 
                    ! 
                    ! 
                    ! 
                          subroutine sfc_fast_matrix_form(cgrid,   &
                                         fin_nonods,fina_all,cola_all,ncola_all, nonods_all, nlevel, &
                                         fina,cola,ncola, nonods, &
                                         max_nonods_all, max_ncola_all, max_nlevel) 
                    ! formed from subroutine split
                          implicit none
                          integer, intent( in ) :: max_nonods_all, max_ncola_all, max_nlevel
                          integer, intent( in ) :: ncola, nonods
                          integer, intent( in ) :: fina(nonods+1),cola(ncola)
                          integer, intent( out ) :: cgrid(max_nonods_all)
                          integer, intent( out ) :: fin_nonods(max_nlevel+1)
                          integer, intent( out ) :: ncola_all, nonods_all, nlevel
                          integer, intent( out ) :: fina_all(max_nonods_all+1),cola_all(max_ncola_all)
                               
                    !*--SPLIT387
                    !*** Start of declarations inserted by SPAG
                    !*** End of declarations inserted by SPAG
                    ! MXNLEV is the maximum number of multi-grid levels. E.G. 4
                    ! NLEVEL is now the number of multi-grid levels e.g. set to 4.
                    ! NONODS=number of vertices or nodes in the graph to be decomposed.
                    ! A contains the edge weights for the graph partitioning and stored
                    ! using compact row storage in FINA,COLA.
                    ! HAVMAT=1 if we strore the matrix.
                    ! ALSO the compact row storage is in FINA, COLA
                    ! 
                    ! MAXTOT is the maximum value of TOTNOD allowed.
                    ! suggest MAX_mxnlev=100
                    ! local storage...
                          integer, dimension(:), allocatable :: list 
                          integer, dimension(:), allocatable :: q, qtemp 
                          integer, dimension(:), allocatable :: ptcola, nodlev
                          integer, dimension(:), allocatable :: cgrid_prev, fina_prev
                          integer, dimension(:), allocatable :: color
                    ! q,qtemp contains working arrays.
                          real, dimension(:), allocatable :: x, y, a
                    ! 
                          integer maxtot, totnod, maxna, max_mxnlev, havmat
                          integer ilevel, count_displace, inod_all_fine, count, count2, jnod_all_fine
                          integer count3, level_nonods
                    
                          maxna  = 5*ncola
                          maxtot = max_nonods_all
                          max_mxnlev = max_nlevel
                    
                          allocate(list(nonods))
                          allocate(q(nonods), qtemp(nonods) )
                    ! 
                          allocate( ptcola(max_mxnlev+1),nodlev(max_mxnlev+1) )
                          allocate( cgrid_prev(maxtot), fina_prev(maxtot+max_nlevel) )
                          allocate( color(maxtot) )
                          havmat=0
                          allocate(x(maxtot), y(maxtot), a(maxna*havmat))
                    ! 
                          cola_all(1:ncola)=cola(1:ncola) 
                          fina_prev(1:nonods+1)=fina(1:nonods+1) 
                    ! 
                          if(nonods.le.2) then
                    !            PRINT *,'-------SKIPPING DOMAIN DECOMP NONODS=',NONODS
                             if(nonods.ge.1) cgrid_prev(1:nonods)=1
                             if(nonods==2) cgrid_prev(nonods)=2
                             return
                          endif
                    ! 
                            print *,'nonods, max_nonods_all, maxna, max_mxnlev, max_nlevel:', &
                                     nonods, max_nonods_all, maxna, max_mxnlev, max_nlevel
                            print *,'entering forma'
                          call forma(cgrid_prev,maxtot,totnod,nonods,nodlev,ptcola,max_nlevel, & 
                                fina_prev,cola_all,a,maxna,ncola_all,color,q,qtemp,list,x,y, &
                                havmat)
                            print *,'out of forma'
                    ! 
                          deallocate(x,y, color,q,qtemp)
                          do ilevel=1,max_nlevel
                             print *,'ilevel, nodlev(ilevel), nodlev(ilevel+1):', ilevel, nodlev(ilevel), nodlev(ilevel+1)
                    !         print *,'nodlev(ilevel+1) - nodlev(ilevel):',nodlev(ilevel+1) - nodlev(ilevel)
                             if((nodlev(ilevel+1) - nodlev(ilevel))==0) then
                                nlevel=ilevel-1
                                exit
                             endif
                             if(ilevel>2) then
                             if((nodlev(ilevel) - nodlev(ilevel-1))==1) then
                             if((nodlev(ilevel+1) - nodlev(ilevel))==1) then
                                nlevel=ilevel-1
                                exit
                             endif
                             endif
                             endif
                          end do
                          print *,'nlevel=',nlevel
                          nonods_all=nodlev(nlevel+1)-1
                          print *,'nonods_all:',nonods_all
                          cgrid(1:nonods_all)=cgrid_prev(1:nonods_all)
                          cgrid(nonods_all)=0
                    !        print *,'cgrid_prev(1:nonods_all):',cgrid_prev(1:nonods_all)
                    !      print *,'here0.1'
                    !      stop 2821
                    ! Now form the matrices fina_all, cola_all, fin_nonods from fina_prev, cola_prev, nodlev
                          fin_nonods(1) = 1
                          print *,'here0.2'
                          do ilevel=1,nlevel
                             print *,'ilevel=',ilevel
                             level_nonods = nodlev(ilevel+1) - nodlev(ilevel)
                             fin_nonods(ilevel+1) = fin_nonods(ilevel) + level_nonods
                             count_displace = Ptcola(ilevel) - 1
                             count3 = Ptcola(ilevel) - 1
                             print *,'level_nonods,count_displace,count3:',level_nonods,count_displace,count3
                             print *,'fin_nonods(ilevel),fin_nonods(ilevel)+level_nonods:', &
                                      fin_nonods(ilevel),fin_nonods(ilevel)+level_nonods
                             fina_all(fin_nonods(ilevel): fin_nonods(ilevel)+level_nonods) &
                                  = fina_prev(Nodlev(ilevel)+ilevel-1: Nodlev(ilevel)+ilevel-1  +level_nonods) &
                                    + count_displace 
                             print *,'here1 fin_nonods(ilevel),fin_nonods(ilevel+1)-1:', &
                                            fin_nonods(ilevel),fin_nonods(ilevel+1)-1
                             do inod_all_fine = fin_nonods(ilevel), fin_nonods(ilevel+1)-1
                    !            print *,'inod_all_fine:',inod_all_fine
                                if(cgrid(inod_all_fine).ne.0) then
                                if(ilevel.ne.nlevel) then
                                   cgrid(inod_all_fine) = cgrid(inod_all_fine) + fin_nonods(ilevel+1)-1
                                endif
                                endif
                    !            print *,'fina_all(inod_all_fine+1),fina_all(inod_all_fine):', &
                    !                     fina_all(inod_all_fine+1),fina_all(inod_all_fine)
                                do count = fina_all(inod_all_fine), fina_all(inod_all_fine+1)-1
                    ! we overwrite cola_all here with new values. 
                                   count3 = count3 + 1
                                   count2 = count + count_displace - 1
                    !              jnod_all_fine = cola_prev(count) + fin_nonods(ilevel) -1
                                   jnod_all_fine = cola_all(count3) + fin_nonods(ilevel) -1
                                   cola_all(count) = jnod_all_fine
                    !       if(inod_all_fine==193) then
                    !          print *,'inod_all_fine,jnod_all_fine:',inod_all_fine,jnod_all_fine
                    !       endif
                                end do  
                             end do ! do inod_all_fine = fin_nonods(ilevel+1),fin_nonods(ilevel)-1
                    ! 
                    ! 
                          end do ! do ilevel=nlevel,1,-1
                          ncola_all = Ptcola(nlevel+1)-1
                          fina_all(nonods_all+1) = ncola_all + 1 
                    !        print *,'cgrid(1:nonods_all):',cgrid(1:nonods_all)
                          print *,'leaving sfc_fast_matrix_form'
                    !      inod_all_fine=193
                    !      do count = fina_all(inod_all_fine), fina_all(inod_all_fine+1)-1
                    !         jnod_all_fine = cola_all(count) 
                    !         print *,'inod_all_fine,jnod_all_fine:',inod_all_fine,jnod_all_fine
                    !      end do
                    !      stop 16
                          return
                          end subroutine sfc_fast_matrix_form
                    ! 
                    ! 
                    ! 
                    ! 
                              subroutine level_improvement(nod2sfc_ordering_all,inv_nod2sfc_ordering_all, &
                                         nonods_all,nlevel,ilevel,   &
                                         fina_all,cola_all,ncola_all, &
                                         fin_nonods ) 
                    ! formed from subroutine split
                              implicit none
                    !*--SPLIT387
                    !*** Start of declarations inserted by SPAG
                              integer, intent( in ) :: ncola_all, nonods_all, nlevel, ilevel
                              integer, intent( inout ) :: nod2sfc_ordering_all(nonods_all)
                              integer, intent( inout ) :: inv_nod2sfc_ordering_all(nonods_all)
                    !      integer, intent( in ) :: cgrid(nonods_all) 
                              integer, intent( in ) :: fin_nonods(nlevel+1)
                              integer, intent( in ) :: fina_all(nonods_all+1)
                              integer, intent( in ) :: cola_all(ncola_all)
                    !      integer, intent( in ) :: fina(nonods+1), cola(ncola)
                    ! local variables...
                              logical original_method
                              parameter(original_method=.true.)
                              integer, allocatable :: whichd2(:), nod2sfc_ordering2(:)
                              integer, allocatable :: cola2(:), fina2(:)
                              integer i,nsplt,nsub,nonods2, starting_node, ncola2, istart, itry_harder
                              integer inod_all_fine, inod_sfc_all, noptimise
                    
                              nonods2=fin_nonods(ilevel+1)-fin_nonods(ilevel)
                              ncola2=fina_all(fin_nonods(ilevel+1)) - fina_all(fin_nonods(ilevel))
                    ! 
                              allocate(whichd2(nonods2), nod2sfc_ordering2(nonods2))
                              allocate(cola2(ncola2), fina2(nonods2+1) )
                    ! determine cola2, fina2
                              istart=fina_all(fin_nonods(ilevel)) 
                              cola2(1:ncola2) = cola_all(istart:istart +ncola2-1) - fin_nonods(ilevel) + 1
                              fina2(1:nonods2+1) = fina_all(fin_nonods(ilevel): fin_nonods(ilevel) + (nonods2+1)-1) &
                                                 - fina_all(fin_nonods(ilevel)) +1
                    ! 
                              nod2sfc_ordering2(1:nonods2) &
                                 = nod2sfc_ordering_all(fin_nonods(ilevel):fin_nonods(ilevel)+nonods2-1) &
                                 - fin_nonods(ilevel) + 1
                    ! 
                              if(original_method) then
                    ! 
                                 do i=1,10000
                                    nsplt=i
                                    if(2**nsplt>=nonods2) exit
                                 end do
                    !            nsplt=nsplt+1
                    !          nsplt=nsplt-1 ! subtract one so we have more than 1 node per subdomain 
                                 nsub=2**nsplt
                                 print *,'nsub,maxval(nod2sfc_ordering2):',nsub,maxval(nod2sfc_ordering2)
                    !             nsub=maxval(nod2sfc_ordering2)
                                 itry_harder=1
                    !          itry_harder=0
                                 starting_node=0
                    
                                 whichd2 = nod2sfc_ordering2
                                 call improve_subdomains_sfc_ordering(ncola2, cola2,fina2, &
                                          whichd2, nod2sfc_ordering2, nonods2, starting_node, nsub, &
                                          itry_harder  )  
                              else
                                 call find_best_out_of_nopt_sfc_ordering(ncola2, cola2,fina2, &
                                             nod2sfc_ordering2, nonods2, starting_node )  
                              endif
                    ! 
                    ! convert to nod2sfc_ordering_all & inv_nod2sfc_ordering_all
                              istart=fin_nonods(ilevel)
                              nod2sfc_ordering_all(istart:istart + nonods2-1) = nod2sfc_ordering2(1:nonods2) &
                                                                              + fin_nonods(ilevel)-1
                              do inod_all_fine = fin_nonods(ilevel), fin_nonods(ilevel+1)-1
                                 inod_sfc_all=nod2sfc_ordering_all(inod_all_fine) 
                                 inv_nod2sfc_ordering_all(inod_sfc_all)=inod_all_fine
                              end do
                              return 
                              end subroutine level_improvement
                    ! 
                    ! 
                    ! 
                    ! 
                              subroutine python_subdomain_space_filling_curve( whichd,  &
                                space_fill_curve_numbering, a,  cola,fina, cola2,fina2, &
                                starting_node, irapid_within, ncola2, na, ncola, nonods)
                    ! *******************************************************************************************************
                    ! This subroutine uses nested disection of the domain into subdomains in order to form 
                    ! a space filling curve: space_fill_curve_numbering. whichd contains the subdomain ordering.
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).  
                    ! cola2,fina2,ncola2  is for the domain decomposotion. - send down the trimmed graph with multiple space filling curves.
                    ! cola,fina,ncola is for the optimization of the node numbering.
                    ! if irapid_within==1 then use the rapid within this subroutine method to form the SFC. 
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: starting_node, irapid_within, ncola2, na, ncola, nonods
                              INTEGER, INTENT(out) :: whichd(nonods)
                              INTEGER, INTENT(out) :: space_fill_curve_numbering(nonods)
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1), cola2(ncola),fina2(nonods+1)
                              real, INTENT(IN) :: a(na)
                    ! local variables...
                              logical try_harder
                              parameter(try_harder=.true.)
                              integer nsplt,i,iexact,havmat,havwnod,ii,j,nx,ny,nsub
                              logical exact
                              real, allocatable :: wnod(:)
                              integer, allocatable :: SPLEVS(:)
                    
                    ! 2**nsplit=no of subdomains >= nonods 
                              if(.false.) then
                                 nsplt=4
                              else
                                 do i=1,10000
                                    nsplt=i
                                    if(2**nsplt>=nonods) exit
                                 end do
                    !            nsplt=nsplt+1
                              endif
                    !          nsplt=nsplt-1 ! subtract one so we have more than 1 node per subdomain 
                              nsub=2**nsplt
                    !          print *,'nonods,nsplt=',nonods,nsplt
                              allocate(SPLEVS(nsplt)) 
                              SPLEVS(:)=2   
                    
                    ! subdomain options...
                              allocate(wnod(nonods))
                              exact=.true. ! exact node balance in each subdomain
                              iexact=1
                    !          exact=.false. ! exact node balance in each subdomain
                              havmat=0
                              if(na>0) havmat=1
                    !          na=ncola2*havmat+1
                    !          allocate(A(ncola2*havmat+1))
                    !          havwnod=2
                              havwnod=1
                              wnod=1.0
                              ii=1
                    !          na=0   
                    !          print *,'na:',na
                    !          print *,'a:',a
                    
                    !          print *,'here1'
                    
                    !         print *,'before python_set_up_recbis a:',a ! here is good. 
                    !          if(rapid_sfc_method) then
                              if(irapid_within==1) then
                    !             stop 29211
                                 call form_sfc_fast(WHICHD, &
                                                       fina2,cola2,nonods,ncola2) 
                    !             call form_sfc_fast(ncurve_space_fill_curve_numbering(:,icurve), &
                    !                                   fina2,cola2,nonods,ncola2) 
                    !             nsub=maxval(whichd)
                              else
                    
                                 call PYTHON_SET_UP_RECBIS(WHICHD, SPLEVS,FINA2,COLA2, &
                                  &    WNOD,a, havwnod,havmat,iexact, NSPLT,NCOLA2,NONODS,na )
                              endif
                    !          call PYTHON_SET_UP_RECBIS(WHICHD, SPLEVS,FINA,COLA, &
                    !              &    WNOD,a, havwnod,havmat,iexact, NSPLT,NCOLA,NONODS,na )
                    !          print *,'here2'
                    
                              if(.false.) then
                                 print *,'nonods=',nonods
                                 PRINT *,'original WHICHD:'
                                    ny=4
                                    nx=4
                                 if(nonods==4) then
                                    ny=2
                                    nx=2
                                 endif
                    
                                 do j=1,ny
                                    PRINT *,WHICHD( (j-1)*nx +1: j*nx)
                                 end do
                              endif
                              if(try_harder) then
                                 call swap_subdomains_orig(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                              endif
                    !          print *,'here2.5'
                              call swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                    !          print *,'here3'
                             ! go backwards and see if we can improve things...
                              if(try_harder) then
                    !          print *,'here4'
                                 call swap_subdomains_go_backwards(ncola, cola,fina, whichd, nonods, starting_node, nsub) 
                    !          print *,'here5'
                    
                                 call swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub)   
                              endif
                    !  
                    !          print *,'here6'
                              call space_filling_curve_from_ddm(ncola, cola,fina, whichd, nonods, &
                                              space_fill_curve_numbering, starting_node)
                    !          print *,'here7'
                    
                              end subroutine python_subdomain_space_filling_curve
                    ! 
                    ! 
                    ! 
                    ! 
                              subroutine find_best_out_of_nopt_sfc_ordering(ncola, cola,fina, &
                                          space_fill_curve_numbering, nonods, starting_node )  
                    ! *******************************************************************************************************
                    ! This subroutine swaps the subdomains over to achieve a better connectivity for the space filling curves. 
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).  
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola, starting_node
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(inout) :: space_fill_curve_numbering(nonods)
                    ! local variables...
                              integer, allocatable :: inv_space_fill_curve_numbering(:) 
                              integer inod_sfc_start, its,nits,iloop, isumv, isumv2
                              integer inod, inod_sfc
                              integer istart,ifinish,istep, noptimise
                              integer ikeep1_inv, ikeep2_inv, inod_sfc_start_plus1
                              integer ikeep1, ikeep2
                    ! 
                              allocate(inv_space_fill_curve_numbering(nonods) ) 
                    ! 
                              do inod=1,nonods
                                 inod_sfc = space_fill_curve_numbering(inod)
                                 inv_space_fill_curve_numbering(inod) = inod_sfc
                              end do
                    ! 
                              nits=7
                              do its=1,nits
                              do iloop=1,2
                              if(iloop==1) then
                                 istart=1
                                 ifinish=nonods-1
                                 istep=1
                              else
                                 istart=nonods-1
                                 ifinish=1
                                 istep=-1
                              endif
                              do inod_sfc_start=istart,ifinish,istep
                    ! 
                                 noptimise=2
                    ! 
                                 call calc_fun_quality_sfc_segment(isumv, cola, fina, &
                                          inv_space_fill_curve_numbering, space_fill_curve_numbering, &
                                          ncola, nonods, inod_sfc_start, noptimise)
                    ! swap over two values...
                                 inod_sfc_start_plus1 = min(inod_sfc_start+1,nonods)
                                 ikeep1_inv = inv_space_fill_curve_numbering(inod_sfc_start)
                                 ikeep2_inv = inv_space_fill_curve_numbering(inod_sfc_start_plus1)
                                 ikeep1 = space_fill_curve_numbering(ikeep1_inv)
                                 ikeep2 = space_fill_curve_numbering(ikeep2_inv)
                                 inv_space_fill_curve_numbering(inod_sfc_start)       = ikeep2_inv
                                 inv_space_fill_curve_numbering(inod_sfc_start_plus1) = ikeep1_inv
                                 space_fill_curve_numbering(ikeep2_inv) = inod_sfc_start
                                 space_fill_curve_numbering(ikeep1_inv) = inod_sfc_start_plus1
                    ! 
                                 call calc_fun_quality_sfc_segment(isumv2, cola, fina, &
                                          inv_space_fill_curve_numbering, space_fill_curve_numbering, &
                                          ncola, nonods, inod_sfc_start, noptimise)
                    ! 
                                 if(isumv2 > isumv) then ! put it back the way it was...
                    !             if(.true.) then ! put it back the way it was...
                    !             if(isumv2 .le. isumv) then ! put it back the way it was...
                                    inv_space_fill_curve_numbering(inod_sfc_start)       = ikeep1_inv
                                    inv_space_fill_curve_numbering(inod_sfc_start_plus1) = ikeep2_inv
                                    space_fill_curve_numbering(ikeep1_inv) = ikeep1
                                    space_fill_curve_numbering(ikeep2_inv) = ikeep2
                                 endif
                    ! 
                              end do
                              end do
                              end do
                    ! 
                              return 
                              end subroutine find_best_out_of_nopt_sfc_ordering
                    ! 
                    ! 
                    ! 
                    ! 
                              subroutine calc_fun_quality_sfc_segment(isumv, cola, fina, &
                                          inv_space_fill_curve_numbering, space_fill_curve_numbering, &
                                          ncola, nonods, inod_sfc_start, noptimise)
                              implicit none
                              INTEGER, INTENT(IN) :: ncola, nonods, inod_sfc_start, noptimise
                              INTEGER, INTENT(out) :: isumv
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(in) :: inv_space_fill_curve_numbering(nonods)
                              INTEGER, INTENT(in) :: space_fill_curve_numbering(nonods)
                    ! local variables...
                    ! local variables...
                              integer inod_start, its,nits,iloop, min_diff, max_diff, diff_valancy
                              integer inod_sfc, inod, jnod, jnod_sfc, count
                              isumv = 0
                              do inod_sfc = inod_sfc_start, min(inod_sfc_start+noptimise-1, nonods)
                                 inod = inv_space_fill_curve_numbering(inod_sfc)
                                 min_diff = nonods
                                 max_diff = -nonods
                                 do count = fina(inod),fina(inod+1)-1
                                    jnod = cola(count) 
                                    jnod_sfc = space_fill_curve_numbering(jnod)
                    !                if(col.ne.old_nod) then
                                        if( jnod_sfc-inod_sfc>0 ) min_diff=min(min_diff, jnod_sfc-inod_sfc )
                                        if( jnod_sfc-inod_sfc<0 ) max_diff=max(max_diff, jnod_sfc-inod_sfc )
                    !                endif
                                 end do
                                 if(inod_sfc==1) then
                                    diff_valancy = abs(min_diff) 
                                 else if(inod_sfc==nonods) then
                                    diff_valancy = abs(max_diff) 
                                 else
                                    diff_valancy = max( abs(min_diff), abs(max_diff) )
                                 endif
                                 isumv = isumv + diff_valancy
                              end do ! do inod_sfc=inod_start, min(inod_start+noptimise-1, nonods) 
                              return 
                              end subroutine calc_fun_quality_sfc_segment
                    ! 
                    ! 
                    ! 
                    ! 
                              subroutine improve_subdomains_sfc_ordering(ncola, cola,fina, &
                                          whichd, space_fill_curve_numbering, nonods, starting_node, nsub, &
                                          itry_harder  )  
                    ! *******************************************************************************************************
                    ! This subroutine swaps the subdomains over to achieve a better connectivity for the space filling curves. 
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).  
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola, starting_node, nsub, itry_harder
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(inout) :: whichd(nonods), space_fill_curve_numbering(nonods)
                           if(.true.) then
                              if(itry_harder.ne.0) then
                                 call swap_subdomains_orig(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                              endif
                           endif
                    !          print *,'here2.5'
                           if(.true.) then
                              call swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub) 
                           endif 
                    !          print *,'here3'
                             ! go backwards and see if we can improve things...
                           if(.true.) then
                              if(itry_harder.ne.0) then
                    !          print *,'here4' ! this following sub works for new method
                                 call swap_subdomains_go_backwards(ncola, cola,fina, whichd, nonods, starting_node, nsub) 
                    !          print *,'here5'
                    
                           if(.true.) then
                                 call swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                           endif  
                              endif
                           endif
                    !  
                    !          print *,'here6'
                              call space_filling_curve_from_ddm(ncola, cola,fina, whichd, nonods, &
                                              space_fill_curve_numbering, starting_node)
                              return 
                              end subroutine improve_subdomains_sfc_ordering
                    
                    
                    
                    
                              subroutine improve_subdomains_sfc_ordering_orig(ncola, cola,fina, &
                                          whichd, space_fill_curve_numbering, nonods, starting_node, nsub, &
                                          itry_harder  )  
                    ! *******************************************************************************************************
                    ! This subroutine swaps the subdomains over to achieve a better connectivity for the space filling curves. 
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).  
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola, starting_node, nsub, itry_harder
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(inout) :: whichd(nonods), space_fill_curve_numbering(nonods)
                              if(itry_harder.ne.0) then
                                 call swap_subdomains_orig(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                              endif
                    !          print *,'here2.5'
                              call swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                    !          print *,'here3'
                             ! go backwards and see if we can improve things...
                              if(itry_harder.ne.0) then
                    !          print *,'here4'
                                 call swap_subdomains_go_backwards(ncola, cola,fina, whichd, nonods, starting_node, nsub) 
                    !          print *,'here5'
                    
                                 call swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub)   
                              endif
                    !  
                    !          print *,'here6'
                              call space_filling_curve_from_ddm(ncola, cola,fina, whichd, nonods, &
                                              space_fill_curve_numbering, starting_node)
                              return 
                              end subroutine improve_subdomains_sfc_ordering_orig
                    
                    
                    
                    
                              subroutine swap_subdomains(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                    ! *******************************************************************************************************
                    ! This subroutine swaps the subdomains over to achieve a better connectivity for the space filling curves. 
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).  
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola, starting_node, nsub
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(inout) :: whichd(nonods)
                    ! local variables...
                              integer count,nod,col, isub, jsub, new_nod, level, nlevel, ilevel, Nsplt, accum, ii, ndom
                              integer lcount, iisub,iloop, iii, across, inlev, lndom, count2, ntree, sub, super_step, half_super_step
                              integer istart, iend, its, max_in_sub, sub2, f_before, f_after
                              integer min_sub_neigh(2), min_sub_neigh2(2), min_val(2) 
                              integer sub_level ! function 
                              integer nx,ny,i,j,its_outer, start_level
                              logical swap, go_backwards_swaps, found_starting_node(2), got_starting_node
                              INTEGER, ALLOCATABLE :: nodes_in_domain(:), count_in_sub(:)
                              INTEGER, ALLOCATABLE :: max_val(:) 
                     
                              got_starting_node=((starting_node>0).and.(starting_node<nonods+1)) 
                    
                    ! this is not safe nsub=maxval(whichd) 
                    !          nsub=maxval(whichd) 
                              allocate(count_in_sub(nsub) ) 
                    
                    ! calculate nlevel for nested bisection...
                              do ilevel=1,1000
                    !             print *,'ilevel,nsub,2**ilevel:',ilevel,nsub,2**ilevel
                                 if(2**ilevel>=nsub) then
                                    nlevel=ilevel
                                    exit
                                 endif
                              end do
                    !          print *,'nlevel,nsub,2**nlevel=',nlevel,nsub,2**nlevel
                    
                              count_in_sub=0
                              do nod=1,nonods
                                  isub=whichd(nod) 
                                  count_in_sub(isub) = count_in_sub(isub) + 1
                              end do
                              max_in_sub=maxval( count_in_sub )
                              allocate(nodes_in_domain(nsub*max_in_sub) ) 
                    
                    !          do its_outer=1,3
                              do its_outer=1,7
                    
                    !            if(.false.) then
                                if(its>1) then ! reverse ordering
                    !            if(.true.) then ! reverse ordering
                    !               new_whichd=whichd
                                   do nod=1,nonods
                                      whichd(nod) = nsub - whichd(nod) +1
                                   end do
                    !            endif
                                endif
                    
                    ! Form subdomains to nodes list ***************************
                    !          call subs_2_node_list(nonods,nsub, whichd, fin_sub, sub2nod)
                              call simple_subs_2_node_list(nonods, nsub, whichd, max_in_sub, nodes_in_domain, count_in_sub) 
                    ! Form subdomains to nodes list ***************************
                    
                    !             nod=13
                    !             do count2=fina(nod),fina(nod+1)-1
                    !                print *,'cola(count2):',cola(count2)
                    !             end do
                    !                stop 282
                                 
                    
                    !         print *,'** nlevel,nsub=',nlevel,nsub
                              start_level=2
                              if(got_starting_node) start_level=1 ! may need to swap of level 1 subdomains so they contain the starting node 
                    
                              do level = start_level , nlevel 
                    ! go through the 2 bares to see if subdomains are close to one anther otherwise 
                                 super_step=2**(nlevel-level+1)  
                                 half_super_step=super_step/2
                    !             print *,'*** level,nlevel,nsub,super_step,half_super_step:', &
                    !                          level,nlevel,nsub,super_step,half_super_step
                    
                    
                    !          do its=1,2
                    !          do its=1,3
                              do its=1,7
                    
                                 if(.false.) then
                                    ny=4
                                    nx=4
                                    if(nonods==4) then
                                       ny=2
                                       nx=2
                                    endif
                     
                                    do j=1,ny
                                       PRINT *,WHICHD( (j-1)*nx +1: j*nx)
                                    end do
                                 endif
                    !             if(level==3) stop 383
                    
                                 
                                 do sub=1, nsub, super_step  
                          
                                    do iloop=0,1
                                       iisub=iloop+1
                    !                   sub=1*(iloop-1) +
                    !                   sub=1*(iloop-1) + super_step*iloop 
                    
                                       istart=sub*(1-iloop)                     + (sub+half_super_step)*iloop
                                       iend  =(sub+half_super_step-1)*(1-iloop) + (sub+super_step-1)*iloop 
                                       iend = min(iend, nsub) 
                    !                   if(iend>nsub) then
                    !                       print *,'found error swap1'
                    !                       print *,'sub,nsub,istart,half_super_step,super_step:',sub,nsub,istart,half_super_step,super_step
                    !                   endif
                    
                    !                   min_sub_neigh(iisub)=istart 
                                       min_sub_neigh(iisub)=1
                                       min_sub_neigh2(iisub)=nsub
                                       min_val(iisub)=1000000 ! min valancy
                                       found_starting_node(iisub)=.false.
                    
                                       do isub = istart, iend 
                    !                      print *,'iloop,isub:',iloop,isub
                    !                   isub= 1 + iloop*super_step
                    !                      do count=fin_sub(isub),fin_sub(isub+1)-1
                                          do count=max_in_sub*(isub-1)+1, max_in_sub*(isub-1)+count_in_sub(isub) 
                                             nod=nodes_in_domain( count )
                                             if(got_starting_node) then
                                                if(nod==starting_node) found_starting_node(iisub)=.true.
                                             endif
                    !                         print *,'isub,nod:',isub,nod
                                             min_val(iisub) = min( min_val(iisub),  fina(nod+1)-fina(nod) )
                    !                         print *,'isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod):', &
                    !                                  isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod)
                                             do count2=fina(nod),fina(nod+1)-1
                                                col=cola(count2) 
                    !                            print *,'nod,  fina(nod+1)-fina(nod):', nod,  fina(nod+1)-fina(nod)
                                                if(whichd(col)<sub) then
                                                   min_sub_neigh(iisub) = max( min_sub_neigh(iisub), whichd(col) ) 
                                                endif
                                                if(whichd(col)>sub+super_step-1) then
                                                   min_sub_neigh2(iisub) = min( min_sub_neigh2(iisub), whichd(col) ) 
                                                endif
                                             end do ! do count=fina(nod),fina(nod+1)-1
                                          end do ! do count=fin_sub(isub),fin_sub(isub+1)-1
                                       end do ! do isub = istart, iend 
                    
                    
                                   end do ! do iloop=0,1  
                    
                                   if(sub==1) then
                    !                  print *,'here1'
                    
                                   f_before =  &
                                + abs( sub_level( min_sub_neigh2(2),level,nlevel ) - sub_level( sub+half_super_step,level,nlevel) )
                    
                                   f_after =  abs( sub_level( min_sub_neigh2(1),level,nlevel)- sub_level( sub+half_super_step,level,nlevel)  )
                                   if(got_starting_node) then
                                      if(found_starting_node(2)) then ! must swap subdomains so subdomain 1 contains starting nod
                                         f_before=1
                                         f_after=0
                                      endif
                                   endif
                    
                                  else if(sub== nsub-super_step +1) then
                    !                  print *,'here2'
                    
                                   f_before = abs( sub_level( sub,level,nlevel) - sub_level( min_sub_neigh(1),level,nlevel )  ) 
                    
                                   f_after =  &
                                + abs( sub_level( sub,level,nlevel) - sub_level( min_sub_neigh(2),level,nlevel) ) 
                    
                                  else 
                    !                  print *,'here3'
                                   f_before =  abs( sub_level( sub,level,nlevel) - sub_level( min_sub_neigh(1),level,nlevel )  )  &
                                + abs( sub_level( min_sub_neigh2(2),level,nlevel ) - sub_level( sub+half_super_step,level,nlevel) )
                    
                                   f_after =  abs( sub_level( min_sub_neigh2(1),level,nlevel)- sub_level( sub+half_super_step,level,nlevel)  ) &
                                + abs( sub_level( sub,level,nlevel) - sub_level( min_sub_neigh(2),level,nlevel) )
                    
                                  endif
                    
                                   if(f_before >= f_after) then ! swap 2 super-subdomains...
                                 if(.false.) then
                                   print *,'***** its, sub, min_sub_neigh2(:):',its, sub, min_sub_neigh2(:)
                                   print *,'sub_level( min_sub_neigh2(1),level,nlevel ):',sub_level( min_sub_neigh2(1),level,nlevel )
                                   print *,'sub_level( min_sub_neigh2(2),level,nlevel ):',sub_level( min_sub_neigh2(2),level,nlevel )
                                   print *,'min_sub_neigh(:):',min_sub_neigh(:)
                                   print *,'sub_level( min_sub_neigh(1),level,nlevel ):',sub_level( min_sub_neigh(1),level,nlevel )
                                   print *,'sub_level( min_sub_neigh(2),level,nlevel ):',sub_level( min_sub_neigh(2),level,nlevel )
                                   print *,'f_before, f_after:',f_before, f_after
                                   print *,' '
                                 endif
                    
                                      call simple_sub_swap(min(nsub, sub), min(nsub, sub+half_super_step), nsub,nonods,max_in_sub, whichd, &
                                                  nodes_in_domain, count_in_sub )
                    !                  print *,'swap level,its',level,its
                                   endif
                    !
                    ! 
                    
                             end do ! do sub=1, nsub, super_step
                    
                    
                            end do ! do its=1,2
                    
                          end do ! do level = 2 , nlevel - 1
                    
                          end do ! do its_outer=1,3
                    
                            end subroutine swap_subdomains
                    
                    
                    
                    
                              subroutine swap_subdomains_orig(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                    ! *******************************************************************************************************
                    ! This subroutine swaps the subdomains over to achieve a better connectivity for the space filling curves. 
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).   
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola, starting_node, nsub
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(inout) :: whichd(nonods)
                    ! local variables...
                              integer count,nod,col, isub, jsub, new_nod
                              integer level, nlevel, ilevel, Nsplt, accum, ii, ndom
                              integer lcount, iisub,iloop, iii, across, inlev, lndom
                              integer count2, ntree, sub, super_step, half_super_step
                              integer istart, iend, its, max_in_sub, start_level
                              integer min_sub_neigh(2), min_sub_neigh2(2), min_val(2) 
                              logical swap, found_starting_node(2), got_starting_node
                              INTEGER, ALLOCATABLE :: nodes_in_domain(:), count_in_sub(:)
                              INTEGER, ALLOCATABLE :: max_val(:) 
                     
                              got_starting_node=((starting_node>0).and.(starting_node<nonods+1)) 
                    
                    ! this is not safe nsub=maxval(whichd) 
                    !          nsub=maxval(whichd) 
                              allocate(count_in_sub(nsub) ) 
                    
                    ! calculate nlevel for nested bisection...
                              nlevel=0
                              do ilevel=1,1000
                    !             print *,'ilevel,nsub,2**ilevel:',ilevel,nsub,2**ilevel
                                 if(2**ilevel>=nsub) then
                                    nlevel=ilevel
                                    exit
                                 endif
                              end do
                              if(nlevel==0) stop 22
                    !          print *,'nlevel,nsub,2**nlevel=',nlevel,nsub,2**nlevel
                    
                              count_in_sub=0
                              do nod=1,nonods
                                  isub=whichd(nod) 
                                  count_in_sub(isub) = count_in_sub(isub) + 1
                              end do
                              max_in_sub=maxval( count_in_sub )
                              allocate(nodes_in_domain(nsub*max_in_sub) ) 
                    
                    !          do its=1,3
                              do its=1,7
                    
                                if(its>1) then ! reverse ordering
                    !            if(.true.) then ! reverse ordering
                    !               new_whichd=whichd
                                   do nod=1,nonods
                                      whichd(nod) = nsub - whichd(nod) +1
                                   end do
                                endif
                    
                    ! Form subdomains to nodes list ***************************
                    !          call subs_2_node_list(nonods,nsub, whichd, fin_sub, sub2nod)
                              call simple_subs_2_node_list(nonods, nsub, whichd, max_in_sub, nodes_in_domain, count_in_sub) 
                    ! Form subdomains to nodes list ***************************
                    
                    !             nod=13
                    !             do count2=fina(nod),fina(nod+1)-1
                    !                print *,'cola(count2):',cola(count2)
                    !             end do
                    !                stop 282
                                 
                    
                    !         print *,'** nlevel,nsub=',nlevel,nsub
                    !         print *,'** nlevel,nsub=',nlevel,nsub
                              start_level=2
                              if(got_starting_node) start_level=1 ! may need to swap of level 1 subdomains so they contain the starting node 
                    
                              do level = start_level , nlevel 
                    ! go through the 2 bares to see if subdomains are close to one anther otherwise 
                                 super_step=2**(nlevel-level+1)  
                                 half_super_step=super_step/2
                    !             print *,'level,nlevel,nsub,super_step,half_super_step:', &
                    !                      level,nlevel,nsub,super_step,half_super_step
                                 
                    
                                 do sub=1, nsub, super_step        
                                    do iloop=0,1
                                       iisub=iloop+1
                    !                   sub=1*(iloop-1) +
                    !                   sub=1*(iloop-1) + super_step*iloop 
                    
                                       istart=sub*(1-iloop)                     + (sub+half_super_step)*iloop
                                       iend  =(sub+half_super_step-1)*(1-iloop) + (sub+super_step-1)*iloop 
                                       iend = min(iend, nsub) 
                    !                   if(iend>nsub) then
                    !                       print *,'found error swap2'
                    !                       print *,'sub,nsub,istart,half_super_step,super_step:',sub,nsub,istart,half_super_step,super_step
                    !                   endif
                    
                    !                   min_sub_neigh(iisub)=istart 
                                       min_sub_neigh(iisub)=0
                                       min_sub_neigh2(iisub)=nsub
                                       min_val(iisub)=1000000 ! min valancy
                                       found_starting_node(iisub)=.false.
                    
                                       do isub = istart, iend 
                    !                      print *,'iloop,isub:',iloop,isub
                    !                   isub= 1 + iloop*super_step
                    !                      do count=fin_sub(isub),fin_sub(isub+1)-1
                                          do count=max_in_sub*(isub-1)+1, max_in_sub*(isub-1)+count_in_sub(isub) 
                                             nod=nodes_in_domain( count )
                                             if(got_starting_node) then
                                                if(nod==starting_node) found_starting_node(iisub)=.true.
                                             endif
                    !                         print *,'isub,nod:',isub,nod
                                             min_val(iisub) = min( min_val(iisub),  fina(nod+1)-fina(nod) )
                    !                         print *,'isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod):', &
                    !                                  isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod)
                                             do count2=fina(nod),fina(nod+1)-1
                                                col=cola(count2) 
                    !                            print *,'nod,  fina(nod+1)-fina(nod):', nod,  fina(nod+1)-fina(nod)
                                                if(whichd(col)<sub) then
                                                   min_sub_neigh(iisub) = max( min_sub_neigh(iisub), whichd(col) ) 
                                                endif
                                                if(whichd(col)>sub+super_step-1) then
                                                   min_sub_neigh2(iisub) = min( min_sub_neigh2(iisub), whichd(col) ) 
                                                endif
                                             end do ! do count=fina(nod),fina(nod+1)-1
                                          end do ! do count=fin_sub(isub),fin_sub(isub+1)-1
                                       end do ! do isub = istart, iend 
                    
                                   end do ! do iloop=0,1  
                    
                                   swap=.false.
                    !               if( (level==nlevel).and.(sub==1 )) then
                                   if( sub==1 ) then
                    !                  print *,'*****************'
                                      if((its==1).and.(min_val(2)< min_val(1) )) swap=.true.
                                      if(found_starting_node(2)) swap=.true.
                    !                  if(min_val(1)< min_val(2) ) swap=.true.
                                   else if((its==1).and.(min_sub_neigh(2)>min_sub_neigh(1) )) then ! original
                                       swap=.true.
                    !               else if(min_sub_neigh(2)>min_sub_neigh(1) ) then ! original
                                   else if((its>1).and.(min_sub_neigh(2) + min_sub_neigh2(2) >= min_sub_neigh(1) + min_sub_neigh2(1) )) then ! the best
                    !               else if((its>1).and.(  max( sub-min_sub_neigh(2), min_sub_neigh2(2)-(sub+super_step-1)) &
                    !                                    > max( sub-min_sub_neigh(1), min_sub_neigh2(1)-(sub+super_step-1)) )) then
                    !               else if(min_sub_neigh(1)>min_sub_neigh(2) ) then
                                       swap=.true.
                    !               else if( (min_sub_neigh(2)==min_sub_neigh(1)).and.(min_val(2)<min_val(1)) ) then
                                   else if( .false. ) then
                    !               else if(min_sub_neigh(1)>min_sub_neigh(2) ) then
                                       swap=.true.
                                   endif
                    !            if(sub==3) then
                    !               print *,'**********sub:', sub
                    !               print *,'min_val(1),min_val(2):', min_val(1),min_val(2)
                    !               print *,'min_sub_neigh(1),min_sub_neigh(2):', min_sub_neigh(1),min_sub_neigh(2)
                    !               print *,'swap:',swap
                    !            endif
                    !               stop 292
                                   if(swap) then
                    !                  print *,'swapping its,sub,sub+half_super_step:',its,sub,sub+half_super_step
                    !                  stop 261
                    !                  call sub_swap(sub,sub+half_super_step, nsub,nonods, whichd, fin_sub, sub2nod) 
                                      call simple_sub_swap(min(nsub, sub), min(nsub, sub+half_super_step), nsub,nonods,max_in_sub, whichd, &
                                                  nodes_in_domain, count_in_sub )
                                   endif
                    
                             end do ! do sub=1, nsub, super_step
                          end do ! do level = 3 , nlevel - 1
                    
                            end do ! do its=1,2
                    
                            end subroutine swap_subdomains_orig
                    
                    
                    
                    
                    
                              subroutine swap_subdomains_go_backwards(ncola, cola,fina, whichd, nonods, starting_node, nsub)  
                    ! *******************************************************************************************************
                    ! This subroutine swaps the subdomains over to achieve a better connectivity for the space filling curves.  
                    ! *******************************************************************************************************
                              implicit none
                              INTEGER, INTENT(IN) :: nonods,ncola, starting_node, nsub
                              INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1)
                              INTEGER, INTENT(inout) :: whichd(nonods)
                    ! local variables...
                              integer count,nod,col, isub, jsub, new_nod, level, nlevel, ilevel, Nsplt, accum, ii, ndom
                              integer lcount, iisub,iloop, iii, across, inlev, lndom, count2, ntree, sub, super_step, half_super_step
                              integer istart, iend, its, max_in_sub, sub2
                              integer min_sub_neigh(2), min_sub_neigh2(2), min_val(2) 
                              integer sub_level ! function 
                              integer nx,ny,i,j, start_level
                              logical swap, go_backwards_swaps, found_starting_node(2), found_starting_node2(2)
                              logical got_starting_node
                              INTEGER, ALLOCATABLE :: nodes_in_domain(:), count_in_sub(:)
                              INTEGER, ALLOCATABLE :: max_val(:) 
                    
                              got_starting_node=((starting_node>0).and.(starting_node<nonods+1)) 
                    
                    ! this is not safe nsub=maxval(whichd) because it can return a number less than 2**nlevel
                    !          nsub=maxval(whichd) 
                              allocate(count_in_sub(nsub) ) 
                    
                    ! calculate nlevel for nested bisection...
                              do ilevel=1,1000
                    !             print *,'ilevel,nsub,2**ilevel:',ilevel,nsub,2**ilevel
                                 if(2**ilevel>=nsub) then
                                    nlevel=ilevel
                    !                print *,'inside exit'
                                    exit
                                 endif
                              end do
                    
                    !          print *,'nlevel,nsub,2**nlevel=',nlevel,nsub,2**nlevel
                    
                              count_in_sub=0
                              do nod=1,nonods
                                  isub=whichd(nod) 
                                  count_in_sub(isub) = count_in_sub(isub) + 1
                              end do
                              max_in_sub=maxval( count_in_sub )
                              allocate(nodes_in_domain(nsub*max_in_sub) ) 
                    
                    !          do its=1,2
                    !          do its=1,3
                              do its=1,7
                    !          do its=1,100
                    
                    !            if(.false.) then
                                if(its>100) then ! reverse ordering
                    !            if(.true.) then ! reverse ordering
                    !               new_whichd=whichd
                                   do nod=1,nonods
                                      whichd(nod) = nsub - whichd(nod) +1
                                   end do
                                endif
                    !            endif
                    
                    ! Form subdomains to nodes list ***************************
                    !          call subs_2_node_list(nonods,nsub, whichd, fin_sub, sub2nod)
                              call simple_subs_2_node_list(nonods, nsub, whichd, max_in_sub, nodes_in_domain, count_in_sub) 
                    ! Form subdomains to nodes list ***************************
                    
                    !             nod=13
                    !             do count2=fina(nod),fina(nod+1)-1
                    !                print *,'cola(count2):',cola(count2)
                    !             end do
                    !                stop 282
                                 
                    
                    !         print *,'** nlevel,nsub=',nlevel,nsub
                    !         print *,'** nlevel,nsub=',nlevel,nsub
                              start_level=2
                              if(got_starting_node) start_level=1 ! may need to swap of level 1 subdomains so they contain the starting node 
                    
                              do level = start_level , nlevel 
                    ! go through the 2 bares to see if subdomains are close to one anther otherwise 
                                 super_step=2**(nlevel-level+1)  
                                 half_super_step=super_step/2
                    !             print *,'*** level,nlevel,nsub,super_step,half_super_step:', &
                    !                          level,nlevel,nsub,super_step,half_super_step
                    
                                 if(.false.) then
                                    ny=4
                                    nx=4
                                    if(nonods==4) then
                                       ny=2
                                       nx=2
                                    endif
                     
                                    do j=1,ny
                                       PRINT *,WHICHD( (j-1)*nx +1: j*nx)
                                    end do
                                 endif
                    
                                 
                                 do sub=1, nsub, super_step  
                          
                                    do iloop=0,1
                                       iisub=iloop+1
                    !                   sub=1*(iloop-1) +
                    !                   sub=1*(iloop-1) + super_step*iloop 
                    
                                       istart=sub*(1-iloop)                     + (sub+half_super_step)*iloop
                                       iend  =(sub+half_super_step-1)*(1-iloop) + (sub+super_step-1)*iloop 
                                       iend = min(iend, nsub) 
                    !                   if(iend>nsub) then
                    !                       print *,'found error swap3'
                    !                       print *,'sub,nsub,istart,iend,half_super_step,super_step:', &
                    !                                sub,nsub,istart,iend,half_super_step,super_step
                    !                   endif
                    !                   print *,'sub,iend,nsub:',sub,iend,nsub
                    
                    !                   min_sub_neigh(iisub)=istart 
                    !                   min_sub_neigh(iisub)=0
                                       min_sub_neigh2(iisub)=nsub
                                       min_val(iisub)=1000000 ! min valancy
                                       found_starting_node(iisub)=.false.
                    
                                       do isub = istart, iend 
                    !                      print *,'iloop,isub:',iloop,isub
                    !                   isub= 1 + iloop*super_step
                    !                      do count=fin_sub(isub),fin_sub(isub+1)-1
                                          do count=max_in_sub*(isub-1)+1, max_in_sub*(isub-1)+count_in_sub(isub) 
                                             nod=nodes_in_domain( count )
                                             if(got_starting_node) then
                                                if(nod==starting_node) found_starting_node(iisub)=.true.
                                             endif
                    !                         print *,'isub,nod:',isub,nod
                                             min_val(iisub) = min( min_val(iisub),  fina(nod+1)-fina(nod) )
                    !                         print *,'isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod):', &
                    !                                  isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod)
                                             do count2=fina(nod),fina(nod+1)-1
                                                col=cola(count2) 
                    !                            print *,'nod,  fina(nod+1)-fina(nod):', nod,  fina(nod+1)-fina(nod)
                    !                            if(whichd(col)<sub) then
                    !                               min_sub_neigh(iisub) = max( min_sub_neigh(iisub), whichd(col) ) 
                    !                            endif
                                                if(whichd(col)>sub+super_step-1) then
                                                   min_sub_neigh2(iisub) = min( min_sub_neigh2(iisub), whichd(col) ) 
                                                endif
                                             end do ! do count=fina(nod),fina(nod+1)-1
                                          end do ! do count=fin_sub(isub),fin_sub(isub+1)-1
                                       end do ! do isub = istart, iend 
                    
                    
                                   end do ! do iloop=0,1  
                    
                    !               swap=.false.
                                   go_backwards_swaps=.false.
                                   if( sub_level( min_sub_neigh2(2),level,nlevel ) > sub_level( min_sub_neigh2(1),level,nlevel) ) then
                                       go_backwards_swaps=.true.
                                   endif
                    !               print *,'go_backwards_swaps,its, sub, min_sub_neigh2(:):',go_backwards_swaps,its, sub, min_sub_neigh2(:)
                    !               print *,'sub_level( min_sub_neigh2(1),level,nlevel ):',sub_level( min_sub_neigh2(1),level,nlevel )
                    !               print *,'sub_level( min_sub_neigh2(2),level,nlevel ):',sub_level( min_sub_neigh2(2),level,nlevel )
                    !
                                   if(go_backwards_swaps) then ! go backwards swapping subdomains over as you go. 
                                      do sub2 = sub, 1, - super_step  
                                    do iloop=0,1
                                       iisub=iloop+1
                    !                   sub=1*(iloop-1) +
                    !                   sub=1*(iloop-1) + super_step*iloop 
                    
                                       istart=sub2*(1-iloop)                     + (sub2+half_super_step)*iloop
                                       iend  =(sub2+half_super_step-1)*(1-iloop) + (sub2+super_step-1)*iloop 
                                       iend = min(iend, nsub) 
                    
                    !                   min_sub_neigh(iisub)=istart 
                                       min_sub_neigh(iisub)=0
                    !                   min_sub_neigh2(iisub)=nsub
                                       min_val(iisub)=1000000 ! min valancy
                                       found_starting_node2(iisub)=.false.
                    
                                       do isub = istart, iend 
                    !                      print *,'iloop,isub:',iloop,isub
                    !                   isub= 1 + iloop*super_step
                    !                      do count=fin_sub(isub),fin_sub(isub+1)-1
                                          do count=max_in_sub*(isub-1)+1, max_in_sub*(isub-1)+count_in_sub(isub) 
                                             nod=nodes_in_domain( count )
                                             if(got_starting_node) then
                                                if(nod==starting_node) found_starting_node2(iisub)=.true.
                                             endif
                    !                         print *,'isub,nod:',isub,nod
                                             min_val(iisub) = min( min_val(iisub),  fina(nod+1)-fina(nod) )
                    !                         print *,'isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod):', &
                    !                                  isub,iisub, nod, min_val(iisub),fina(nod+1)-fina(nod)
                                             do count2=fina(nod),fina(nod+1)-1
                                                col=cola(count2) 
                    !                            print *,'nod,  fina(nod+1)-fina(nod):', nod,  fina(nod+1)-fina(nod)
                                                if(whichd(col)<sub-super_step+1) then
                                                   min_sub_neigh(iisub) = max( min_sub_neigh(iisub), whichd(col) ) 
                                                endif
                    !                            if(whichd(col)>sub+super_step-1) then
                    !                               min_sub_neigh2(iisub) = min( min_sub_neigh2(iisub), whichd(col) ) 
                    !                            endif
                                             end do ! do count=fina(nod),fina(nod+1)-1
                                          end do ! do count=fin_sub(isub),fin_sub(isub+1)-1
                                       end do ! do isub = istart, iend 
                    
                    
                                   end do ! do iloop=0,1  
                    
                    
                    
                    !                  call simple_sub_swap(sub2, sub2+half_super_step, nsub,nonods,max_in_sub, whichd, &
                    !                              nodes_in_domain, count_in_sub )
                    
                    !               if(sub_level(sub2,level,nlevel)<=2) then
                    !                  exit ! can not go backwards any further
                    !               endif
                                   if(sub2==1) then
                                      if(found_starting_node2(1)) exit ! can not swap 
                                   endif
                                   if( sub_level( min_sub_neigh(2),level,nlevel ) > sub_level( min_sub_neigh(1),level,nlevel) ) then
                    !               if( .false. ) then
                    !                  print *,'--finished reversing between sub2, sub2+half_super_step:',sub2, sub2+half_super_step
                                      exit ! exit loop because we have got to a point where we have not improved things
                                   else 
                    !                call simple_sub_swap(sub, sub+half_super_step, nsu... (original)
                    
                                      call simple_sub_swap(min(nsub, sub2), min(nsub, sub2+half_super_step), nsub,nonods,max_in_sub, whichd, &
                                                  nodes_in_domain, count_in_sub )
                                   endif
                    ! 
                                      end do ! do sub2=sun, 1, super_step
                    
                    !                  if(backwards_not_as_good) then ! reset to original
                    !                  endif
                    
                                   endif ! if(go_backwards_swaps) then
                    ! 
                    
                             end do ! do sub=1, nsub, super_step
                          end do ! do level = 3 , nlevel - 1
                    
                            end do ! do its=1,2
                    
                            end subroutine swap_subdomains_go_backwards
                    
                    
                    
                    
                            integer function sub_level( sub, level, nlevel )
                            integer sub, level, nlevel
                    !             super_step=2**(nlevel-level+1)  
                    !        sub_level = sub / ( 2**(nlevel-level+1) )    +1
                            sub_level = (sub-1) / ( 2**(nlevel-level) )    +1
                            end function sub_level
                    
                    
                    
                    
                    
                            subroutine simple_sub_swap(isuper_sub, jsuper_sub, nsub,nonods, max_in_sub, whichd, &
                                                  nodes_in_domain, count_in_sub )
                    ! **********************************************************************************
                    ! switch subdomains isub and jsub along with the variables  whichd, fin_sub, sub2nod 
                    ! to take this switch into account.
                    ! **********************************************************************************
                            implicit none
                            INTEGER, INTENT(IN) :: isuper_sub, jsuper_sub, nonods, nsub, max_in_sub
                            INTEGER, INTENT(inout) :: whichd(nonods)
                            INTEGER, INTENT(inout) :: nodes_in_domain(max_in_sub*nsub), count_in_sub(nsub)
                    ! local variables...
                            integer count,nod,col, iloop, iisub,iisub2, i,ip1, ii, nlist_i,nlist_j, sub, half_super_step
                            integer istart,iend, jstart,jend,  sub1_i,sub2_i, sub1_j,sub2_j, isub,jsub
                            INTEGER, ALLOCATABLE :: list_i(:), list_j(:), sub_keep_i(:), sub_keep_j(:)  
                    !        INTEGER, ALLOCATABLE :: list_i_dom(:), list_j_dom(:)
                    
                            half_super_step=jsuper_sub - isuper_sub 
                    
                     !       print *,'isuper_sub, jsuper_sub, half_super_step:', isuper_sub, jsuper_sub, half_super_step
                    !        nlist_i=fin_sub(jsuper_sub)-fin_sub(isuper_sub)
                    !        nlist_j=fin_sub(jsuper_sub+half_super_step)-fin_sub(jsuper_sub) 
                    !          print *,'nlist_i,nlist_j:',nlist_i,nlist_j
                    !        print *,'isuper_sub,jsuper_sub,nsub:',isuper_sub,jsuper_sub,nsub
                            sub= isuper_sub
                            sub1_i=sub
                            istart=(sub-1)*max_in_sub+1
                            sub=jsuper_sub-1
                            sub2_i=sub
                    !        iend=(sub-1)*max_in_sub+count_in_sub(sub) 
                            iend=(sub-1)*max_in_sub+max_in_sub
                            iend=min(nsub*max_in_sub, iend) 
                    
                            sub= jsuper_sub
                            sub1_j=sub
                            jstart=(sub-1)*max_in_sub+1
                            sub= jsuper_sub+half_super_step-1
                            sub2_j=sub
                    !        jend=(sub-1)*max_in_sub+count_in_sub(sub)
                            jend=(sub-1)*max_in_sub+max_in_sub
                            jend=min(nsub*max_in_sub, jend) 
                    
                    !        print *,'for allocating jstart,jend:',jstart,jend
                            allocate(list_i( istart:iend ), list_j( jstart:jend )  )
                            list_i=0; list_j=0
                            allocate(sub_keep_i(sub1_i:sub2_i), sub_keep_j(sub1_j:sub2_j)  )
                    !        print *,'sub1_j,sub2_j:',sub1_j,sub2_j
                    
                    !        allocate(list_i_dom( fin_sub(jsuper_sub)-fin_sub(isuper_sub) )   )
                    !        allocate(list_j_dom( fin_sub(jsuper_sub+super_step-1)-fin_sub(jsuper_sub+) )   )
                    
                    !           print *,'here1'
                    !           do count=fin_sub(isuper_sub),fin_sub(jsuper_sub)-1
                               do sub= isuper_sub, min(nsub, jsuper_sub-1) 
                                  sub_keep_i(sub)=count_in_sub(sub) 
                                  do count=(sub-1)*max_in_sub+1, (sub-1)*max_in_sub+count_in_sub(sub) 
                                     nod=nodes_in_domain( count )
                                     list_i(count) = nod
                                  end do
                    !              print *,'nod,ii,count:',nod,ii,count
                               end do
                    !           print *,'  '
                    !           print *,'here2'
                    !           do count=fin_sub(jsuper_sub),fin_sub(jsuper_sub+half_super_step)-1
                               do sub= jsuper_sub, min(nsub, jsuper_sub+half_super_step-1 )
                                  sub_keep_j(sub)=count_in_sub(sub) 
                                  do count=(sub-1)*max_in_sub+1, (sub-1)*max_in_sub+count_in_sub(sub) 
                                     nod=nodes_in_domain( count )
                                     list_j(count) = nod
                                  end do
                    !              print *,'nod,ii,count:',nod,ii,count
                               end do
                           
                    !          if(istart>iend) print *,'got issue1'
                    !          if(jstart>jend) print *,'got issue1'
                    !          print *,'jstart,jend,max_in_sub*nsub:',jstart,jend,max_in_sub*nsub
                    !          print *,'nsub,max_in_sub:',nsub,max_in_sub
                    !          print *,'jstart, jstart + (iend-istart):',jstart, jstart + (iend-istart)
                    
                               nodes_in_domain( jstart:jend )= list_i( istart: istart + (jend-jstart) )
                               nodes_in_domain( istart:iend )= list_j( jstart: jstart + (iend-istart) )
                    !           nodes_in_domain( jstart:jend )= list_i( istart:iend )
                    !           nodes_in_domain( istart:iend )= list_j( jstart:jend )
                    
                    
                    !           print *,'here3'
                    
                               do sub= isuper_sub, min(nsub, jsuper_sub-1)
                                  isub=sub
                                  jsub=sub + half_super_step
                                  count_in_sub(jsub) = sub_keep_i(isub)
                                  count_in_sub(isub) = sub_keep_j(jsub)
                                  do count=(isub-1)*max_in_sub+1, (isub-1)*max_in_sub+count_in_sub(isub) 
                                     nod=nodes_in_domain( count )
                                     whichd(nod)=isub
                                  end do
                                  do count=(jsub-1)*max_in_sub+1, (jsub-1)*max_in_sub+count_in_sub(jsub) 
                                     nod=nodes_in_domain( count )
                                     whichd(nod)=jsub
                                  end do
                               end do
                    !           print *,'here4'
                    
                    
                            end subroutine simple_sub_swap
                    
                     
                    
                    
                    
                            subroutine sub_swap(isuper_sub,jsuper_sub, nsub,nonods, whichd, fin_sub, sub2nod) 
                    ! **********************************************************************************
                    ! switch subdomains isub and jsub along with the variables  whichd, fin_sub, sub2nod 
                    ! to take this switch into account.
                    ! **********************************************************************************
                            implicit none
                            INTEGER, INTENT(IN) :: isuper_sub, jsuper_sub, nonods, nsub
                            INTEGER, INTENT(inout) :: whichd(nonods)
                            INTEGER, INTENT(inout) :: fin_sub(nsub+1), sub2nod(nonods)
                    ! local variables...
                            integer count,nod,col, iloop, iisub,iisub2, i,ip1, ii, nlist_i,nlist_j, sub, half_super_step
                            INTEGER, ALLOCATABLE :: list_i(:), list_j(:), fin_sub_keep_i(:)
                    !        INTEGER, ALLOCATABLE :: list_i_dom(:), list_j_dom(:)
                    
                            half_super_step=jsuper_sub - isuper_sub 
                    
                            print *,'isuper_sub, jsuper_sub, half_super_step:', isuper_sub, jsuper_sub, half_super_step
                            nlist_i=fin_sub(jsuper_sub)-fin_sub(isuper_sub)
                            nlist_j=fin_sub(jsuper_sub+half_super_step)-fin_sub(jsuper_sub) 
                              print *,'nlist_i,nlist_j:',nlist_i,nlist_j
                            
                            allocate(list_i( nlist_i ), list_j( nlist_j )   )
                    
                    !        allocate(list_i_dom( fin_sub(jsuper_sub)-fin_sub(isuper_sub) )   )
                    !        allocate(list_j_dom( fin_sub(jsuper_sub+super_step-1)-fin_sub(jsuper_sub+) )   )
                    
                               do count=fin_sub(isuper_sub),fin_sub(jsuper_sub)-1
                                  nod=sub2nod( count )
                                  ii = count - fin_sub(isuper_sub)+1
                                  list_i(ii) = nod
                    !              print *,'nod,ii,count:',nod,ii,count
                               end do
                    !           print *,'  '
                               do count=fin_sub(jsuper_sub),fin_sub(jsuper_sub+half_super_step)-1
                                  nod=sub2nod( count )
                                  ii = count - fin_sub(jsuper_sub) + 1
                                  list_j(ii) = nod
                    !              print *,'nod,ii,count:',nod,ii,count
                               end do
                    !         print *,'here1'
                    
                           if(.false.) then
                             allocate( fin_sub_keep_i(fin_sub(isuper_sub):fin_sub(jsuper_sub) )  )
                             do sub = isuper_sub, jsuper_sub-1
                                 fin_sub_keep_i(sub) = fin_sub(sub) 
                             end do
                             do sub = jsuper_sub, jsuper_sub + half_super_step -1 
                                 fin_sub(sub) = fin_sub_keep_i(sub) 
                             end do
                           endif
                    
                    
                               do count=fin_sub(isuper_sub),fin_sub(jsuper_sub)-1
                                  ii = count - fin_sub(isuper_sub) + 1
                                  nod=list_i(ii )
                                  sub2nod( count ) = nod
                                  whichd(nod) = whichd(nod) + half_super_step
                               end do
                    
                               do count=fin_sub(jsuper_sub),fin_sub(jsuper_sub+half_super_step)-1
                                  ii = count - fin_sub(jsuper_sub) + 1
                                  nod=list_j(ii )
                                  sub2nod( count ) = nod
                                  whichd(nod) = whichd(nod) - half_super_step
                               end do
                    ! Form subdomains to nodes list ***************************
                              call subs_2_node_list(nonods,nsub, whichd, fin_sub, sub2nod)
                    ! Form subdomains to nodes list ***************************
                    
                            end subroutine sub_swap
                    
                     
                    
                    
                    !        integer function subdomain_base(sub, level)
                    !        implicit none
                    !        INTEGER, INTENT(IN) :: sub, level
                    !        subdomain_base = (sub-1)/(2**level) 
                    !        end function subdomain_base
                    
                    
                    
                            subroutine simple_subs_2_node_list(nonods, nsub, whichd, max_in_sub, nodes_in_domain, count_in_sub) 
                    ! subdomains to nodes list ***************************
                    ! form: nodes_in_domain, count_in_sub
                    ! subdomains to nodes list ***************************
                            implicit none
                            INTEGER, INTENT(IN) :: nonods, nsub, max_in_sub
                            INTEGER, INTENT(in) :: whichd(nonods)
                            INTEGER, INTENT(inout) :: nodes_in_domain(nsub*max_in_sub), count_in_sub(nsub) 
                    ! local variables...
                            integer count, nod, col, isub
                    
                            nodes_in_domain=0 
                            do nod=1,nonods
                               isub=whichd(nod)
                               nodes_in_domain(isub) = nodes_in_domain(isub) + 1
                            end do
                    
                    !           print *,'nodes_in_domain:',nodes_in_domain
                    !           stop 282
                    !        print *,'fin_sub:',fin_sub
                    !          stop 2382
                            count_in_sub=0 
                            do nod=1,nonods
                               isub=whichd(nod)
                               count_in_sub(isub)=count_in_sub(isub)+1
                               count = (isub-1)*max_in_sub + count_in_sub(isub) 
                               nodes_in_domain( count ) = nod 
                            end do
                            end subroutine simple_subs_2_node_list
                    
                    
                    
                            subroutine subs_2_node_list(nonods,nsub, whichd, fin_sub, sub2nod) 
                    ! subdomains to nodes list ***************************
                    ! form: fin_sub, sub2nod
                    ! subdomains to nodes list ***************************
                            implicit none
                            INTEGER, INTENT(IN) :: nonods,nsub
                            INTEGER, INTENT(in) :: whichd(nonods)
                            INTEGER, INTENT(inout) :: fin_sub(nsub+1), sub2nod(nonods)
                    ! local variables...
                            integer count, nod, col, isub
                            INTEGER, ALLOCATABLE :: nodes_in_domain(:), count_in_sub(:)
                             
                            allocate(nodes_in_domain(nsub), count_in_sub(nsub) )
                            nodes_in_domain=0 
                            do nod=1,nonods
                               isub=whichd(nod)
                               nodes_in_domain(isub) = nodes_in_domain(isub) + 1
                            end do
                    
                    !           print *,'nodes_in_domain:',nodes_in_domain
                    !           stop 282
                            fin_sub(1)=1 
                            do isub=1,nsub
                               fin_sub(isub+1)=fin_sub(isub) + nodes_in_domain(isub) 
                            end do
                    !        print *,'fin_sub:',fin_sub
                    !          stop 2382
                            count_in_sub=0 
                            do nod=1,nonods
                               isub=whichd(nod)
                               count_in_sub(isub)=count_in_sub(isub)+1
                               count = fin_sub(isub) + count_in_sub(isub)-1
                               sub2nod( count ) = nod 
                            end do
                    
                            end subroutine subs_2_node_list
                    
                    
                    
                    
                            subroutine space_filling_curve_from_ddm(ncola, cola,fina, whichd, nonods,  &
                                              space_fill_curve_numbering, starting_node)
                    ! *******************************************************************************************************
                    ! This subroutine forms the space filling curve from the domain decompositon. 
                    ! It outputs the array space_fill_curve_numbering(nod) = new node numbering from current node number nod.
                    ! starting_node is the starting node of the space filling curve =0 (no starting node).   
                    ! *******************************************************************************************************
                    !        INTEGER, INTENT(IN) :: nonods,ncola,ndim
                            implicit none
                            INTEGER, INTENT(IN) :: nonods,ncola, starting_node
                            INTEGER, INTENT(in) :: cola(ncola),fina(nonods+1), whichd(nonods)
                    !        real, intent(in) :: x_all(ndim,nonods) 
                            INTEGER, INTENT(inout) :: space_fill_curve_numbering(nonods) 
                    ! local variables...
                            integer count,nod,col, nsub, isub, new_nod, old_nod, iloop, its 
                            integer new_nod1, old_nod1, new_nod2, old_nod2, f_before, f_after, icount
                            integer for_max(2), for_min(2)
                            logical swap, found_starting_node(2), got_starting_node
                            INTEGER, ALLOCATABLE :: nodes_in_domain(:), fin_sub(:), count_in_sub(:), sub2nod(:)
                            INTEGER, ALLOCATABLE :: new2old(:)
                     
                            got_starting_node=((starting_node>0).and.(starting_node<nonods+1)) 
                    
                    ! this is ok here as we dont assume the number of subdomain is 2^nlevel...
                            nsub=maxval(whichd) 
                            allocate(nodes_in_domain(nsub), fin_sub(nsub+1), count_in_sub(nsub), sub2nod(nonods) ) 
                            allocate(new2old(nonods)  ) 
                    
                            nodes_in_domain=0 
                            do nod=1,nonods
                               isub=whichd(nod)
                               nodes_in_domain(isub) = nodes_in_domain(isub) + 1
                            end do
                    
                            fin_sub(1)=1 
                            do isub=1,nsub
                               fin_sub(isub+1)=fin_sub(isub) + nodes_in_domain(isub) 
                            end do
                    
                            count_in_sub=0 
                            do nod=1,nonods
                               isub=whichd(nod)
                               count_in_sub(isub)=count_in_sub(isub)+1
                               count = fin_sub(isub) + count_in_sub(isub)-1
                               sub2nod( count ) = nod 
                            end do
                    
                            new_nod=0
                            do isub=1,nsub
                               do count=fin_sub(isub),fin_sub(isub+1)-1
                                  nod=sub2nod( count )
                                  new_nod = new_nod+1
                                  space_fill_curve_numbering(nod)=new_nod
                               end do
                            end do
                    
                    ! try swapping nodes over a few times in case there were a more than 1 node per subdomain...
                            do old_nod=1,nonods
                               new_nod=space_fill_curve_numbering(old_nod)
                               new2old(new_nod) = old_nod
                            end do
                    
                            if(got_starting_node) then ! make sure starting node is node 1 in new ordering. 
                               new_nod1=1
                               old_nod1=new2old(new_nod1)
                               new_nod2=0
                               if(old_nod1.ne.starting_node) then !swap over but find the node to swap with 
                                  do new_nod=1,nonods
                                     old_nod=new2old(new_nod)
                                     if( old_nod==starting_node ) new_nod2=new_nod
                                  end do ! do new_nod=1,nonods
                                  if(new_nod2==0) stop 2921
                                  old_nod1=new2old(new_nod1)
                                  old_nod2=new2old(new_nod2)
                                  space_fill_curve_numbering(old_nod1)=new_nod2
                                  space_fill_curve_numbering(old_nod2)=new_nod1
                                  new2old(new_nod1) = old_nod2
                                  new2old(new_nod2) = old_nod1
                               endif ! if(old_nod1.ne.starting_node) then 
                            endif ! if(got_starting_node) then
                    
                            do its=1,5
                               icount=0
                               do new_nod=1,nonods-1
                    ! swap nod with nod +1 ? 
                                  do iloop=1,2
                                     for_max(iloop) = 1
                                     for_min(iloop) = nonods 
                                     new_nod2=new_nod+ iloop-1
                                     old_nod2 = new2old(new_nod2) 
                    !                 found_starting_node(iloop)=.false.
                                     do count=fina(old_nod2),fina(old_nod2+1)-1
                                        col=cola(count)
                                        if(space_fill_curve_numbering(col)<new_nod) then
                                           for_max(iloop) = max( for_max(iloop), space_fill_curve_numbering(col) )
                                        endif
                                        if(space_fill_curve_numbering(col)>new_nod+1) then
                                           for_min(iloop) = min( for_min(iloop), space_fill_curve_numbering(col) )
                                        endif
                                     end do
                                  end do
                    
                                  if(new_nod==1) then
                                     f_before =     + abs( for_min(2) - (new_nod+1) )
                    
                                     f_after =     + abs( for_min(1) - (new_nod+1) )
                                  else if(new_nod==nonods-1) then
                                     f_before =  abs( new_nod - for_max(1)  )    
                    
                                     f_after =  abs( new_nod - for_max(2)  )    
                                  else
                                     f_before =  abs( new_nod - for_max(1)  )    + abs( for_min(2) - (new_nod+1) )
                    
                                     f_after =  abs( new_nod - for_max(2)  )    + abs( for_min(1) - (new_nod+1) )
                                  endif
                    
                                  swap = (f_before>=f_after) ! swap over if its better...
                    !              if(found_starting_node(1).or.found_starting_node(2)) swap=.false. ! dont swap starting node
                                  if(got_starting_node) then
                                     if(new_nod==1) swap=.false. ! dont swap starting node
                                  endif
                    !              print *,'its,new_nod,swap:',its,new_nod,swap 
                    
                                  if(swap) then 
                                     icount=icount+1
                    !                 print *,'swap, f_before, f_after:', swap, f_before, f_after
                    !                 print *,'its,new_nod,swap:',its,new_nod,swap 
                                     new_nod1=new_nod
                                     old_nod1=new2old(new_nod1)
                                     new_nod2=new_nod+1
                                     old_nod2=new2old(new_nod2)
                                     space_fill_curve_numbering(old_nod1)=new_nod2
                                     space_fill_curve_numbering(old_nod2)=new_nod1
                                     new2old(new_nod1) = old_nod2
                                     new2old(new_nod2) = old_nod1
                                  endif
                                  
                               end do
                    !           print *,'its,icount:',its,icount
                               if(icount==0) exit
                            end do 
                            
                            end subroutine space_filling_curve_from_ddm
                    
                    
                    
                    
                             subroutine one_d_row_stor(ncola, cola,fina, nx,ny,nonods,mx_ncola)
                            INTEGER, INTENT(IN) :: nx,ny,nonods,mx_ncola
                            INTEGER, INTENT(OUT) :: ncola
                            INTEGER, INTENT(OUT) :: cola(mx_ncola),fina(nonods+1)
                    ! local variables...
                             integer count,nod,col,i,j
                    
                              count=0
                              do nod=1,nonods
                                 fina(nod)=count+1
                    
                                 if(.false.) then
                                    do ii=-1,1,1
                                       col=nod+ii
                                       if((col.ge.1).and.(col.le.nonods)) then
                                          count=count+1
                                          cola(count)=col
                                       endif
                                    end do
                                 else ! 5 pt stencil in 2d...
                    !             nod = (j-1)*nx + i 
                                    j = (nod-1)/nx +1 
                                    i = nod - (j-1)*nx 
                                   if(j.ne.1) then
                                    col=nod-nx
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                   if(i.ne.1) then
                                    col=nod-1
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                    col=nod
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   if(i.ne.nx) then
                                    col=nod+1
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                   if(j.ne.ny) then
                                    col=nod+nx
                                    call set_col(col,count,cola,mx_ncola,nonods)
                                   endif
                                 endif
                    
                              end do
                              fina(nonods+1)=count+1
                              ncola=count
                              return
                              end subroutine 
                    
                    !
                              subroutine set_col(col,count,cola,ncola,nonods)
                              integer col,count,ncola,nonods
                              integer cola(ncola)
                              if((col.ge.1).and.(col.le.nonods)) then
                                 count=count+1
                                 cola(count)=col
                              endif
                              return
                              end subroutine set_col
                    !
                    !
                              SUBROUTINE test_r_i(ORR,OII,  RR,NR,II,NI)
                    !! SUBROUTINE TO TEST THE REALS AND INTEGERS IN PHTHON
                              IMPLICIT NONE
                              INTEGER, INTENT(IN) :: NR,NI
                    !         ! REAL, INTENT(OUT) :: ORR(NR)
                    !         ! INTEGER, INTENT(OUT) :: OII(NI)
                    !         ! REAL, INTENT(IN) :: RR(NR)
                    !         ! INTEGER, INTENT(IN) :: II(NI)
                              REAL, INTENT(OUT) :: ORR(NR)
                              INTEGER, INTENT(OUT) :: OII(NI)
                              REAL, INTENT(IN) :: RR(:)
                              INTEGER, INTENT(IN) :: II(:)
                    
                              PRINT *,'RR:',RR
                              PRINT *,'II:',II
                              ORR=RR
                              OII=II
                              RETURN
                              END SUBROUTINE test_r_i
                    
                    
                    ! 
                    ! ************RECBIS IS THE KEY SUBROUTINE TO CALL FOR SPLITTING*********** 
                    ! NOTE FOR AUTOENCODERS:
                    ! If we want to use a specified number
                    ! of input neurons (not a bad idea) then we might find the maximum number of
                    ! nodes in each subdomain and just send down zero's into the unused nodes. 
                    ! 
                    ! 
                    ! *****DOMAIN DECOMPOSITION METHOD***********
                    ! The subdomain splitting method is a neural network - a recurrent mean field theory network. 
                    ! This has the advantage that you can easily modify it (as we have done) to
                    ! as exactly as possible balance the number of nodes in each subdomain. 
                    ! 
                    ! 
                    ! SET_UP_RECBIS IS A SIMPLIFIED INTERFACE FOR IT **************************
                    ! 
                    ! 
                    ! 
                    ! from python call...
                    ! wnod = weight_from_stress_tensor( ct,  nsnapshot, ndim, nonods )
                          subroutine weight_from_stress_tensor( wnod, ct,  nsnapshot, ndim, nonods )
                    ! Calculate WNOD the weight associated with each node for trying to 
                    ! balance the activity in each subdomain and minimize activity between subdomains. 
                    ! It does this by caclulating the Reynolds stresses and taking the maximim of them. 
                    ! nonods = no of nodes in fem mesh
                    ! ndim= no of dimensions e.g. for 3D problems =3. 
                    ! nsnapshot = no of snapshots. 
                    ! ct contains the velocity snapshots and of form: ct(isnapshot, u,v,w) 
                          implicit none
                          integer, INTENT(IN) :: nsnapshot, ndim, nonods
                          real, INTENT(OUT) :: wnod(nonods)
                          real, INTENT(IN) :: ct(nsnapshot,nonods*ndim) 
                    ! Local variables
                    ! a and b define the form of the expoential used to form the wnod from the Reynolds stresses. 
                          real a,b
                          parameter( a=0.05, b=0.0019183 )
                          real vel_mean(ndim), reynolds(ndim),  max_reynolds
                          integer nod,idim
                          real, allocatable :: vel_snap(:,:)
                    
                          allocate(vel_snap(ndim, nsnapshot) )
                    
                          do nod=1,nonods
                             do idim=1,ndim
                                vel_snap(idim,:) = ct(:,(idim-1)*nonods + nod)
                                vel_mean(idim) = sum(vel_snap(idim,:) )/ real(nsnapshot) 
                                reynolds(idim) = sum( (vel_snap(idim,:) - vel_mean(idim))**2 )/ real(nsnapshot)
                             end do
                             max_reynolds = maxval( reynolds(:) )
                             wnod(nod) = (1./b) * log( max_reynolds/a + 1.0) 
                          end do
                          end subroutine weight_from_stress_tensor
                    ! 
                    ! 
                    ! 
                    ! wnod = ele_weight_calc_non_uni_meshes( ndglno, coordinates, nloc, totele, nonods )
                          subroutine ele_weight_calc_non_uni_meshes( wnod,ndglno, &
                                               coordinates, nloc, totele, nonods )
                    ! Calculate WNOD the weight associated with each node for trying to 
                    ! encourage partitions to occure across areas with changes in mesh resolution. 
                    ! Works only for element connectivity lists for not for DG. 
                    ! findm,colm contain the compact row storage of the DG stencil calculated by this sub.
                    ! ncolm = length of colm. 
                    ! nonods = no of DG nodes for the problem = totele*nloc
                    ! coordinates = spatial coordinates
                          implicit none
                          integer, INTENT(IN) :: nonods,nloc,totele
                          real, INTENT(OUT) :: wnod(nonods)
                          integer, INTENT(IN) :: ndglno(totele*nloc)
                          real, INTENT(IN) :: coordinates(nonods,3) 
                    ! Local variables
                          integer iloc, nod,ele
                          integer lnod(0:3)
                          real vol_ele
                          real elevolume ! function
                          logical d3
                          real, allocatable :: x_all(:,:), min_nod(:), max_nod(:)
                    
                          ALLOCATE(x_all(3,nonods), min_nod(nonods), max_nod(nonods) )
                          x_all(1,:)=coordinates(:,1); x_all(2,:)=coordinates(:,2); 
                          x_all(3,:)=coordinates(:,3)
                    
                          d3=  (   (maxval(x_all(3,:))-minval(x_all(3,:))) > 1.e-8   ) ! is this a 2d or 3d simulation.
                    
                          min_nod=1.e+15; max_nod=-1.e+15
                          do ele=1,totele
                             do iloc=1,nloc
                                lnod(iloc-1) = ndglno((ele-1)*nloc+iloc) 
                             end do
                             if(.not.d3) lnod(3)=lnod(2)
                    !            vol_jele = elevolume(d3, x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3)
                             vol_ele = elevolume(d3, x_all(1,lnod(0)), x_all(2,lnod(0)),x_all(3,lnod(0)), &
                                                     x_all(1,lnod(1)), x_all(2,lnod(1)),x_all(3,lnod(1)), &
                                                     x_all(1,lnod(2)), x_all(2,lnod(2)),x_all(3,lnod(2)), &
                                                     x_all(1,lnod(3)), x_all(2,lnod(3)),x_all(3,lnod(3)) )
                             do iloc=1,nloc
                                nod = lnod(iloc-1) 
                                min_nod(nod) = min( vol_ele, min_nod(nod) )
                                max_nod(nod) = max( vol_ele, max_nod(nod) )
                             end do
                          end do
                          wnod=min_nod/max_nod
                    
                          end subroutine ele_weight_calc_non_uni_meshes
                    
                    
                    
                    ! wnod = weight_calc_non_uni_meshes( findm,colm, coordinates, ncolm, nonods )
                          subroutine weight_calc_non_uni_meshes( wnod, findm,colm, coordinates, ncolm, nonods )
                    ! Calculate WNOD the weight associated with each node for trying to 
                    ! encourage partitions to occure across areas with changes in mesh resolution. 
                    ! works only for DG meshes. 
                    ! findm,colm contain the compact row storage of the DG stencil calculated by this sub.
                    ! ncolm = length of colm. 
                    ! nonods = no of DG nodes for the problem = totele*nloc
                    ! coordinates = spatial coordinates
                          implicit none
                          integer, INTENT(IN) :: nonods,ncolm
                          real, INTENT(OUT) :: wnod(nonods)
                          integer, INTENT(IN) :: findm(nonods+1),colm(ncolm)
                          real, INTENT(IN) :: coordinates(nonods,3) 
                    ! Local variables
                          integer count,ndim,nsur,nloc,totele, nod,ele,jele,jnod
                          integer nod0,nod1,nod2,nod3
                          real max_vol_ele, min_vol_ele, vol_ele, vol_jele 
                          real elevolume ! function
                          logical d3
                          real, allocatable :: x_all(:,:)
                    
                          ALLOCATE(x_all(3,nonods) )
                          x_all(1,:)=coordinates(:,1); x_all(2,:)=coordinates(:,2); 
                          x_all(3,:)=coordinates(:,3)
                    
                          d3=  (   (maxval(x_all(3,:))-minval(x_all(3,:))) > 1.e-8   ) ! is this a 2d or 3d simulation.
                          ndim=2; if(d3) ndim=3 ! number of dimensions - 2d or 3d
                          nloc=ndim+1 ! no of local nodes per element
                          nsur=ndim+1 ! no of elements surround an element
                          totele = nonods/nloc
                    
                    
                          do nod=1,nonods
                    !         ele=(nod-1)/nloc + 1 
                             max_vol_ele = -1.e+10
                             min_vol_ele =  1.e+10
                             do count=findm(nod),findm(nod+1)-1
                                jnod=colm(count)
                                jele=(jnod-1)/nloc + 1 
                                nod0=(jele-1)*nloc+1; nod1=(jele-1)*nloc+2; nod2=(jele-1)*nloc+3; 
                                nod3=(jele-1)*nloc+4
                                if(.not.d3) nod3=nod2
                    !            vol_jele = elevolume(d3, x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3)
                                vol_jele = elevolume(d3, x_all(1,nod0), x_all(2,nod0),x_all(3,nod0), &
                                                         x_all(1,nod1), x_all(2,nod1),x_all(3,nod1), &
                                                         x_all(1,nod2), x_all(2,nod2),x_all(3,nod2), &
                                                         x_all(1,nod3), x_all(2,nod3),x_all(3,nod3) )
                                max_vol_ele = max( max_vol_ele, vol_jele) 
                                min_vol_ele = min( min_vol_ele, vol_jele) 
                             end do
                             wnod(nod) = min_vol_ele/max_vol_ele
                          end do
                          end subroutine weight_calc_non_uni_meshes
                    
                    
                    
                          function elevolume(D3, x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3)
                          IMPLICIT NONE
                         LOGICAL, intent(in) :: D3
                         real, intent(in) :: x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3
                    
                         real :: tetvolume, triangle_area
                         real :: elevolume
                    
                          IF(D3) THEN
                             elevolume = tetvolume(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3)
                          ELSE
                             elevolume = triangle_area( x0, y0, x1, y1, x2, y2 )
                          ENDIF
                          elevolume=abs(elevolume) 
                         
                          end function elevolume
                     
                    
                    
                        real function triangle_area( x1, y1, x2, y2, x3, y3 )
                    
                            implicit none
                    
                            real :: x1, y1, x2, y2, x3, y3
                    
                            triangle_area = 0.5 * ( ( x2 * y3 - y2 * x3 ) - x1 * ( y3 - y2 ) + y1 * ( x3 - x2 ) )
                    
                            return
                        end function triangle_area
                    
                    
                          function tetvolume(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3)
                          IMPLICIT NONE
                    
                         real, intent(in) :: x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3
                    
                         real :: tetvolume
                    
                         ! tetvolume = 1.0 / 6.0 * det |three tet edge vectors|
                         ! Chris' tets have a clockwise base, hence the sign change in the det
                         tetvolume = &
                           (  &
                             & - (x1 - x0) * ((y2 - y0) * (z3 - z0) - (y3 - y0) * (z2 - z0)) &
                             & + (y1 - y0) * ((x2 - x0) * (z3 - z0) - (x3 - x0) * (z2 - z0)) &
                             & - (z1 - z0) * ((x2 - x0) * (y3 - y0) - (x3 - x0) * (y2 - y0)) &
                           & ) / 6.0
                    
                       end function tetvolume
                    
                    
                    
                    ! 
                    ! pYTHON: 
                    ! COLM,FINDRM,NCOLM = SIMPLE_POSINMC_legacy(NDGLNO, TOTELE,NONODS,NLOC, MAX_NCOLM)
                          SUBROUTINE SIMPLE_POSINMC_legacy(COLM,FINDRM,NCOLM,  NDGLNO, TOTELE,NONODS,NLOC, MAX_NCOLM)
                    !  use FLDebug
                      IMPLICIT NONE
                      INTEGER, INTENT(IN)::NONODS, TOTELE, NLoc, MAX_NCOLM
                      INTEGER, INTENT(OUT)::NCOLM,FINDRM(NONODS+1),COLM(MAX_NCOLM)
                      INTEGER, INTENT(IN)::NDGLNO(TOTELE*NLoc)
                      INTEGER ELE,GLOBI,GLOBJ,LOCI,LOCJ,I,IROW,PTR
                         INTEGER, allocatable :: CENTRM(:)
                    
                       ALLOCATE(CENTRM(NONODS))
                    
                       CALL POSINMC_legacy(TOTELE,NONODS,NLOC, &
                         COLM, NCOLM, MAX_NCOLM, &
                         FINDRM, CENTRM, &
                         NONODS, NLOC, NDGLNO, &
                         NDGLNO)
                    
                       RETURN
                       END SUBROUTINE SIMPLE_POSINMC_legacy
                    ! 
                    ! 
                    ! 
                    ! 
                       SUBROUTINE POSINMC_legacy(TOTELE,NNodes1,NLoc1, &
                         COLM, LenCOLM, NIMEM, &
                         FINDRM, CENTRM, &
                         NNodes2, NLoc2, NDGLNO2, &
                         NDGLNO1)
                    !  use FLDebug
                      IMPLICIT NONE
                      INTEGER, INTENT(IN)::NNodes1, NNodes2, TOTELE, NLoc1, NLoc2, NIMEM
                      INTEGER, INTENT(OUT)::LenCOLM,FINDRM(NNodes2+1),COLM(NIMEM),CENTRM(NNodes2)
                      INTEGER, INTENT(IN)::NDGLNO1(TOTELE*NLoc1), NDGLNO2(TOTELE*NLoc2)
                      INTEGER ELE,GLOBI,GLOBJ,LOCI,LOCJ,I,IROW,PTR
                    
                      ! Define a linked list
                      TYPE node
                         INTEGER :: ID                ! id number of node
                         TYPE (node), POINTER :: next ! next node
                      END TYPE node
                    
                      TYPE row
                         TYPE (node), POINTER :: row
                      END TYPE row
                    
                      TYPE(row), DIMENSION(:), ALLOCATABLE::Matrix
                      TYPE(node), POINTER::List, Current, Next
                       
                      ! Initalise the linked lists
                      ALLOCATE( Matrix(NNodes2) )
                      DO I=1, NNodes2
                         ALLOCATE( List )
                         List%ID = -1
                         NULLIFY( List%next )
                         
                         Matrix(I)%row => List
                         NULLIFY(List)
                      END DO
                        
                      DO ELE=1,TOTELE
                         DO LOCI=1,NLoc2
                            GLOBI=NDGLNO2((ELE-1)*NLoc2+LOCI)
                            List => Matrix(GLOBI)%row
                    
                            DO LOCJ=1,NLoc1
                               GLOBJ=NDGLNO1((ELE-1)*NLoc1+LOCJ)
                               
                               ! Check if the list is initalised
                               IF(List%ID.EQ.-1) THEN
                                  List%ID = GLOBJ
                                  CYCLE
                               END IF
                               
                               ! Check if the list is initalised
                               IF(List%ID.EQ.-1) THEN
                                  List%ID = GLOBJ
                                  CYCLE
                               END IF
                               
                               IF(GLOBJ.LT.List%ID) THEN
                                  ! Insert at start of list
                                  ALLOCATE(Current)
                                  Current%ID = GLOBJ
                                  Current%next => List
                    
                                  Matrix(GLOBI)%row => Current
                                  List => Matrix(GLOBI)%row
                               ELSE
                                  Current => List
                                  DO WHILE ( ASSOCIATED(Current) )
                                     IF(GLOBJ.EQ.Current%ID) THEN
                                        ! Already have this node
                                        exit 
                                     ELSE IF(.NOT.ASSOCIATED(Current%next)) THEN
                                        ! End of list - insert this node
                                        ALLOCATE(Current%next)
                                        NULLIFY(Current%next%next)
                                        Current%next%ID = GLOBJ
                                        
                                        exit
                                     ELSE IF(GLOBJ.LT.Current%next%ID) THEN
                                        ! Insert new node here
                                        ALLOCATE(Next)
                                        Next%ID = GLOBJ
                                        Next%next => Current%next
                                        Current%Next => Next
                                        exit
                                     END IF
                                     Current => Current%next
                                  END DO
                               END IF
                            END DO
                         END DO
                      END DO
                        
                      ! From matrix write COLM, FINDRM and CENTRM
                      ! linked list as we go
                      PTR = 1
                      DO IROW=1,NNodes2
                         FINDRM(IROW) = PTR
                         CENTRM(IROW) = -1
                    
                         Current => Matrix(IROW)%row
                    
                         DO WHILE ( ASSOCIATED(Current) )
                    !        ASSERT(PTR.LE.NIMEM)
                            
                            COLM(PTR) = Current%ID
                            IF(Current%ID==-1) THEN
                    !           ewrite(0,*) &
                    !                "ERROR: Mesh contains nodes that are not associated with any elements."
                    !           ewrite(0,*) &
                    !                "ERROR: POSINM() seriously unhappy with node", IROW
                            END IF
                    
                            IF(Current%ID.EQ.IROW) THEN
                               CENTRM(IROW) = PTR
                            END IF
                            
                            Next => Current%next
                            DEALLOCATE(Current)
                            Current => Next
                            
                            PTR = PTR + 1
                         END DO
                      END DO
                    
                      LenCOLM = PTR-1
                      FINDRM(NNodes2+1) = LenCOLM+1
                      
                      DEALLOCATE( Matrix )
                      
                      END SUBROUTINE POSINMC_legacy
                    
                    ! 
                    ! 
                    ! In phython use:
                    ! NONODS_S, LX_ALL, LFINA,LCOLA,LNCOLA, MAP_L2S=new_pters_for_sub(FINA,COLA, X_ALL, WHICHD,ISUB, NCOLA, MAX_LNCOLA,MAX_NONODS_S,NONODS,NDIM) 
                          SUBROUTINE NEW_PTERS_FOR_SUB( NONODS_S, LX_ALL, LFINA,LCOLA,LNCOLA, MAP_L2S, &
                                     FINA,COLA, X_ALL, WHICHD,ISUB, NCOLA, MAX_LNCOLA,MAX_NONODS_S,NONODS,NDIM )
                    ! This sub deetermins the local to subdomain ISUb LFINA,LCOLA,LNCOLA
                    ! it also calculates the coordinates LX_ALL local to a subdomain from the coodinates X_ALL
                    ! WHICHD(NOD)= IS INPUT AND CONTAINS THE SUBDOMAIN THAT NODE NOD BELONGS. 
                          IMPLICIT NONE
                          INTEGER, INTENT(OUT) :: NONODS_S
                          INTEGER, INTENT(IN) :: NONODS,ISUB,NCOLA, MAX_NONODS_S, MAX_LNCOLA,NDIM
                          REAL, INTENT(OUT) :: LX_ALL(NDIM,MAX_NONODS_S) 
                          INTEGER, INTENT(OUT) :: MAP_L2S(NONODS), LFINA(MAX_NONODS_S+1),LCOLA(MAX_LNCOLA),LNCOLA
                          INTEGER, INTENT(IN) :: FINA(NONODS+1),COLA(NCOLA),WHICHD(NONODS) 
                          REAL, INTENT(IN) :: X_ALL(NDIM,NONODS)
                    ! LOCAL VARIABLES...
                          INTEGER LNNOD,LNOD,I,COUNT,COUNT2,MICOL
                    
                                lnnod = 0
                                DO i = 1 , NONODS
                                   Map_L2S(i) = 0
                                ENDDO
                                DO i = 1 , NONODS
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnnod = lnnod + 1
                                      Map_L2S(i) = lnnod
                    !                  Lwnod(lnnod) = Wnod(i)
                                      LX_ALL(:,lnnod) = X_ALL(:,i)
                                   ENDIF
                                ENDDO
                                NONODS_S = LNNOD
                    !
                                count = 0
                                lnod = 0
                                DO i = 1 , NONODS
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnod = lnod + 1
                                      Lfina(lnod) = count + 1
                                      DO count2 = Fina(i) , Fina(i+1) - 1
                                         micol = Map_L2S(Cola(count2))
                                         IF ( micol.NE.0 ) THEN
                                            count = count + 1
                                            Lcola(count) = micol
                    !                        IF ( Havmat.EQ.1 ) La(count) = A(count2)
                                         ENDIF
                                      ENDDO
                                   ENDIF
                                ENDDO
                                Lfina(lnnod+1) = count + 1
                                lncola = count
                          END SUBROUTINE NEW_PTERS_FOR_SUB
                    ! 
                    ! 
                    
                    
                    ! SET_UP_RECBIS IS A SIMPLIFIED INTERFACE FOR IT **************************
                    
                    ! 
                    !
                           SUBROUTINE python_set_up_recbis(WHICHD0, SPLEVS0,FINA0,COLA0, &
                                         wnod,a, havwnod,havmat,iexact, NSPLT,NCOLA,NNOD,na) 
                    ! This sub splits the domain into subdomains using recursive bisection. 
                    ! SPLEVS(1..NSPLT) contains the dissection information. 
                    ! NSPLT - THE NUMBER OF RECURSIVE GRAPH CUTS
                    ! SPLEVS(I), i=1,NSPLT: FOR RECURSION =I THE NUMBER OF PARTITIONS is SPLEVS(I)
                    ! FINA,COLA is the matrix sparcity using compressed row storage.  
                    ! NNOD = no of nodes. 
                    ! WHICHD(NOD)= subdomain number of node NOD. *********ONLY THING THAT IS RETURNED BY SUBROUTINE****
                    ! if HAVWNOD.ne.0 then assume we have non-unifrom weight for the nodes 
                    ! in WNOD and we decompose to make these about equal. 
                    ! If HAVWNOD=2 then also use the nodal weight for the graph splitting
                    ! If EXACT balance as best we can the number of nodes in each subdomain. 
                    ! only works for uniform WNOD. 
                            IMPLICIT NONE 
                    ! 
                      !      INTEGER, INTENT(IN) :: NSPLT,NCOLA,NNOD, havwnod, havmat
                    !
                            INTEGER, INTENT(IN) :: NSPLT,NCOLA,NNOD,na, havwnod, havmat,iexact
                    !
                            INTEGER, INTENT(OUT) :: WHICHD0(NNOD)
                            INTEGER, INTENT(IN) :: SPLEVS0(NSPLT)
                    !        INTEGER, INTENT(IN) :: SPLEVS0(:)
                            INTEGER, INTENT(IN) :: COLA0(NCOLA),FINA0(NNOD+1)
                            REAL, INTENT(IN) :: WNOD(NNOD),a(na)
                      !      REAL, INTENT(IN) :: WNOD(NNOD), A(NCOLA*HAVMAT)
                         !   REAL, INTENT(IN) :: WNOD(NNOD)
                        !    LOGICAL, INTENT(IN) :: EXACT
                    !        INTEGER, INTENT(IN) :: COLA0(:),FINA0(:)
                    ! LOCAL VARIABLES...
                            LOGICAL IN_PYTHON
                            PARAMETER(IN_PYTHON=.false.)
                            INTEGER, DIMENSION(:), ALLOCATABLE :: SPLEVS, WHICHD, FINA, COLA
                            INTEGER NDOM
                        !    real, DIMENSION(:), ALLOCATABLE :: wnod
                            logical exact
                        !    integer havwnod
                         !   integer havmat
                         !   real a(1)
                    
                    
                         !   print *, "inside fortran subroutine"
                         !   print *, "splev", SPLEVS0
                         !   print *, "shape fina", size(fina0)
                         !   print *, "shape cola", size(cola0)
                         !   print *, "nsplit", nsplt
                         !   print *, "ncola", ncola
                            !print "ii", ii
                    
                    !        stop
                    
                    
                    !      
                    ! Convert variables to fortran type variables...
                           ALLOCATE(SPLEVS(NSPLT))
                           ALLOCATE(WHICHD(NNOD))
                           ALLOCATE(FINA(NNOD+1))
                           ALLOCATE(COLA(NCOLA))
                    !       allocate(wnod(nnod))
                    !       havwnod=2
                    !       WNOD=1.0
                    !       exact=.true.
                           exact = (iexact==1)
                    !       havmat=0
                    
                         if(IN_PYTHON) then
                           COLA(1:NCOLA) = COLA0(1:NCOLA) + 1 
                           FINA(1:NNOD+1) = FINA0(1:NNOD+1) + 1
                           SPLEVS(1:NSPLT) = SPLEVS0(1:NSPLT)
                         else
                           COLA(1:NCOLA) = COLA0(1:NCOLA) 
                           FINA(1:NNOD+1) = FINA0(1:NNOD+1) 
                           SPLEVS(1:NSPLT) = SPLEVS0(1:NSPLT)
                         endif
                    !         print *,'-before SET_UP_RECBIS a:',a
                    !         print *,'before SET_UP_RECBIS IN_PYTHON:',IN_PYTHON
                           
                           CALL SET_UP_RECBIS(SPLEVS,NSPLT,NDOM, &
                                    &  FINA,COLA,NCOLA,NNOD,WHICHD, havwnod,WNOD,exact, havmat,a)
                    !         print *,'after SET_UP_RECBIS'
                         if(IN_PYTHON) then
                           WHICHD0(1:NNOD) = WHICHD(1:NNOD) - 1
                         else
                           WHICHD0(1:NNOD) = WHICHD(1:NNOD)
                         endif
                    !         print *,'after SET_UP_RECBIS IN_PYTHON:',IN_PYTHON
                    !          stop 282
                           
                           END SUBROUTINE python_set_up_recbis
                    !
                    !
                    !       end module
                    
                    
                    
                    
                    !
                    ! Fortran code... 
                           SUBROUTINE SET_UP_RECBIS(SPLEVS,NSPLT,NDOM, &
                         &               FINA,COLA,NCOLA,NNOD,WHICHD, havwnod,WNOD,exact, havmat,a) 
                    ! This sub splits the domain into subdomains using recursive bisection. 
                    ! NDOM=no of subdomains. (not really needed but a good check). 
                    ! SPLEVS(1..NSPLT) contains the dissection information. 
                    ! NSPLT - THE NUMBER OF RECURSIVE GRAPH CUTS
                    ! SPLEVS(I), i=1,NSPLT: FOR RECURSION =I THE NUMBER OF PARTITIONS is SPLEVS(I)
                    ! FINA,COLA is the matrix sparcity using compressed row storage.  
                    ! NNOD = no of nodes. 
                    ! WHICHD(NOD)= subdomain number of node NOD. *********ONLY THING THAT IS RETURNED BY SUBROUTINE****
                    ! FOR NESTED BISSECTION THE SUBDOMAINS ARE ORDERED: 
                    !  1   2   3   4   5   6   7   8   (SUBDOMAIN NUMBERS) 
                    !    1       2       3       4   (SUBDOMAIN 1 AND 2 MAKES UP SUBDOMAIN 1 ON THIS LEVEL) 
                    !        1               2
                    !                1
                    ! In this case NDOM=8, NSPLT=3, SPLEVS(1)=2, SPLEVS(2)=2, SPLEVS(3)=2. 
                    ! if HAVWNOD.ne.0 then assume we have non-unifrom weight for the nodes 
                    ! in WNOD and we decompose to make these about equal. 
                    ! If HAVWNOD=2 then also use the nodal weight for the graph splitting
                    ! If EXACT balance as best we can the number of nodes in each subdomain. 
                    ! only works for uniform WNOD. 
                            IMPLICIT NONE 
                    ! 
                            INTEGER NDOM,NSPLT,SPLEVS(NSPLT)
                            INTEGER NCOLA,NNOD, HAVWNOD, HAVMAT
                    !
                            INTEGER WHICHD(NNOD)
                            INTEGER COLA(NCOLA),FINA(NNOD+1)
                            REAL WNOD(NNOD), A(NCOLA*HAVMAT) 
                    
                    ! LOCAL VARIABES...
                          INTEGER NSUBAL,MAXNLA,MMXTOT
                          INTEGER MULLEV
                          INTEGER MXNSPL,MXNTRE,NCHAIN
                          PARAMETER(MXNSPL=40,MXNTRE=1000)
                             INTEGER, DIMENSION(:), ALLOCATABLE :: LWICHD
                             INTEGER, DIMENSION(:), ALLOCATABLE :: FITREE
                             REAL, DIMENSION(:), ALLOCATABLE :: SUBALA,LSUBAL
                             REAL ALPHA,LODBAL,BETA,TOLER
                             REAL, DIMENSION(:), ALLOCATABLE :: X,Y,LX,LY
                    ! MXNTRE=max no of entries in TREE (suggest 1000 
                    ! so that max no of sub-domains is about 500). 
                             REAL, DIMENSION(:), ALLOCATABLE :: LA
                             INTEGER, DIMENSION(:), ALLOCATABLE :: LCOLA,LFINA
                    !
                    !        REAL, DIMENSION(:), ALLOCATABLE :: RMEM
                            REAL, DIMENSION(:), ALLOCATABLE :: LWNOD
                            INTEGER, DIMENSION(:), ALLOCATABLE :: Q,QTEMP
                            INTEGER, DIMENSION(:), ALLOCATABLE :: MAP
                    !
                    !
                            LOGICAL EXACT
                    
                    !          print *,'just in SET_UP_RECBIS'
                    
                            MMXTOT=max(6*NNOD,1000)
                    !        MMXTOT=max(10*NNOD,1000)
                            MAXNLA=3*NCOLA
                    !        MAXNLA=5*NCOLA
                    
                    !        NRMEM=100*NNOD
                            NSUBAL=NNOD
                    
                            !print *,'help1' 
                            !print *,'nrmem,nNOD:',nrmem,nNOD
                            TOLER=1.E-4
                    !        NCHAIN=3000
                            NCHAIN=300
                            ALPHA=0.98
                            BETA=0.9
                    !        LODBAL=0.1
                            LODBAL=1.0
                    !        LODBAL=10.0
                    !        MULLEV=4
                            MULLEV=8
                    !        MULLEV=6
                    !        print *,'here1 nnod:',nnod
                    
                            ALLOCATE(Q(NNOD),QTEMP(NNOD),MAP(NNOD)) 
                    !        print *,'here1.1'
                            ALLOCATE(X(NNOD),Y(NNOD))
                    !        print *,'here1.2'
                            ALLOCATE(LX(MMXTOT),LY(MMXTOT),LWNOD(MMXTOT),LA(NCOLA*3*havmat)) 
                    !        print *,'here2 nsubal,mxntre:',nsubal,mxntre
                    !        ALLOCATE(RMEM(NRMEM),SUBALA(NSUBAL),LSUBAL(MXNTRE))
                            ALLOCATE(SUBALA(NSUBAL),LSUBAL(MXNTRE))
                    !        print *,'here3'
                            ALLOCATE(LCOLA(MAXNLA),LFINA(MMXTOT+MULLEV)) 
                    !        print *,'here4'
                            ALLOCATE(LWICHD(MMXTOT),FITREE(MXNSPL+2))
                    !        print *,'here5'
                            X=0.0; Y=0.0
                    
                          
                    !        print *,'here6'
                            SUBALA(:)=1.0
                    !        print *,'here7'
                    !        A=1.0
                            LA(:)=1.0
                    !        print *,'here8'
                            LWNOD(1:NNOD) = WNOD(1:NNOD) 
                    !          stop 282 ! in here
                    !          print *,'before recbis a:',a
                    !          print *,'before recbis :'
                    !
                             CALL RECBIS(SPLEVS,NSPLT,MULLEV,  &
                    !     &           RMEM,NRMEM,  &
                         &           FINA,COLA,A,NCOLA,NNOD,MMXTOT,NDOM,WHICHD, &
                         &           LFINA,LCOLA,LA,MAXNLA, &
                         &           NSUBAL, &
                         &           LWICHD,MAP  ,WNOD, LWNOD,  Q,QTEMP, &
                         &           SUBALA,EXACT,ALPHA,LODBAL,BETA,TOLER,NCHAIN, &
                         &           X,Y,LX,LY,HAVMAT, HAVWNOD )
                    !          print *,'after recbis :'
                    
                             RETURN
                             END SUBROUTINE SET_UP_RECBIS
                    !
                    !
                    !
                    !      SUBROUTINE RECBIS(Splevs,Nsplt,Mullev,Rmem,Nrmem,Fina,Cola,A,     &
                          SUBROUTINE RECBIS(Splevs,Nsplt,Mullev,Fina,Cola,A,     &
                                          & Ncola,Nnod,Mmxtot,Ndom,Whichd,Lfina,Lcola,La,   &
                                          & Maxnla,Nsubal,Lwichd,Map,Wnod,Lwnod,Q,Qtemp,    &
                                          & Subala,Exact,Alpha,Lodbal,Beta,Toler,Nchain,X,Y,&
                                          & Lx,Ly,Havmat, HAVWNOD)
                          IMPLICIT NONE
                    !*--RECBIS43
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ii , iii , inlev , isub , maxtot , mxnla2 , Nchain ,  &
                                & nlevel , ntree
                    !*** End of declarations inserted by SPAG
                    ! NB MAP & QTEMP can contain the same storage location.
                    ! This sub splits the domain using recursive bisection.
                    ! SPLEVS(1..NSPLT) contains the dissection information.
                    ! NSPLT - THE NUMBER OF RECURSIVE GRAPH CUTS
                    ! SPLEVS(I), i=1,NSPLT: FOR RECURSION =I THE NUMBER OF PARTITIONS is SPLEVS(I)
                    ! NB LFINA,LCOLA,LMIDPA,LA are defined(working arrays) inside sub.
                    ! WNOD contains the weights of each node.
                    ! MULLEV=no of multi-grid levels.
                    ! MMXTOT is the maximum value of MAXTOT.
                    ! NB it is recommended that MMXTOT=2*NNOD, MAXNLA=2*NCOLA.
                    ! SUBALA() conatains subdomain balancing information.
                    ! HAVMAT=0 if we are not worried about using weights.
                    ! NRMEM=100*NNOD say.
                    ! EXACT WILL EXACTLY BALANCE THE LOAD
                          INTEGER Havmat, HAVWNOD
                          INTEGER MXNSPL , MXNTRE , Nsubal , Maxnla , Mmxtot
                          INTEGER Mullev
                          PARAMETER (MXNSPL=100,MXNTRE=10000000) !MXNTRE=100000)
                          INTEGER Splevs(Nsplt)
                          INTEGER lcount , sub , level , lnnod , micol , Nsplt , lnod
                          INTEGER lncola , across , look , lndom , count , count2
                          INTEGER accum
                          INTEGER Lwichd(Mmxtot) , Map(Nnod)
                          INTEGER fitree(MXNSPL+2) 
                    !      integer tree(MXNTRE)
                          INTEGER Q(Nnod) , Qtemp(Nnod)
                          REAL Subala(Nsubal) 
                    !      real lsubal(MXNTRE)
                          REAL Alpha , Lodbal , Beta , Toler
                          REAL X(Nnod) , Y(Nnod) , Lx(Mmxtot) , Ly(Mmxtot)
                    ! MXNTRE=max no of entries in TREE (suggest 1000
                    ! so that max no of sub-domains is about 500).
                          REAL La(Maxnla*Havmat)
                    !
                          INTEGER Lcola(Maxnla) , Lfina(Mmxtot+Mullev)
                    !
                    !      REAL Rmem(Nrmem)
                          REAL Wnod(Nnod) , Lwnod(Mmxtot)
                    !
                          INTEGER Ncola , Nnod , Ndom
                    !
                          INTEGER Whichd(Nnod)
                          INTEGER Cola(Ncola) , Fina(Nnod+1)
                    !
                          REAL A(Ncola)
                          LOGICAL Exact
                          integer, allocatable:: tree(:)
                          real, allocatable:: lsubal(:)
                    
                    
                    !      print *, 'inside recbis'
                    !
                    !       stop 92
                    !
                    ! FORM POINTERS TO TREE.
                           !print *,'nrmem:',nrmem
                          !WRITE (*,*) 'MXNTRE,NSPLT:' , MXNTRE , Nsplt
                          nlevel = Nsplt + 1
                          count = 0
                          inlev = 1
                          DO level = 1 , nlevel
                             fitree(level) = count + 1
                             IF ( level.EQ.1 ) THEN
                                count = count + 1
                                inlev = 1
                                accum = 1
                             ELSE
                                inlev = inlev*Splevs(level-1)
                                accum = accum + inlev
                                count = accum
                             ENDIF
                          ENDDO
                          fitree(nlevel+1) = count + 1
                    !
                          ntree = count
                          ALLOCATE( tree(ntree+1), lsubal(ntree+1) )!MXNTRE
                    !      ALLOCATE( tree(MXNTRE), lsubal(MXNTRE) )!MXNTRE
                    ! Now put entries in TREE
                          DO level = nlevel , 1 , -1
                             IF ( level.EQ.nlevel ) THEN
                                ii = 0
                                DO count = fitree(level) , fitree(level+1) - 1
                                   ii = ii + 1
                                   tree(count) = ii
                                ENDDO
                                Ndom = ii
                             ELSE
                    ! Choose minimum value from future level.
                                across = 1
                                DO count = fitree(level) , fitree(level+1) - 1
                                   tree(count) = tree(across+fitree(level+1)-1)
                                   across = across + Splevs(level)
                                ENDDO
                             ENDIF
                          ENDDO
                    !      print *,'ntree,nlevel',ntree,nlevel
                    !      print *,'fitree:' , (fitree(i),i=1,nlevel+1)
                    !      print *,'tree:',tree
                    !
                          !WRITE (*,*) 'splevs:' , Splevs
                          !WRITE (*,*) 'fitree:' , (fitree(i),i=1,nlevel+1)
                          DO level = 1 , -nlevel
                             !WRITE (*,*) 'TREE:' ,                                          &
                             !          & (tree(count),count=fitree(level),fitree(level+1)-1)
                          ENDDO
                     
                    !
                    !
                    !
                    ! Split at level 1.
                          lndom = Splevs(1)
                          !WRITE (*,*) 'LNDOM,SPLEVS(1):' , lndom , Splevs(1)
                    !       print *,'a:',a ! no 1000's
                    !        if(maxval(a) > 10.0) stop 192
                    !       stop 281
                    !
                          CALL COPYI(Lfina,Fina,Nnod+1)
                          CALL COPYI(Lcola,Cola,Ncola)
                          IF ( Havmat.EQ.1 ) CALL COPYR(La,A,Ncola)
                          if(havwnod.ne.0) CALL COPYR(Lwnod,Wnod,Nnod)
                          CALL COPYR(Lx,X,Nnod)
                          CALL COPYR(Ly,Y,Nnod)
                          lnnod = Nnod
                    !      maxtot = max(MIN(4*lnnod,Mmxtot),1000)
                    !      maxtot = MIN(4*lnnod,Mmxtot)
                          maxtot = Mmxtot
                    !      print *,'1-LNNOD,Mmxtot, HAVWNOD:',LNNOD,Mmxtot, HAVWNOD
                          CALL SPLIT(Lwichd,maxtot,lnnod,Mullev,lndom,  &
                                   & Lfina,Lcola,La,Maxnla,Q,Qtemp,Lwnod,lsubal,Exact,Alpha,  &
                                   & Lodbal,Beta,Toler,Nchain,Lx,Ly,Havmat, HAVWNOD)
                    !         print *,'done split'
                    !
                    !
                          DO i = 1 , Nnod
                             IF ( Lwichd(i).GE.1 ) Whichd(i) = tree(1+Lwichd(i))
                             IF ( Lwichd(i).LE.0 ) Whichd(i) = Lwichd(i)
                          ENDDO
                          !WRITE (*,*) 'after split'
                          !WRITE (*,*) 'splevs:' , Splevs
                          !WRITE (*,*) 'fitree:' , (fitree(i),i=1,nlevel+1)
                          DO level = 1 , nlevel
                            ! WRITE (*,*) '1-TREE:' ,                                          &
                            !           & (tree(count),count=fitree(level),fitree(level+1)-1)
                          ENDDO
                    !
                    ! count no of nodes in each subdomain
                          DO isub = 1 , lndom
                             ii = 0
                             DO i = 1 , Nnod
                                IF ( Lwichd(i).EQ.isub ) ii = ii + 1
                             ENDDO
                          ENDDO
                    !
                          DO level = 2 , nlevel - 1
                             lndom = Splevs(level)
                             iii = 0
                             DO lcount = fitree(level) , fitree(level+1) - 1
                    ! Look for entries in WHICHD that have values of TREE(LCOUNT),
                    ! form another graph from these and decompose this graph.
                                isub = tree(lcount)
                                lnnod = 0
                                DO i = 1 , Nnod
                                   Map(i) = 0
                                ENDDO
                                DO i = 1 , Nnod
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnnod = lnnod + 1
                    !                 MAPBAK(LNNOD)=I
                                      Map(i) = lnnod
                                      Lwnod(lnnod) = Wnod(i)
                                      Lx(lnnod) = X(i)
                                      Ly(lnnod) = Y(i)
                                   ENDIF
                                ENDDO
                    !
                                count = 0
                                lnod = 0
                                DO i = 1 , Nnod
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnod = lnod + 1
                                      Lfina(lnod) = count + 1
                                      DO count2 = Fina(i) , Fina(i+1) - 1
                                         micol = Map(Cola(count2))
                                         IF ( micol.NE.0 ) THEN
                                            count = count + 1
                                            Lcola(count) = micol
                                            IF ( Havmat.EQ.1 ) La(count) = A(count2)
                                         ENDIF
                                      ENDDO
                                   ENDIF
                                ENDDO
                                Lfina(lnnod+1) = count + 1
                                lncola = count
                                if(lncola>Maxnla) then
                                   stop 2821
                                endif
                    !
                                !WRITE (*,*) '*************LNNOD=' , lnnod
                    !            maxtot = max(4*lnnod,1000)
                    !            maxtot = max(4*lnnod,1000)
                                maxtot = Mmxtot
                          !print *,'2-LNNOD,MAxtot:',LNNOD,MAxtot
                                !mxnla2 = MIN(2*lncola,Maxnla)
                                mxnla2 = Maxnla
                    !            print *,'going in split'
                                CALL SPLIT(Lwichd,maxtot,lnnod,Mullev,lndom,     &
                                         & Lfina,Lcola,La,mxnla2,Q,Qtemp,Lwnod,lsubal,Exact,&
                                         & Alpha,Lodbal,Beta,Toler,Nchain,Lx,Ly,Havmat, HAVWNOD)
                    !            print *,'out'
                    !
                    ! Use MAP again to obtain MAPBAK
                                lnod = 0
                                DO i = 1 , Nnod
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnod = lnod + 1
                    !                 MAPBAK(LNOD)=I
                                      Map(lnod) = i
                                   ENDIF
                                ENDDO
                    ! Put this decomposition in the next level
                                iii = iii + 1
                                DO sub = 1 , lndom
                                   across = (iii-1)*Splevs(level) + sub
                                   look = fitree(level+1) - 1 + across
                                   isub = tree(look)
                                   DO i = 1 , lnnod
                    !                 IF(LWICHD(I).EQ.SUB) WHICHD(MAPBAK(I))=ISUB
                                      IF ( Lwichd(i).LE.0 ) THEN
                                         Whichd(Map(i)) = Lwichd(i)
                                      ELSE
                                         IF ( Lwichd(i).EQ.sub ) Whichd(Map(i)) = isub
                                      ENDIF
                                   ENDDO
                                ENDDO
                    !
                             ENDDO ! DO lcount = fitree(level) , fitree(level+1) - 1
                    !         !print *,'here3'
                          ENDDO ! DO level = 2 , nlevel - 1
                    !         !print *,'here4 exiting RECBIS'
                          deallocate( tree, lsubal )
                          END SUBROUTINE RECBIS
                    !*==COPYI.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE COPYI(Lcola,Cola,Ncola)
                          IMPLICIT NONE
                    !*--COPYI263
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , Ncola
                    !*** End of declarations inserted by SPAG
                          INTEGER Lcola(Ncola) , Cola(Ncola)
                          DO i = 1 , Ncola
                             Lcola(i) = Cola(i)
                          ENDDO
                          END
                    !*==COPYR.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                          SUBROUTINE COPYR(Lcola,Cola,Ncola)
                          IMPLICIT NONE
                    !*--COPYR277
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , Ncola
                    !*** End of declarations inserted by SPAG
                          REAL Lcola(Ncola) , Cola(Ncola)
                          DO i = 1 , Ncola
                             Lcola(i) = Cola(i)
                          ENDDO
                          END
                    !*==SPLIT_SIMPL.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE SPLIT_SIMPL(Simp_whichd,Nonods,Onsubd,Simp_fina,       &
                                               & Simp_cola,Simp_a,Simp_ncola,Simp_wnod)
                          IMPLICIT NONE
                    !*--SPLIT_SIMPL294
                    !*** Start of declarations inserted by SPAG
                          INTEGER maxna , nchain , Nonods
                    !*** End of declarations inserted by SPAG
                          INTEGER havmat
                          INTEGER mxnlev
                          parameter(mxnlev=4)
                    ! **********NEW INTERFACE*********
                    ! NONODS=number of vertices or nodes in the graph to be decomposed.
                    ! SIMP_WNOD() is the weight of each node - for load balancing.
                    ! ONSUBD=no of subdomains.
                    ! SIMP_WHICHD = domain each node belongs too. THE OUTPUT OF THIS SUB
                    ! SIMP_A contains the edge weights for the graph partitioning and stored
                    ! using compact row storage in SIMP_FINA,SIMP_COLA.
                     
                    ! **********THE PREVIOUS INTERFACE*********
                    ! MXNLEV is the maximum number of multi-grid levels. E.G. 4
                    ! NLEVEL is now the number of multi-grid levels e.g. set to 4.
                    ! NONODS=number of vertices or nodes in the graph to be decomposed.
                    ! WNOD() is the weight of each node - for load balancing.
                    ! ONSUBD=no of subdomains.
                    ! SUBAL(1..ONSUBD) contains the load for each processor. e.g. =1.0
                    ! LODBAL gives the importance of balancing the load default is 1
                    ! if EXACT then as near as possible load balance.
                    ! WNOD=weight for each node.
                    ! WHICHD = domain each node belongs too. THE OUTPUT OF THIS SUB
                    ! A contains the edge weights for the graph partitioning and stored
                    ! using compact row storage in FINA,COLA.
                    ! HAVMAT=1 if we strore the matrix.
                    ! ALSO the compact row storage is in FINA, COLA
                    ! RMEM contains a long real working array e.g. NRMEM=100 * NONODS
                    ! Q,QTEMP contains working arrays.
                    ! BETA controls the crytical temp e.g. BETA=0.9
                    ! ALPHA how BETA is annealed donw e.g. ALPHA=0.98
                    ! TOLER tolerence for the iterations e.g. TOLER=1.E-4
                    ! NCHAIN =maximum no of iterations 3000 is suggested.
                    ! MAXTOT=3*nonods is default.
                    !
                          INTEGER maxtot , Onsubd , Simp_ncola
                    ! MAXTOT is the maximum value of TOTNOD allowed.
                          INTEGER Simp_whichd(Nonods)
                          INTEGER Simp_cola(Simp_ncola) , Simp_fina(Nonods+1)
                          REAL Simp_a(Simp_ncola) , Simp_wnod(Nonods)
                    ! Local variables...
                          LOGICAL exact
                          REAL, allocatable :: rmem(:) , x(:) , y(:) , a(:) , wnod(:)
                          INTEGER, allocatable :: q(:) , qtemp(:)
                          INTEGER, allocatable :: cola(:) , fina(:) , whichd(:)
                          INTEGER nrmem , nlevel , totnod
                          REAL alpha , beta , toler , subal(Onsubd) , lodbal
                          INTEGER nodlev(mxnlev+1) , ptcola(mxnlev+1)
                          integer havwnod
                     
                          maxtot = 3*Nonods
                          exact = .FALSE.
                          nlevel = mxnlev
                          maxna = 3*Simp_ncola
                          nrmem = 100*Nonods
                          subal(:) = 1.0
                          toler = 1.E-4
                          nchain = 3000
                          alpha = 0.98
                          beta = 0.9
                          havmat = 1
                          lodbal = 1.0
                          havwnod=0
                     
                     
                          ALLOCATE (rmem(nrmem),x(maxtot),y(maxtot),a(maxna),wnod(maxtot))
                          ALLOCATE (q(Nonods),qtemp(Nonods))
                          ALLOCATE (cola(maxna),fina(maxtot+nlevel))
                          ALLOCATE (whichd(maxtot))
                          cola(1:Simp_ncola) = Simp_cola(1:Simp_ncola)
                          fina(1:Nonods+1) = Simp_fina(1:Nonods+1)
                          a(1:Simp_ncola) = Simp_a(1:Simp_ncola)
                          wnod(1:Nonods) = Simp_wnod(1:Nonods)
                     
                          CALL SPLIT(whichd,maxtot,Nonods,nlevel,Onsubd,    &
                                   & fina,cola,a,maxna,q,qtemp,wnod,subal,exact,alpha, &
                                   & lodbal,beta,toler,nchain,x,y,havmat, havwnod)
                     
                          Simp_whichd(1:Nonods) = whichd(1:Nonods)
                     
                          END
                    !*==SPLIT.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                     
                     
                    ! 
                    !
                          SUBROUTINE SPLIT(Whichd,Maxtot,Nonods,Nlevel,Onsubd,   &
                                         & Fina,Cola,A,Maxna,Q,Qtemp,Wnod,Subal,Exact,Alpha,&
                                         & Lodbal,Beta,Toler,Nchain,X,Y,Havmat, havwnod) 
                          IMPLICIT NONE
                    !*--SPLIT387
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ii , isub , na , Nchain , need , Nlevel , Nonods 
                    !*** End of declarations inserted by SPAG
                          INTEGER Havmat
                          INTEGER MAX_mxnlev
                          PARAMETER(MAX_MXNLEV=100) 
                          LOGICAL MISS_OUT_2NODS,DYNAMIC_NCHAIN
                          PARAMETER(MISS_OUT_2NODS=.TRUE.) ! If we have two nodes or less then assign partition and scip code.
                          PARAMETER(DYNAMIC_NCHAIN=.TRUE.)
                    !      PARAMETER(MISS_OUT_2NODS=.false.) ! If we have two nodes or less then assign partition and scip code.
                    !      PARAMETER(DYNAMIC_NCHAIN=.false.)
                    ! MXNLEV is the maximum number of multi-grid levels. E.G. 4
                    ! NLEVEL is now the number of multi-grid levels e.g. set to 4.
                    ! NONODS=number of vertices or nodes in the graph to be decomposed.
                    ! WNOD() is the weight of each node - for load balancing.
                    ! ONSUBD=no of subdomains.
                    ! SUBAL(1..ONSUBD) contains the load for each processor. e.g. =1.0
                    ! LODBAL gives the importance of balancing the load default is 1
                    ! if EXACT then as near as possible load balance.
                    ! WNOD=weight for each node.
                    ! WHICHD = domain each node belongs too. THE OUTPUT OF THIS SUB
                    ! A contains the edge weights for the graph partitioning and stored
                    ! using compact row storage in FINA,COLA.
                    ! HAVMAT=1 if we strore the matrix.
                    ! ALSO the compact row storage is in FINA, COLA
                    ! RMEM contains a long real working array e.g. NRMEM=100 * NONODS
                    ! Q,QTEMP contains working arrays.
                    ! BETA controls the crytical temp e.g. BETA=0.9
                    ! ALPHA how BETA is annealed donw e.g. ALPHA=0.98
                    ! TOLER tolerence for the iterations e.g. TOLER=1.E-4
                    ! NCHAIN =maximum no of iterations 3000 is suggested.
                    ! MAXTOT=3*nonods is default.
                    ! IF EXACT balce the no of nodes in each subdomain.
                          INTEGER nodlev(MAX_mxnlev+1) , ptcola(MAX_mxnlev+1)
                    !
                          INTEGER Maxtot , totnod , Onsubd , Maxna, havwnod
                          REAL Lodbal
                    ! MAXTOT is the maximum value of TOTNOD allowed.
                          INTEGER mxnlev
                          INTEGER Whichd(Maxtot)
                          INTEGER Cola(Maxna) , Fina(Maxtot+Nlevel)
                          INTEGER Q(Nonods) , Qtemp(Nonods)
                          REAL A(Maxna*Havmat) , Alpha , Beta , Toler , Subal(Onsubd)
                          REAL WNOD(MAXTOT)
                          LOGICAL Exact
                    !      REAL Rmem(Nrmem)
                          REAL X(Maxtot) , Y(Maxtot)
                          INTEGER NCHAIN2
                    
                          INTEGER, DIMENSION(:), ALLOCATABLE :: LIST,whichd_new,whichd_long
                          REAL, DIMENSION(:), ALLOCATABLE :: V_NEW,B_NEW,TSCALE_NEW
                    
                          IF(MISS_OUT_2NODS) THEN
                             IF(NONODS.LE.2) THEN
                    !            PRINT *,'-------SKIPPING DOMAIN DECOMP NONODS=',NONODS
                                if(nonods.ge.1) Whichd(1:nonods)=1
                                IF(NONODS==2) Whichd(NONODS)=2
                                RETURN
                             ENDIF
                          ENDIF
                    
                          ALLOCATE(LIST(NONODS))
                    !         print *,'a:',a ! this a does not have 1000 in it. 
                    !          stop 291
                    !       print *,'in 1'
                    
                    !
                          CALL FORMA(Whichd,Maxtot,totnod,Nonods,nodlev,ptcola,Nlevel,Fina, &
                                   & Cola,A,Maxna,na,Whichd,Q,Qtemp,LIST,X,Y,Havmat)
                    !       print *,'in 2'
                    ! This sub finds the subdomains.
                          ALLOCATE(whichd_new(maxtot))
                          ALLOCATE(V_NEW(Totnod*Onsubd),B_NEW(Nonods*Onsubd),TSCALE_NEW(NONODS))
                    !       print *,'in 3'
                    
                          !WRITE (*,*) 'totnod,onsubd=' , totnod , Onsubd
                    ! !print out all the levels
                    !       DO 82 ILEVEL=NLEVEL,1,-1
                    !        NCOLA2=PTCOLA(ILEVEL+1)-PTCOLA(ILEVEL)
                    !        NNOD2=NODLEV(ILEVEL+1)-NODLEV(ILEVEL)
                    !         CALL DRAXYZ(X(NODLEV(ILEVEL)),Y(NODLEV(ILEVEL)),
                    !     &     FINA(NODLEV(ILEVEL)+ILEVEL-1),COLA(PTCOLA(ILEVEL)),
                    !     &     NCOLA2,NNOD2)
                    !82     CONTINUE
                    !       STOP
                    
                            !print *,'nonods,totnod,onsubd:',nonods,totnod,onsubd
                    !        stop 221
                     
                    !
                    !      need = Onsubd*totnod + Onsubd*Nonods + Nonods + 1
                    !      IF ( Nrmem.LT.need ) THEN
                    !         WRITE (*,*) 'NOT ENOUGH MEMORY IN SPLIT'
                    !         WRITE (*,*) 'we need:' , need , ' reals'
                    !         WRITE (*,*) 'we have ' , Nrmem , ' reals'
                    !         STOP
                    !      ENDIF
                          !WRITE (*,*) 'INSIDE SPLIT ABOUT TO ENTER NEUR'
                          !WRITE (*,*) 'MAXNA,NA,onsubd:' , Maxna , na , Onsubd
                         ! WRITE (*,*) 'mxnlev,NLEVEL,ALPHA,LODBAL,BETA,TOLER,NCHAIN:' ,     &
                         !           & mxnlev , Nlevel , Alpha , Lodbal , Beta , Toler ,     &
                         !           & Nchain
                          IF(DYNAMIC_NCHAIN) THEN
                             NCHAIN2=MAX(30,  MIN(300,NONODS/2) )
                          ELSE
                             NCHAIN2=NCHAIN
                          ENDIF
                    !
                    ! NB V,B,TSCALE are stored in RMEM.
                    !        CALL NEUR(WHICHD,WHICHD,V,B,TSCALE,
                           if(totnod.lt.nonods) stop 3932
                           if(maxtot.lt.max(totnod,nonods)) stop 3933
                           whichd_new(1:totnod)=whichd(1:totnod)
                    !      CALL NEUR(Whichd_long,Whichd_new,V_NEW,B_NEW,TSCALE_NEW, nodlev,ptcola,      &
                    !         print *,'entering neur'
                          CALL NEUR(Whichd,Whichd_new,V_NEW,B_NEW,TSCALE_NEW, nodlev,ptcola,      &
                                  & totnod,Nonods,Onsubd,Fina,Cola,A,na,Nlevel,Alpha,Lodbal,&
                                  & Beta,Toler,Nchain2,Havmat,exact, havwnod,wnod)
                    !         print *,'out of neur'
                    ! count no of nodes in each subdomain
                          !WRITE (*,*) 'inside split onsubd,nonods:' , Onsubd , Nonods
                          DO isub = 1 , Onsubd
                             ii = 0
                             DO i = 1 , Nonods
                                IF ( Whichd(i).EQ.isub ) ii = ii + 1
                             ENDDO
                             !WRITE (*,*) 'no of nodes in sub=' , isub , ' is =' , ii
                          ENDDO
                    !        DO 79 ILEVEL=1,NLEVEL
                    !          NNOD2=NODLEV(ILEVEL+1)-NODLEV(ILEVEL)
                    !          MAXNA2=PTCOLA(ILEVEL+1)-PTCOLA(ILEVEL)
                    !
                    !            CALL DRAHAL(X(NODLEV(ILEVEL)),Y(NODLEV(ILEVEL)),
                    !     &        FINA(NODLEV(ILEVEL)+ILEVEL-1),
                    !     &        COLA(PTCOLA(ILEVEL)),MAXNA2,NNOD2,
                    !     &        WHICHD(NODLEV(ILEVEL)) )
                    !79       CONTINUE
                          RETURN 
                          END SUBROUTINE SPLIT
                    !*==COUDOM.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE COUDOM(Whichd,Nonods,Fina,Cola,Ncola)
                          IMPLICIT NONE
                    !*--COUDOM488
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , icol , icount , ii , imax , imin , isub , Ncola ,     &
                                & noint , Nonods
                    !*** End of declarations inserted by SPAG
                    ! this sub counts the number of subdomains.
                          INTEGER Whichd(Nonods) , Fina(Nonods+1) , Cola(Ncola)
                          imax = -1000
                          imin = 1000
                          DO i = 1 , Nonods
                             imax = MAX(Whichd(i),imax)
                             imin = MIN(Whichd(i),imax)
                          ENDDO
                          DO isub = imax , imin
                             ii = 0
                             DO i = 1 , Nonods
                                IF ( Whichd(i).EQ.isub ) ii = ii + 1
                             ENDDO
                     
                          ENDDO
                    ! count the interface nodes
                          noint = 0
                          DO i = 1 , Nonods
                             DO icount = Fina(i) , Fina(i+1) - 1
                                icol = Cola(icount)
                                IF ( Whichd(i).NE.Whichd(icol) ) noint = noint + 1
                             ENDDO
                          ENDDO
                          noint = noint/2
                          !print * , 'no of edges between subs =' , noint
                          END
                    !*==RECBI2.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE RECBI2(Splevs,Nsplt,Rmem,Nrmem,Fina,Cola,Midpa,A,Ncola,&
                                          & Nnod,Ndom,Whichd,Lfina,Lcola,Lmidpa,La,Tempd,Km,&
                                          & Kmtemp,Random,Power,Optim,Chopar,Chopa3,Chopa4, &
                                          & Halo,Fitree,Tree,Mxntre,Lwichd,Map,Mxldom,Wnod, &
                                          & Lwnod)
                          IMPLICIT NONE
                    !*--RECBI2530
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ii , iii , inlev , isub , Mxntre , nlevel , Nrmem ,   &
                                & ntree
                    !*** End of declarations inserted by SPAG
                    ! This sub splits the domain using recursive bisection.
                    ! SPLEVS(1..NSPLT) contains the dissection information.
                    ! NB LFINA,LCOLA,LMIDPA,LA are defined(working arrays) inside sub.
                    !         INTEGER MXSPLT
                    !         PARAMETER(MXSPLT=20)
                    !         INTEGER SPLEVS(MXSPLT)
                          INTEGER Splevs(Nsplt)
                          INTEGER lcount , sub , level , lnnod , micol , Nsplt , lnod
                          INTEGER lncola , across , look , lndom , count , count2
                          INTEGER Mxldom , accum
                          INTEGER Lwichd(Nnod) , Map(Nnod)
                          INTEGER Fitree(Nsplt+2) , Tree(Mxntre)
                          INTEGER Power , Optim
                    ! MXNTRE=max no of entries in TREE (suggest 1000
                    ! so that max no of sub-domains is about 500).
                          REAL La(Ncola)
                    !
                          INTEGER Lmidpa(Nnod) , Lcola(Ncola) , Lfina(Nnod+1)
                          REAL Lwnod(Nnod)
                    !
                          INTEGER Halo
                          REAL Rmem(Nrmem)
                          REAL Wnod(Nnod)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          REAL Km(Mxldom) , Kmtemp(Mxldom)
                          INTEGER Tempd(Nnod)
                    !
                          INTEGER Chopar(Nnod) , Chopa3(Nnod) , Chopa4(Nnod)
                          INTEGER Whichd(Nnod)
                          INTEGER Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                    !
                          REAL A(Ncola)
                          LOGICAL Random
                     
                    ! FORM POINTERS TO TREE.
                          nlevel = Nsplt + 1
                          count = 0
                          inlev = 1
                          DO level = 1 , nlevel
                             Fitree(level) = count + 1
                             IF ( level.EQ.1 ) THEN
                                count = count + 1
                                inlev = 1
                                accum = 1
                             ELSE
                                inlev = inlev*Splevs(level-1)
                                accum = accum + inlev
                                count = accum
                             ENDIF
                          ENDDO
                          Fitree(nlevel+1) = count + 1
                    ! NB NTREE might have to be worked out befor hand.
                          ntree = count
                    ! Now put entries in TREE
                          DO level = nlevel , 1 , -1
                             IF ( level.EQ.nlevel ) THEN
                                ii = 0
                                DO count = Fitree(level) , Fitree(level+1) - 1
                                   ii = ii + 1
                                   Tree(count) = ii
                                ENDDO
                                Ndom = ii
                             ELSE
                    ! Choose minimum value from future level.
                                across = 1
                                DO count = Fitree(level) , Fitree(level+1) - 1
                                   Tree(count) = Tree(across+Fitree(level+1)-1)
                                   across = across + Splevs(level)
                                ENDDO
                             ENDIF
                          ENDDO
                     
                     
                    ! Split at level 1.
                          lndom = Splevs(1)
                     
                          CALL SPLIT2(Rmem,Nrmem,Fina,Cola,Midpa,A,Ncola,Nnod,lndom,Lwichd, &
                                    & Tempd,Km,Kmtemp,Random,Power,Optim,Chopar,Chopa3,     &
                                    & Chopa4,Halo,Wnod)
                    !
                    !
                          DO i = 1 , Nnod
                             IF ( Lwichd(i).GE.1 ) Whichd(i) = Tree(1+Lwichd(i))
                             IF ( Lwichd(i).LE.0 ) Whichd(i) = Lwichd(i)
                          ENDDO
                    !
                    !
                          DO level = 2 , nlevel - 1
                             lndom = Splevs(level)
                             iii = 0
                             DO lcount = Fitree(level) , Fitree(level+1) - 1
                    ! Look for entries in WHICHD that have values of TREE(LCOUNT),
                    ! form another graph from these and decompose this graph.
                                isub = Tree(lcount)
                                lnnod = 0
                                DO i = 1 , Nnod
                                   Map(i) = 0
                                ENDDO
                                DO i = 1 , Nnod
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnnod = lnnod + 1
                    !                 MAPBAK(LNNOD)=I
                                      Map(i) = lnnod
                                      Lwnod(lnnod) = Wnod(i)
                                   ENDIF
                                ENDDO
                    !
                                count = 0
                                lnod = 0
                                DO i = 1 , Nnod
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnod = lnod + 1
                                      Lfina(lnod) = count + 1
                                      DO count2 = Fina(i) , Fina(i+1) - 1
                                         micol = Map(Cola(count2))
                                         IF ( micol.NE.0 ) THEN
                                            count = count + 1
                                            Lcola(count) = micol
                                            La(count) = A(count2)
                                         ENDIF
                                      ENDDO
                                   ENDIF
                                ENDDO
                                Lfina(lnnod+1) = count + 1
                                lncola = count
                    !
                                DO i = 1 , lnnod
                                   DO count2 = Lfina(i) , Lfina(i+1) - 1
                                      IF ( Lcola(count2).EQ.i ) Lmidpa(i) = count2
                                   ENDDO
                                ENDDO
                     
                                CALL SPLIT2(Rmem,Nrmem,Lfina,Lcola,Lmidpa,La,lncola,lnnod,  &
                                          & lndom,Lwichd,Tempd,Km,Kmtemp,Random,Power,Optim,&
                                          & Chopar,Chopa3,Chopa4,Halo,Lwnod)
                    !
                    ! Use MAP again to obtain MAPBAK
                                lnod = 0
                                DO i = 1 , Nnod
                                   IF ( Whichd(i).EQ.isub ) THEN
                                      lnod = lnod + 1
                    !                 MAPBAK(LNOD)=I
                                      Map(lnod) = i
                                   ENDIF
                                ENDDO
                    ! Put this decomposition in the next level
                                iii = iii + 1
                                DO sub = 1 , lndom
                                   across = (iii-1)*Splevs(level) + sub
                                   look = Fitree(level+1) - 1 + across
                                   isub = Tree(look)
                                   DO i = 1 , lnnod
                    !                 IF(LWICHD(I).EQ.SUB) WHICHD(MAPBAK(I))=ISUB
                                      IF ( Lwichd(i).LE.0 ) THEN
                                         Whichd(Map(i)) = Lwichd(i)
                                      ELSE
                                         IF ( Lwichd(i).EQ.sub ) Whichd(Map(i)) = isub
                                      ENDIF
                                   ENDDO
                                ENDDO
                    !
                             ENDDO
                          ENDDO
                          END
                    !*==SPLIT2.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE SPLIT2(Rmem,Nrmem,Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,   &
                                          & Whichd,Tempd,Km,Kmtemp,Random,Power,Optim,      &
                                          & Chopar,Chopa3,Chopa4,Halo,Wnod)
                          IMPLICIT NONE
                    !*--SPLIT2710
                    !*** Start of declarations inserted by SPAG
                          INTEGER ii , iii , iiii , iiiv , iiv , iv , Nrmem
                          REAL rbeta , rtr
                    !*** End of declarations inserted by SPAG
                    ! This sub does the graph splitting.
                    !
                          INTEGER Halo
                          REAL Rmem(Nrmem)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          REAL Km(Ndom) , Kmtemp(Ndom)
                          REAL Wnod(Nnod)
                          INTEGER Tempd(Nnod)
                          INTEGER nparts , npart3 , npart4 , ndom2 , nnod2
                    !
                          INTEGER Chopar(Nnod) , Chopa3(Nnod) , Chopa4(Nnod)
                          INTEGER Whichd(Nnod)
                          INTEGER Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          INTEGER Power , Optim
                          INTEGER, ALLOCATABLE :: Noinsu(:)
                    !
                          REAL A(Ncola)
                          LOGICAL Random
                    
                          ALLOCATE(Noinsu(ndom))
                     
                          rbeta = 1./(2.**MAX(0,Ndom-2))
                          rbeta = SQRT(rbeta)
                     
                          CALL MESH(rbeta,Wnod,Fina,Cola,Midpa,A,Ncola,Nnod)
                     
                    ! This sub finds the subdomains using a replicator approach.
                          nparts = INT(REAL(Nnod)**0.75)
                          npart3 = INT(REAL(Nnod)**0.5)
                          npart4 = INT(REAL(Nnod)**0.25)
                     
                          ndom2 = Ndom
                          nnod2 = Nnod
                          ii = Ndom*Nnod + 1
                          iii = 2*Ndom*Nnod + 1
                          iiii = 2*Ndom*Nnod + Ndom*nparts + 1
                          iv = 2*Ndom*Nnod + Ndom*nparts + Ndom*npart3 + 1
                          iiv = 2*Ndom*Nnod + Ndom*nparts + Ndom*npart3 + Ndom*npart4 + 1
                          iiiv = 2*Ndom*Nnod + Ndom*nparts + Ndom*npart3 + Ndom*npart4 +    &
                               & Ndom + 1
                          IF ( iiiv+Ndom+1.GT.Nrmem ) THEN
                            ! WRITE (0,*) 'ERROR: NOT ENOUGH MEMORY PASSED DOWN FOR '//      &
                            !            &'PARTITIONING IN THIS MANNER.'
                             GOTO 99999
                          ENDIF
                     
                          CALL ANNEAL(nparts,npart3,npart4,ndom2,nnod2,Rmem(1),Rmem(ii),rtr,&
                                    & Rmem(iii),Rmem(iiii),Rmem(iv),Rmem(iiv),Rmem(iiiv),   &
                                    & Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Km,    &
                                    & Kmtemp,Random,Power,Optim,Chopar,Chopa3,Chopa4)
                    !
                    ! Find a set of interface nodes. -RESCALE MATRIX FOR NEURAL NETWORK.
                    !
                          IF ( Halo.EQ.0 ) THEN
                    !
                             rbeta = 1.
                             CALL MESH(rbeta,Wnod,Fina,Cola,Midpa,A,Ncola,Nnod)
                    !
                             CALL NEURI(ndom2,nnod2,Rmem(1),Rmem(nnod2*(ndom2+1)+1),Fina,   &
                                      & Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,                &
                    !                  & Rmem(nnod2*(ndom2+2)+1),                            &
                                      & Noinsu,                            &
                                      & Rmem(nnod2*(ndom2+2)+ndom2+2),                      &
                                      & Rmem(nnod2*(ndom2+2)+2*ndom2+4),Optim)
                     
                    !
                          ENDIF
                    99999 END
                    !*==ANNEAL.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE ANNEAL(Nparts,Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,      &
                                          & Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,Fina,Cola,   &
                                          & Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Km,Kmtemp, &
                                          & Random,Power,Optim,Chopar,Chopa3,Chopa4)
                          IMPLICIT NONE
                    !*--ANNEAL789
                    !*** Start of declarations inserted by SPAG
                          REAL alpha , FRAC , rrscal
                          INTEGER i , ii , isub , itcoun , its , nchain , NOITS
                    !*** End of declarations inserted by SPAG
                    !
                    ! FRAC=termination criterion.
                    !
                          INTEGER CHEND
                    !
                          LOGICAL SIMPLE
                    ! If we have no exceptances for CHEND iterations then end.
                          PARAMETER (SIMPLE=.FALSE.)
                    ! if KEEPLI then the cooling schedual attempts to keep
                    ! a linear relation ship between the number if excepted
                    ! iteration and ITS.
                    !        PARAMETER(CHEND=3,FRAC=0.03)
                          PARAMETER (CHEND=3,FRAC=0.01)
                    !
                          PARAMETER (NOITS=1000)
                    !        PARAMETER(NOITS=20)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          REAL c , pcost , ncost , initic
                          REAL Km(Ndom) , Kmtemp(Ndom)
                          INTEGER sub , newsub , oldsub , newnod
                          INTEGER Tempd(Nnod) , nexcp , sumex
                          INTEGER chain
                          INTEGER Nparts , Npart3 , Npart4 , Ndom2 , Nnod2
                    !
                          INTEGER Chopar(Nnod) , Chopa3(Nnod) , Chopa4(Nnod)
                          INTEGER Whichd(Nnod)
                          INTEGER Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          INTEGER Power , Optim
                    !
                          REAL R(Ndom2*Nnod2) , R2(Ndom2*Nnod2)
                          REAL Prodm2(Ndom2) , Rtrpar(Ndom2*Nparts)
                          REAL Rtrsub(Ndom2)
                          REAL Rtrpa3(Ndom2*Npart3) , Rtrpa4(Ndom2*Npart4)
                          REAL Rtr
                          REAL A(Ncola)
                          LOGICAL yes , gotc
                          LOGICAL Random
                     
                          alpha = 0
                          nchain = 0
                          IF ( alpha.LT.0.1 ) alpha = 0.98
                     
                          rrscal = REAL(Optim)/20.
                          nchain = int( rrscal*real((Fina(Nnod+1)-1)*(Ndom-1))/100. )
                     
                    ! This sub finds a partition using an annealing approach.
                     
                    !  Initialise, Find a good initial guess.
                          Ncola = Fina(Nnod+1) - 1
                          CALL INGUES(Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Random)
                    ! Find an initial C.
                          CALL FININI(nchain,initic,pcost,gotc,Nparts,Npart3,Npart4,Ndom2,  &
                                    & Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,    &
                                    & Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Km,    &
                                    & Kmtemp,Random,Power,Chopar,Chopa3,Chopa4)
                    !        GOTC=.FALSE.
                    !        INITIC=100000
                          DO i = 1 , Nnod
                             Tempd(i) = Whichd(i)
                          ENDDO
                    ! work out R & R2 and PCOST
                          CALL FIDERC(pcost,Nparts,Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,      &
                                    & Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,Fina,Cola,Midpa,A, &
                                    & Ncola,Nnod,Ndom,Whichd,Km,Kmtemp,Chopar,Chopa3,Chopa4,&
                                    & Power)
                    !
                          sumex = 0
                    !        C=INITIC
                          c = pcost*0.2
                    !        C=PCOST*0.2
                          itcoun = 0
                          DO its = 1 , NOITS
                             itcoun = itcoun + 1
                             IF ( (.NOT.gotc) .AND. ((its).EQ.10) ) THEN
                                gotc = .TRUE.
                                c = pcost*0.2
                             ENDIF
                    !          IF(ITS.EQ.15) C=PCOST*0.2
                    !          IF(ITS.EQ.50) C=2.0E+11
                             nexcp = 0
                             DO chain = 1 , nchain
                    ! Find a neighbourhood configuration
                                CALL FINEIG(newsub,newnod,oldsub,Nparts,Npart3,Npart4,Ndom2,&
                                          & Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,     &
                                          & Prodm2,Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,&
                                          & Tempd,Power)
                                IF ( newsub.NE.oldsub ) THEN
                    ! find cost of neighbourhood config
                    !              CALL FICOSK(NCOST,PCOST,NEWSUB,OLDSUB,NEWNOD)
                                   CALL FICOSK(ncost,pcost,newsub,oldsub,newnod,Fina,Cola,  &
                                             & Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Km,     &
                                             & Kmtemp)
                    ! See if we except this config.
                                   CALL EXCEPT(pcost,ncost,c,yes)
                    !               yes=.true.
                                   IF ( yes ) THEN
                                      nexcp = nexcp + 1
                                      pcost = ncost
                                      Whichd(newnod) = newsub
                                      DO sub = 1 , Ndom
                                         Km(sub) = Kmtemp(sub)
                                      ENDDO
                                      IF ( .NOT.SIMPLE )                                    &
                                         & CALL UPDERI(ncost,newsub,newnod,oldsub,Nparts,   &
                                         & Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,&
                                         & Rtrpa4,Rtrsub,Prodm2,Fina,Cola,Midpa,A,Ncola,    &
                                         & Nnod,Ndom,Whichd,Km,Kmtemp,Chopar,Chopa3,Chopa4, &
                                         & Power)
                                   ELSE
                                      Tempd(newnod) = Whichd(newnod)
                                   ENDIF
                                ENDIF
                             ENDDO
                            ! WRITE (*,*) 'pcost=' , pcost , ' its=' , its , ' NEXCP=' ,     &
                            !           & nexcp , ' c=' , c
                    !
                             c = alpha*c
                    !
                             sumex = sumex + nexcp
                             IF ( ((its/CHEND)*CHEND.EQ.its) .AND. (its.GT.30) ) THEN
                    ! Check for convergence
                                IF ( sumex.LT.CHEND*FRAC*nchain ) GOTO 100
                                sumex = 0
                             ENDIF
                             IF ( itcoun*nchain.GT.500000 ) THEN
                                CALL FIDERC(pcost,Nparts,Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,&
                                          & Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,Fina,Cola,   &
                                          & Midpa,A,Ncola,Nnod,Ndom,Whichd,Km,Kmtemp,Chopar,&
                                          & Chopa3,Chopa4,Power)
                    !
                                !WRITE (*,*) 'call FIDERC *******************'
                                itcoun = 0
                             ENDIF
                          ENDDO
                     100  CALL FIDERC(pcost,Nparts,Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,      &
                                    & Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,Fina,Cola,Midpa,A, &
                                    & Ncola,Nnod,Ndom,Whichd,Km,Kmtemp,Chopar,Chopa3,Chopa4,&
                                    & Power)
                          !WRITE (*,*) 'pcost=' , pcost
                    ! ********************* OUTPUT THE RESULTS **********************
                          DO isub = 1 , Ndom
                             ii = 0
                             DO i = 1 , Nnod
                                IF ( Whichd(i).EQ.isub ) ii = ii + 1
                             ENDDO
                             !WRITE (*,*) 'no of nodes in sub=' , isub , ' is =' , ii
                          ENDDO
                    !
                          END
                    !*==INGUES.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE INGUES(Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd, &
                                          & Random)
                          IMPLICIT NONE
                    !*--INGUES952
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iarg , icol , idom , indval , iran , istart , its ,   &
                                & ival , Ndom , nq , nqtemp
                          REAL RAN1 , rran , sub
                    !*** End of declarations inserted by SPAG
                    !
                          INTEGER Ncola , Nnod
                          INTEGER Whichd(Nnod) , Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          INTEGER Tempd(Nnod)
                    !
                    !      INTEGER MINVAL,TEMPD(MAXNOD),ROW,COUNT
                          INTEGER minval , row , count
                          LOGICAL Random
                    !
                          IF ( Random ) THEN
                             DO i = 1 , Nnod
                    !
                                iarg = 1
                    !
                                rran = RAN1(iarg)
                                IF ( rran.GE.1 ) rran = 0.999999
                                iran = INT(rran*REAL(Nnod*Ndom)+1.)
                    !
                                sub = ((iran-1)/Nnod) + 1
                                Whichd(i) = int( sub )
                                Tempd(i) = int( sub )
                             ENDDO
                          ELSE
                             DO i = 1 , Nnod
                                Whichd(i) = 0
                                Tempd(i) = 0
                             ENDDO
                    !       write(*,*)'**********************'
                    !      do 11 i=1,nnod
                    !        i=286
                    !        write(*,*)'i=',i,'fina(I)=',fina(I),' fina(i+1)=',fina(i+1)
                    !11    continue
                    ! Find MIN VALANCY NODE.
                             DO idom = 1 , Ndom
                    !         DO 30 IDOM=1,1
                                nq = 0
                                istart = 1
                     20         nqtemp = nq + 1
                                !print * , 'idom :' , idom , ' nq1 :' , nq , ' nqtemp :' ,   &
                                !    & nqtemp
                    !
                                minval = 10000
                                indval = 0
                                DO i = 1 , Nnod
                    !           write(*,*)'i=',i,'whichd(i)=',whichd(i)
                                   IF ( Whichd(i).EQ.0 ) THEN
                                      ival = 0
                    !            write(*,*)'fina(i),fina(i+1):',fina(i),fina(i+1)
                                      DO count = Fina(i) , Fina(i+1) - 1
                    !               ival=ival+1
                                         IF ( Whichd(Cola(count)).EQ.0 ) ival = ival + 1
                                      ENDDO
                    !             write(*,*)'ival=',ival,' i=',i
                                      IF ( ival.LT.minval ) THEN
                                         minval = ival
                                         indval = i
                                      ENDIF
                                   ENDIF
                                ENDDO
                    !         write(*,*)'minval=',minval
                    !         write(*,*)'indval=',indval
                    !         TEMPD(NQ)=INDVAL
                    !
                                Whichd(indval) = idom
                                nq = nqtemp
                                Tempd(nq) = indval
                    !         !print*, 'tempd(nq), :', tempd(nq), ' nq :', nq
                    !
                    !
                    !         !print*, 'nq :', nq, ' istart:', istart, ' nqtemp :', nqtemp
                    !
                    ! GROW DOMAIN FROM A POINT
                    ! find all the nodes that TEMPD is connected to that are not numbered.
                                DO its = 1 , Nnod
                     
                                   DO i = istart , nqtemp
                                      row = Tempd(i)
                    !                 write(*,*)'fina(row),fina(row+1):',fina(row),fina(row+1)
                                      DO count = Fina(row) , Fina(row+1) - 1
                                         icol = Cola(count)
                    ! see if already in TEMPD.
                                         IF ( Whichd(icol).EQ.0 ) THEN
                    !                       write(*,*)'inside'
                                            nq = nq + 1
                                            Tempd(nq) = icol
                    !
                    !                       !print*, 'nq :', nq, ' tempd :', tempd(nq)
                    !
                                            Whichd(icol) = idom
                                         ENDIF
                                      ENDDO
                    !                 write(*,*)'nq=',nq
                                      IF ( nq.GT.(Nnod/Ndom)+1 ) GOTO 50
                                   ENDDO
                    !
                                   !print * , 'nq :' , nq , ' nqtemp :' , nqtemp
                    !
                                   IF ( nq.EQ.nqtemp ) GOTO 20
                                   istart = nqtemp + 1
                                   nqtemp = nq
                    !
                                   !print * , 'istart :' , istart , ' nqtemp :' , nqtemp
                    !
                                   !print * , 'its :' , its , ' nq :' , nq , ' nqtemp :' ,   &
                                   !    & nqtemp
                                ENDDO
                    !
                    !
                     50      ENDDO
                             DO i = 1 , Nnod
                                IF ( Whichd(i).EQ.0 ) THEN
                                   !WRITE (*,*) 'zero at i=' , i
                                   Whichd(i) = 1
                                ENDIF
                                Tempd(i) = Whichd(i)
                             ENDDO
                          ENDIF
                          END
                    !*==NEURI.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                     
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE NEURI(Ndom2,Nnod2,V,Tscale,Fina, &
                                         & Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,   &
                                         & Noinsu,  &
                                         & Stoexp,  &
                                         & Sumv,Optim)
                          IMPLICIT NONE
                    !*--NEURI1088
                    !*** Start of declarations inserted by SPAG
                          REAL fcost , ffb , rcost , rr , rscal
                          INTEGER icol , iwicol , maxsub , Ncola , Ndom2 , Nnod , Nnod2
                    !*** End of declarations inserted by SPAG
                    !
                          REAL ANNEAL , FORCE
                          INTEGER Ndom , CHAINL , NOITS
                          PARAMETER (CHAINL=300)
                    !
                          PARAMETER (ANNEAL=0.7)
                          PARAMETER (NOITS=30)
                          PARAMETER (FORCE=0.45)
                    !
                          INTEGER Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          INTEGER Whichd(Nnod)
                          INTEGER Optim
                          REAL A(Ncola)
                    !
                    ! THETA=0 means gamma x^T x is used =1 means x^T b is used.
                    ! FORCE is the force with wich the interface nodes repel the other nodes.
                    ! TOLER is the tolerence of the iteration.
                    ! TAKAWA is the force with which the interface nodes are attracted
                    ! to each other.
                          REAL kk , maxv , minwei
                          REAL Sumv(Ndom+1) , sum
                          REAL ttvv , f , ff , Stoexp(Ndom+1)
                          REAL V(Nnod2*(Ndom2+1)) , Tscale(Nnod2)
                    !        REAL V(maxnod*(maxDOM+1)),TSCALE(maxNOD)
                          REAL prodm2 , scanu1 , scanu2
                    !
                          REAL alpha , gamma
                          INTEGER sub , sub2 , nodsub , i , its , colaco , Noinsu(Ndom+1)
                    !
                          INTEGER count , chain
                    !
                          LOGICAL truble , found
                    !
                    ! Initialise.
                    ! Work out TSCALE for each node.
                          rscal = MIN(0.5,0.05+0.5*REAL(Optim)/200.)
                          DO i = 1 , Nnod
                             kk = 0.
                             DO count = Fina(i) , Fina(i+1) - 1
                                kk = kk + A(count)
                             ENDDO
                    !          TSCALE(I)=0.2*KK/REAL(NDOM+1)
                    !          TSCALE(I)=1.0*KK/REAL(NDOM+1)
                    !          TSCALE(I)=0.5*KK/REAL(NDOM+1)
                    !          TSCALE(I)=0.05*KK/REAL(NDOM+1)
                             Tscale(i) = rscal*kk/REAL(Ndom+1)
                             rr = REAL((Ndom+1)*(Ndom+1)*Nnod)
                    !        TSCALE(I)=KK*REAL(NDOM-1)/RR
                    !          TSCALE(I)=KK/RR
                          ENDDO
                    !
                          kk = 0.
                          minwei = 1.
                          DO count = 1 , Fina(Nnod+1) - 1
                             kk = kk + A(count)
                          ENDDO
                    !        ALPHA=0.1*REAL(NDOM)*KK/REAL(NNOD**2)
                          alpha = 0.5*REAL(Ndom)*kk/REAL(Nnod**2)
                          gamma = FORCE*minwei
                          scanu1 = alpha*REAL(Ndom-1)/REAL(Ndom)
                          scanu2 = -alpha/REAL(Ndom)
                    !
                          DO i = 1 , Nnod*(Ndom+1)
                             V(i) = 0.
                          ENDDO
                          DO i = 1 , Nnod
                             V((Whichd(i)-1)*Nnod+i) = 1.
                          ENDDO
                     
                    !
                          !WRITE (*,*) 'alpha=' , alpha , ' gamma=' , gamma
                    ! The iteration is:
                          ffb = 0.
                          rcost = 0.
                          DO its = 1 , NOITS
                             IF ( its.NE.1 ) THEN
                                DO i = 1 , Nnod
                                   Tscale(i) = ANNEAL*Tscale(i)
                                ENDDO
                             ENDIF
                             DO chain = 1 , CHAINL
                    !
                    ! FF=the functional.
                    ! work out SUMV(SUB)
                                DO sub = 1 , Ndom
                                   sum = 0.
                                   DO i = 1 , Nnod
                                      sum = sum + V((sub-1)*Nnod+i)
                                   ENDDO
                                   Sumv(sub) = sum
                                ENDDO
                    !
                                fcost = 0.
                    !
                     
                                ff = 0.
                                DO i = 1 , Nnod
                    !
                                   sum = 0.
                                   DO sub = 1 , Ndom
                                      nodsub = (sub-1)*Nnod + i
                                      prodm2 = 0.
                                      ttvv = 0.
                                      DO sub2 = 1 , Ndom
                                         IF ( sub.EQ.sub2 ) THEN
                                            prodm2 = prodm2 + scanu1*Sumv(sub2)
                                         ELSE
                                            prodm2 = prodm2 + scanu2*Sumv(sub2)
                    !
                                            DO count = Fina(i) , Fina(i+1) - 1
                                               colaco = Cola(count) + (sub2-1)*Nnod
                                               ttvv = ttvv + A(count)*V(colaco)
                                            ENDDO
                                         ENDIF
                                      ENDDO
                    !
                                      f = ttvv + prodm2
                                      ff = ff + V(nodsub)*f
                                      IF ( ABS(f)/Tscale(i).LT.40 ) THEN
                                         Stoexp(sub) = EXP(-f/Tscale(i))
                                      ELSE
                                         Stoexp(sub) = 0.
                                      ENDIF
                                      sum = sum + Stoexp(sub)
                                   ENDDO
                     
                    !              F=GAMMA*V(NDOM*NNOD+I)
                                   f = gamma
                                   IF ( ABS(f)/Tscale(i).LT.40 ) THEN
                                      Stoexp(Ndom+1) = EXP(-f/Tscale(i))
                                   ELSE
                                      Stoexp(Ndom+1) = 0.
                                   ENDIF
                                   sum = sum + Stoexp(Ndom+1)
                                   IF ( sum.LT.0.0000000000000001 ) GOTO 100
                    !
                    ! Update part that attempts to balance the number of nodes.
                                   DO sub = 1 , Ndom
                                      nodsub = (sub-1)*Nnod + i
                                      Sumv(sub) = Sumv(sub) - V(nodsub)
                                      V(nodsub) = Stoexp(sub)/sum
                                      Sumv(sub) = Sumv(sub) + V(nodsub)
                                   ENDDO
                    ! Update part for interface nodes
                                   V(Ndom*Nnod+i) = Stoexp(Ndom+1)/sum
                                ENDDO
                               ! WRITE (*,*) 'FF=' , ff , ' FFB=' , ffb , ' chain=' , chain ,&
                               !            &' ITS=' , its
                                IF ( ABS(ff-ffb).LT.0.0001 ) GOTO 100
                    !        IF(ABS(FF-FFB).LT.0.000001) GOTO 9000
                                ffb = ff
                    !
                    ! Test for convergence.
                             ENDDO
                     100  ENDDO
                    !
                    !
                    !
                    !
                     
                    ! convert V to WHICHD.
                          DO i = 1 , Nnod
                             maxv = 0.
                             DO sub = 1 , Ndom + 1
                                IF ( V((sub-1)*Nnod+i).GT.maxv ) THEN
                                   maxv = V((sub-1)*Nnod+i)
                                   maxsub = sub
                                ENDIF
                             ENDDO
                             Whichd(i) = maxsub
                          ENDDO
                    !
                    ! check to see if we have a valide partition.
                          truble = .FALSE.
                          DO i = 1 , Nnod
                             DO count = Fina(i) , Fina(i+1) - 1
                                iwicol = Whichd(Cola(count))
                                IF ( Whichd(i).LE.Ndom ) THEN
                    !                 write(*,*)'trouble around i=',i
                                   IF ( (Whichd(i).NE.iwicol) .AND. (iwicol.LE.Ndom) )      &
                                      & truble = .TRUE.
                                ENDIF
                             ENDDO
                          ENDDO
                         ! IF ( truble ) WRITE (*,*) 'NOT A VALIDE PARTITION'
                         ! IF ( .NOT.truble ) WRITE (*,*) 'A VALIDE PARTITION WAS FOUND'
                          DO sub = 1 , Ndom + 1
                             Noinsu(sub) = 0
                          ENDDO
                          DO i = 1 , Nnod
                             Noinsu(Whichd(i)) = Noinsu(Whichd(i)) + 1
                          ENDDO
                          DO sub = 1 , Ndom
                             !WRITE (*,*) 'NO OF NODS IN SUB=' , sub , ' IS =' , Noinsu(sub)
                          ENDDO
                         ! WRITE (*,*) 'NO OF INTERFACE NODES =' , Noinsu(Ndom+1)
                    ! see if interface node is surrounded by other nodes.
                          DO i = 1 , Nnod
                             IF ( Whichd(i).EQ.Ndom+1 ) THEN
                    !            write(*,*)'v(i)=',v(i),' i=',i
                                found = .FALSE.
                                DO count = Fina(i) , Fina(i+1) - 1
                                   icol = Cola(count)
                                   IF ( icol.NE.i ) THEN
                                      IF ( Whichd(icol).EQ.Ndom+1 ) found = .TRUE.
                                   ENDIF
                                ENDDO
                               ! IF ( .NOT.found ) WRITE (*,*) 'I=' , i , 'V(I)=' ,          &
                               !                        & V(i+Ndom*Nnod)
                             ENDIF
                          ENDDO
                    !
                    ! SET THE INTERFACE NODES TO -1 in WHICHD
                          DO i = 1 , Nnod
                             IF ( Whichd(i).GT.Ndom ) Whichd(i) = -1
                          ENDDO
                          END
                    !*==INTPRO.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                     
                          SUBROUTINE INTPRO(Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,V,X,   &
                                          & Subdon)
                          IMPLICIT NONE
                    !*--INTPRO1319
                    !*** Start of declarations inserted by SPAG
                          REAL A
                          INTEGER i , Ncola , Ndom , Nnod
                    !*** End of declarations inserted by SPAG
                    ! This sub works out which subdomain to attach to the interface nodes.
                    !
                          INTEGER count , sub , sub2
                          INTEGER V(Nnod) , X(Nnod)
                          INTEGER minint , minsub , nintsu
                          INTEGER Whichd(Nnod)
                          INTEGER Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          LOGICAL Subdon(Ndom)
                          DO sub = 1 , Ndom
                             Subdon(sub) = .FALSE.
                          ENDDO
                    ! identify which subdomain has the least in number of
                    ! remaining interface nodes surrounding it.
                    !
                          DO sub2 = 1 , Ndom
                             minint = 1000000
                             minsub = 0
                             DO sub = 1 , Ndom
                                IF ( .NOT.Subdon(sub) ) THEN
                                   nintsu = 0
                                   DO i = 1 , Nnod
                                      V(i) = 0
                                      X(i) = 0
                                      IF ( Whichd(i).EQ.sub ) V(i) = 1
                                   ENDDO
                    ! form x=Av
                                   DO i = 1 , Nnod
                                      DO count = Fina(i) , Fina(i+1) - 1
                                         X(i) = X(i) + 1*V(Cola(count))
                                      ENDDO
                                   ENDDO
                                   nintsu = 0
                                   DO i = 1 , Nnod
                    !            IF((WHICHD(I).GT.NDOM).AND.(X(I).GT.0)) NINTSU=NINTSU+1
                                      IF ( (Whichd(i).LT.0) .AND. (X(i).GT.0) )             &
                                         & nintsu = nintsu + 1
                                   ENDDO
                                   IF ( nintsu.LT.minint ) THEN
                                      minsub = sub
                                      minint = nintsu
                                   ENDIF
                                ENDIF
                             ENDDO
                             Subdon(minsub) = .TRUE.
                    ! Claim all surrounding interface nodes of sub MINSUB
                             DO i = 1 , Nnod
                                V(i) = 0
                                X(i) = 0
                                IF ( Whichd(i).EQ.minsub ) V(i) = 1
                             ENDDO
                    ! form x=Av
                             DO i = 1 , Nnod
                                DO count = Fina(i) , Fina(i+1) - 1
                                   X(i) = X(i) + 1*V(Cola(count))
                                ENDDO
                             ENDDO
                             nintsu = 0
                             DO i = 1 , Nnod
                                IF ( (Whichd(i).LT.0) .AND. (X(i).GT.0) ) Whichd(i)         &
                                   & = -minsub
                             ENDDO
                          ENDDO
                          END
                    !*==FINEIG.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE FINEIG(Newsub,Newnod,Oldsub,Nparts,Npart3,Npart4,Ndom2,&
                                          & Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,     &
                                          & Prodm2,Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,&
                                          & Tempd,Power)
                          IMPLICIT NONE
                    !*--FINEIG1400
                    !*** Start of declarations inserted by SPAG
                          INTEGER iarg , irnod
                          REAL RAN1 , rr , rran , rsum
                    !*** End of declarations inserted by SPAG
                    ! Find a neighbourhood configuration
                    !
                          INTEGER Power
                          LOGICAL SIMPLE
                          PARAMETER (SIMPLE=.FALSE.)
                    !        PARAMETER(POWER=2)
                    !        PARAMETER(NODACR=52,NODOWN=52)
                    !        PARAMETER(NS=MAXNOD**0.75)
                    !        PARAMETER(N3=MAXNOD**0.5,N4=MAXNOD**0.25)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          INTEGER Whichd(Nnod) , Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          INTEGER Tempd(Nnod)
                    !
                          INTEGER Nparts , Npart3 , Npart4 , Ndom2 , Nnod2
                          REAL R(Ndom2*Nnod2) , R2(Ndom2*Nnod2)
                          REAL Prodm2(Ndom2) , Rtrpar(Ndom2*Nparts)
                          REAL Rtrsub(Ndom2)
                          REAL Rtrpa3(Ndom2*Npart3) , Rtrpa4(Ndom2*Npart4)
                          REAL Rtr
                    !
                          REAL ranm , prpow
                          INTEGER count , sub , iran , Newsub , Oldsub , Newnod
                    !        INTEGER TEMPD(MAXNOD),SUB2,NODSUB
                          INTEGER nodsub
                          INTEGER part , part3 , part4
                          INTEGER ptpart , ptpar3 , ptpar4
                          INTEGER start , finish , isub
                          LOGICAL usesim , doloop , missed
                    !        COMMON /TEMPD/ TEMPD
                    !        COMMON /R/ R,R2,RTR,RTRPAR,RTRPA3,RTRPA4,RTRSUB,PRODM2
                    !
                    !        COMMON /NPART/ NPARTS,NPART3,NPART4
                    !
                    !        NPARTS=NNOD**0.75
                    !        NPART3=NNOD**0.5
                    !        NPART4=NNOD**0.25
                    !
                          usesim = .FALSE.
                          IF ( ABS(Rtr).LT.0.00001 ) usesim = .TRUE.
                    ! If the last nabourgood configuration was not
                    ! excepted then use R2.
                          IF ( (.NOT.SIMPLE) .AND. (.NOT.usesim) ) THEN
                    ! Find a neighbour hood configuration which only adds a node
                    ! where it is adjasent to at laest one other
                    ! node in the same sub dom.
                    !
                    !            write(*,*)'befor FIDERI'
                    !            CALL FIDERI(R)
                    !            write(*,*)'after FIDERI'
                    !
                    ! Go back to here if missed.
                     50      missed = .FALSE.
                    !
                             iarg = 1
                             rran = RAN1(iarg)
                             IF ( rran.GE.1. ) rran = 0.99999
                             ranm = rran*Rtr
                    !
                    ! Choose which part to look at more closely.
                    ! find out which sub its in
                             isub=0
                             rsum = 0.
                             doloop = .TRUE.
                             DO sub = 1 , Ndom
                                IF ( doloop ) THEN
                                   prpow = (2.*Prodm2(sub))**Power
                                   rr = prpow*Rtrsub(sub)
                                   IF ( (ranm.GE.rsum) .AND. (ranm.LT.rsum+rr) ) THEN
                                      isub = sub
                                      doloop = .FALSE.
                                      rsum = rsum - rr
                                   ENDIF
                                   rsum = rsum + rr
                                ENDIF
                             ENDDO
                             IF ( doloop ) missed = .TRUE.
                    !
                             if(isub==0) stop 8221
                             sub = isub
                    !            PRPOW=(2.*PRODM2(SUB))**POWER
                    !
                    !            rRSUM=RSUM
                             doloop = .TRUE.
                             start = (sub-1)*Npart4 + 1
                             finish = sub*Npart4
                             DO part4 = start , finish
                                IF ( doloop ) THEN
                                   rr = prpow*Rtrpa4(part4)
                                   IF ( (ranm.GE.rsum) .AND. (ranm.LT.rsum+rr) ) THEN
                                      ptpar4 = part4 - (sub-1)*Npart4
                                      doloop = .FALSE.
                                      rsum = rsum - rr
                                   ENDIF
                                   rsum = rsum + rr
                                ENDIF
                             ENDDO
                    !
                             IF ( doloop ) missed = .TRUE.
                    !
                    !            RSUM=RRSUM
                             doloop = .TRUE.
                             start = (sub-1)*Npart3 + ((ptpar4-1)*Npart3)/Npart4 + 1
                             finish = (sub-1)*Npart3 + (ptpar4*Npart3)/Npart4
                             count = 0
                             DO part3 = start , finish
                                IF ( doloop ) THEN
                                   rr = prpow*Rtrpa3(part3)
                                   IF ( (ranm.GE.rsum) .AND. (ranm.LT.rsum+rr) ) THEN
                                      ptpar3 = part3 - (sub-1)*Npart3
                                      doloop = .FALSE.
                                      rsum = rsum - rr
                                   ENDIF
                                   rsum = rsum + rr
                                ENDIF
                             ENDDO
                             IF ( doloop ) missed = .TRUE.
                    !
                    !            RSUM=RRSUM
                             doloop = .TRUE.
                             start = (sub-1)*Nparts + ((ptpar3-1)*Nparts)/Npart3 + 1
                             finish = (sub-1)*Nparts + (ptpar3*Nparts)/Npart3
                             count = 0
                             DO part = start , finish
                                IF ( doloop ) THEN
                                   rr = prpow*Rtrpar(part)
                                   IF ( (ranm.GE.rsum) .AND. (ranm.LT.rsum+rr) ) THEN
                                      ptpart = part - (sub-1)*Nparts
                                      doloop = .FALSE.
                                      rsum = rsum - rr
                                   ENDIF
                                   rsum = rsum + rr
                                ENDIF
                             ENDDO
                             IF ( doloop ) missed = .TRUE.
                    !
                    !            RSUM=RRSUM
                             irnod=0
                             doloop = .TRUE.
                             start = (sub-1)*Nnod + ((ptpart-1)*Nnod)/Nparts + 1
                             finish = (sub-1)*Nnod + (ptpart*Nnod)/Nparts
                             DO nodsub = start , finish
                    !             IF(DOLOOP) THEN
                                rr = prpow*R2(nodsub)
                                IF ( (ranm.GE.rsum) .AND. (ranm.LT.rsum+rr) ) THEN
                                   irnod = nodsub - (sub-1)*Nnod
                                   doloop = .FALSE.
                                ENDIF
                                rsum = rsum + rr
                    !             ENDIF
                             ENDDO
                             IF ( doloop ) missed = .TRUE.
                    ! TRY AGAIN IF MISSED.,
                             IF ( missed ) THEN
                          !      WRITE (*,*) '******************MISSED'
                                GOTO 50
                             ENDIF
                    !
                    ! Have now chosen node IRNOD to be in sub IRSUB
                    !            write(*,*)'irnod=',irnod
                             if(irnod==0) stop 921
                             Newnod = irnod
                             Newsub = sub
                             Oldsub = Whichd(Newnod)
                             Tempd(Newnod) = Newsub
                    !            stop
                          ENDIF
                          IF ( SIMPLE .OR. usesim ) THEN
                    !
                             iarg = 1
                             rran = RAN1(iarg)
                             IF ( rran.GE.1 ) rran = 0.999999
                             iran = INT(rran*REAL(Nnod*Ndom)+1.)
                    !
                             Newsub = ((iran-1)/Nnod) + 1
                             Newnod = iran - (Newsub-1)*Nnod
                             Oldsub = Whichd(Newnod)
                             Tempd(Newnod) = Newsub
                          ENDIF
                          END
                    !*==FIDERC.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE FIDERC(Pcost,Nparts,Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,&
                                          & Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,Fina,Cola,   &
                                          & Midpa,A,Ncola,Nnod,Ndom,Whichd,Km,Kmtemp,Chopar,&
                                          & Chopa3,Chopa4,Power)
                          IMPLICIT NONE
                    !*--FIDERC1594
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , j
                          REAL rtri , rtrp , rtrp3 , rtrp4
                    !*** End of declarations inserted by SPAG
                    ! This sub finds the derivative of the cost function=R
                    ! and finds R2 & KM and also finds the cost function PCOST.
                    !
                          INTEGER Power
                    !        PARAMETER(POWER=2)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          INTEGER Whichd(Nnod) , Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          REAL Km(Ndom) , Kmtemp(Ndom)
                    !
                          INTEGER Chopar(Nnod) , Chopa3(Nnod) , Chopa4(Nnod)
                    !
                          INTEGER Nparts , Npart3 , Npart4 , Ndom2 , Nnod2
                          REAL R(Ndom2*Nnod2) , R2(Ndom2*Nnod2)
                          REAL Prodm2(Ndom2) , Rtrpar(Ndom2*Nparts)
                          REAL Rtrsub(Ndom2)
                          REAL Rtrpa3(Ndom2*Npart3) , Rtrpa4(Ndom2*Npart4)
                          REAL Rtr
                    !
                          REAL prodm1
                    !        real KM(MAXDOM),KMTEMP(MAXDOM),FF,sp,PRODM1
                          REAL Pcost
                          REAL prpow
                          INTEGER sub , sub2
                    !        INTEGER CHOPAR(MAXNOD),CHOPA3(MAXNOD),CHOPA4(MAXNOD)
                          INTEGER count , row , col
                          INTEGER ptpart , ptpar3 , ptpar4
                          INTEGER start , finish , st , fi , st2 , fi2 , st3 , fi3 , part , &
                                & part3 , part4
                    !        COMMON /KM/ KM,KMTEMP
                    !        COMMON /R/ R,R2,RTR,RTRPAR,RTRPA3,RTRPA4,RTRSUB,PRODM2
                    !        COMMON /CHOPAR/ CHOPAR,CHOPA3,CHOPA4
                    !        COMMON /NPART/ NPARTS,NPART3,NPART4
                    ! This sub finds the FINDS THE DERIVATIVE OF THE FUNCTIONAL.
                    !
                    !        NPARTS=NNOD**0.75
                    !        NPART3=NNOD**0.5
                    !        NPART4=NNOD**0.25
                    !
                          DO sub = 1 , Ndom
                             DO i = 1 , Nnod
                                R(i+(sub-1)*Nnod) = 0.
                             ENDDO
                    !
                             DO col = 1 , Nnod
                                IF ( Whichd(col).EQ.sub ) THEN
                                   DO count = Fina(col) , Fina(col+1) - 1
                                      row = Cola(count)
                                      R(row+(sub-1)*Nnod) = R(row+(sub-1)*Nnod) + A(count)
                                   ENDDO
                                ENDIF
                             ENDDO
                    !
                             Km(sub) = 0.
                             DO i = 1 , Nnod
                                R2((sub-1)*Nnod+i) = R((sub-1)*Nnod+i)**Power
                                IF ( Whichd(i).EQ.sub ) THEN
                                   R2((sub-1)*Nnod+i) = 0.
                                   Km(sub) = Km(sub) + R(i+(sub-1)*Nnod)
                                ENDIF
                             ENDDO
                          ENDDO
                    !
                          DO sub = 1 , Ndom
                             prodm1 = 1.
                             DO sub2 = 1 , Ndom
                                IF ( sub2.NE.sub ) prodm1 = prodm1*Km(sub2)
                             ENDDO
                             Prodm2(sub) = prodm1
                          ENDDO
                    !
                          Pcost = 1.
                          DO sub = 1 , Ndom
                             Kmtemp(sub) = Km(sub)
                             Pcost = Pcost*Km(sub)
                          ENDDO
                     
                    !
                    ! WORK OUT RTRPAR & RTR.
                    ! Work out CHOPA3() & CHOPA4()
                          Rtr = 0.
                          DO sub = 1 , Ndom
                             prpow = (2.*Prodm2(sub))**Power
                             start = (sub-1)*Npart4 + 1
                             finish = sub*Npart4
                             rtrp4 = 0.
                             DO part4 = start , finish
                                ptpar4 = part4 - (sub-1)*Npart4
                                st3 = (sub-1)*Npart3 + ((ptpar4-1)*Npart3)/Npart4 + 1
                                fi3 = (sub-1)*Npart3 + (ptpar4*Npart3)/Npart4
                                rtrp3 = 0.
                                DO part3 = st3 , fi3
                                   ptpar3 = part3 - (sub-1)*Npart3
                                   st2 = (sub-1)*Nparts + ((ptpar3-1)*Nparts)/Npart3 + 1
                                   fi2 = (sub-1)*Nparts + (ptpar3*Nparts)/Npart3
                                   rtrp = 0.
                                   DO part = st2 , fi2
                                      ptpart = part - (sub-1)*Nparts
                                      st = (sub-1)*Nnod + ((ptpart-1)*Nnod)/Nparts + 1
                                      fi = (sub-1)*Nnod + (ptpart*Nnod)/Nparts
                                      rtri = 0.
                                      DO i = st , fi
                                         rtri = rtri + R2(i)
                    !
                                         IF ( sub.EQ.1 ) THEN
                                            j = i - (sub-1)*Nnod
                                            Chopar(j) = part - (sub-1)*Nparts
                                            Chopa3(j) = part3 - (sub-1)*Npart3
                                            Chopa4(j) = part4 - (sub-1)*Npart4
                                         ENDIF
                                      ENDDO
                                      Rtrpar(part) = rtri
                                      rtrp = rtrp + rtri
                                   ENDDO
                                   Rtrpa3(part3) = rtrp
                                   rtrp3 = rtrp3 + rtrp
                                ENDDO
                                Rtrpa4(part4) = rtrp3
                                rtrp4 = rtrp4 + rtrp3
                             ENDDO
                             Rtrsub(sub) = rtrp4
                             Rtr = Rtr + prpow*rtrp4
                          ENDDO
                    !
                          !WRITE (*,*) 'rtr=' , Rtr
                          END
                    !*==UPDERI.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                     
                          SUBROUTINE UPDERI(Ncost,Newsub,Newnod,Oldsub,Nparts,Npart3,Npart4,&
                                          & Ndom2,Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,Rtrpa4,      &
                                          & Rtrsub,Prodm2,Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,&
                                          & Whichd,Km,Kmtemp,Chopar,Chopa3,Chopa4,Power)
                          IMPLICIT NONE
                    !*--UPDERI1739
                    ! This sub updates THE NEW R & finds Rtr & RTRPAR.
                    !
                          REAL SMALL
                          INTEGER Power
                    !        PARAMETER(POWER=2)
                          PARAMETER (SMALL=1000.)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          INTEGER Whichd(Nnod) , Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          REAL Km(Ndom) , Kmtemp(Ndom)
                    !
                          INTEGER Chopar(Nnod) , Chopa3(Nnod) , Chopa4(Nnod)
                    !
                          INTEGER Nparts , Npart3 , Npart4 , Ndom2 , Nnod2
                          REAL R(Ndom2*Nnod2) , R2(Ndom2*Nnod2)
                          REAL Prodm2(Ndom2) , Rtrpar(Ndom2*Nparts)
                          REAL Rtrsub(Ndom2)
                          REAL Rtrpa3(Ndom2*Npart3) , Rtrpa4(Ndom2*Npart4)
                          REAL Rtr
                    !
                    !        real KM(MAXDOM),KMTEMP(MAXDOM),FF,PRODM1
                          REAL prodm1
                          REAL prpow , r1pr2p
                          INTEGER sub , sub2 , nodsub , colaco
                    !        INTEGER CHOPAR(MAXNOD),CHOPA3(MAXNOD),CHOPA4(MAXNOD)
                          REAL Ncost
                          INTEGER Newsub , Newnod , Oldsub
                          INTEGER count
                          INTEGER ptpart , ptpar3 , ptpar4
                    !        COMMON /KM/ KM,KMTEMP
                    !        COMMON /R/ R,R2,RTR,RTRPAR,RTRPA3,RTRPA4,RTRSUB,PRODM2
                    !        COMMON /CHOPAR/ CHOPAR,CHOPA3,CHOPA4
                    !        COMMON /NPART/ NPARTS,NPART3,NPART4
                    ! This sub finds the FINDS THE DERIVATIVE OF THE FUNCTIONAL.
                    !
                    !        NPARTS=NNOD**0.75
                    !        NPART3=NNOD**0.5
                    !        NPART4=NNOD**0.25
                    !
                    ! WORK OUT R.
                          IF ( Ncost.LT.SMALL ) THEN
                             DO sub = 1 , Ndom
                                prodm1 = 1.
                                DO sub2 = 1 , Ndom
                                   IF ( sub2.NE.sub ) prodm1 = prodm1*Km(sub2)
                                ENDDO
                                Prodm2(sub) = prodm1
                             ENDDO
                          ELSE
                             DO sub = 1 , Ndom
                                Prodm2(sub) = Ncost/Km(sub)
                             ENDDO
                          ENDIF
                    !
                    !
                    !               prob=.FALSE.
                          DO count = Fina(Newnod) , Fina(Newnod+1) - 1
                             colaco = Cola(count)
                    !
                             nodsub = (Newsub-1)*Nnod + colaco
                             ptpart = Chopar(colaco) + (Newsub-1)*Nparts
                             ptpar3 = Chopa3(colaco) + (Newsub-1)*Npart3
                             ptpar4 = Chopa4(colaco) + (Newsub-1)*Npart4
                    ! Must update RTRPAR as well
                    ! Work out new R(NOSUB)
                             R(nodsub) = R(nodsub) + A(count)
                             r1pr2p = -R2(nodsub)
                             IF ( Whichd(colaco).NE.Newsub ) THEN
                                R2(nodsub) = R(nodsub)**Power
                             ELSE
                                R2(nodsub) = 0.
                             ENDIF
                             r1pr2p = r1pr2p + R2(nodsub)
                             Rtrsub(Newsub) = Rtrsub(Newsub) + r1pr2p
                             Rtrpar(ptpart) = Rtrpar(ptpart) + r1pr2p
                             Rtrpa3(ptpar3) = Rtrpa3(ptpar3) + r1pr2p
                             Rtrpa4(ptpar4) = Rtrpa4(ptpar4) + r1pr2p
                    !
                    ! takeaway a 1.
                             nodsub = (Oldsub-1)*Nnod + colaco
                             ptpart = Chopar(colaco) + (Oldsub-1)*Nparts
                             ptpar3 = Chopa3(colaco) + (Oldsub-1)*Npart3
                             ptpar4 = Chopa4(colaco) + (Oldsub-1)*Npart4
                    ! Must update RTRPAR as well
                    ! Work out new R(NOSUB)
                             R(nodsub) = R(nodsub) - A(count)
                             r1pr2p = -R2(nodsub)
                             IF ( Whichd(colaco).NE.Oldsub ) THEN
                                R2(nodsub) = R(nodsub)**Power
                             ELSE
                                R2(nodsub) = 0.
                             ENDIF
                             r1pr2p = r1pr2p + R2(nodsub)
                             Rtrsub(Oldsub) = Rtrsub(Oldsub) + r1pr2p
                             Rtrpar(ptpart) = Rtrpar(ptpart) + r1pr2p
                             Rtrpa3(ptpar3) = Rtrpa3(ptpar3) + r1pr2p
                             Rtrpa4(ptpar4) = Rtrpa4(ptpar4) + r1pr2p
                          ENDDO
                    !
                    !
                    ! Must update RTR as well
                          Rtr = 0.
                          DO sub = 1 , Ndom
                             prpow = (2.*Prodm2(sub))**Power
                             Rtr = Rtr + prpow*Rtrsub(sub)
                    !                 RTR=RTR+ RTRSUB(SUB)*(PRODM2(SUB)**POWER)
                          ENDDO
                    !              RTR=4.*RTR
                    !
                          END
                    !*==FININI.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                     
                          SUBROUTINE FININI(Nchain,Initic,Pcost,Gotc,Nparts,Npart3,Npart4,  &
                                          & Ndom2,Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,Rtrpa4,      &
                                          & Rtrsub,Prodm2,Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,&
                                          & Whichd,Tempd,Km,Kmtemp,Random,Power,Chopar,     &
                                          & Chopa3,Chopa4)
                          IMPLICIT NONE
                    !*--FININI1864
                    !*** Start of declarations inserted by SPAG
                          INTEGER its
                    !*** End of declarations inserted by SPAG
                    !
                    ! This sub finds the initial C parameter INITIC.
                    !
                          REAL EXCEPI
                          LOGICAL SIMPLE
                          PARAMETER (SIMPLE=.FALSE.)
                          PARAMETER (EXCEPI=0.9)
                    !
                          INTEGER Ncola , Nnod , Ndom
                          INTEGER Whichd(Nnod) , Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          REAL Km(Ndom) , Kmtemp(Ndom)
                          INTEGER Tempd(Nnod)
                          INTEGER Power
                    !
                          INTEGER Chopar(Nnod) , Chopa3(Nnod) , Chopa4(Nnod)
                    !
                          INTEGER Nparts , Npart3 , Npart4 , Ndom2 , Nnod2
                          REAL R(Ndom2*Nnod2) , R2(Ndom2*Nnod2)
                          REAL Prodm2(Ndom2) , Rtrpar(Ndom2*Nparts)
                          REAL Rtrsub(Ndom2)
                          REAL Rtrpa3(Ndom2*Npart3) , Rtrpa4(Ndom2*Npart4)
                          REAL Rtr
                    !
                    ! EXCEPI=initial probability of exceptance with decreased cost fu.
                    ! if MAXBAS then find INITIC based on max difference in cost.
                          REAL Initic , Pcost , dif , nloacp
                          REAL mxdifc , ncost
                    !        real KM(MAXDOM),KMTEMP(MAXDOM)
                    !        INTEGER TEMPD(MAXNOD),I,IRAN,SAM
                          INTEGER Nchain , chain , newsub , newnod , oldsub , sub
                          LOGICAL Gotc
                          LOGICAL Random
                    !        COMMON /TEMPD/ TEMPD
                    !        COMMON /KM/ KM,KMTEMP
                          mxdifc = 0.
                    ! work out R & R2.
                          Ncola = Fina(Nnod+1) - 1
                          CALL FIDERC(Pcost,Nparts,Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,      &
                                    & Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,Prodm2,Fina,Cola,Midpa,A, &
                                    & Ncola,Nnod,Ndom,Whichd,Km,Kmtemp,Chopar,Chopa3,Chopa4,&
                                    & Power)
                          !WRITE (*,*) 'PCOST=' , Pcost
                    ! Find an initial INITIC s.t. [1/(e^( {ncost-pcost}/INITIC))] =0.98
                    !        DO 20 ITS=1,70
                          DO its = 1 , 7
                             DO chain = 1 , Nchain
                    ! Find a neighbourhood configuration
                                CALL FINEIG(newsub,newnod,oldsub,Nparts,Npart3,Npart4,Ndom2,&
                                          & Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,Rtrpa4,Rtrsub,     &
                                          & Prodm2,Fina,Cola,Midpa,A,Ncola,Nnod,Ndom,Whichd,&
                                          & Tempd,Power)
                                IF ( newsub.NE.oldsub ) THEN
                    ! find cost of neighbourhood config
                    !              CALL FICOSK(NCOST,PCOST,NEWSUB,OLDSUB,NEWNOD)
                                   CALL FICOSK(ncost,Pcost,newsub,oldsub,newnod,Fina,Cola,  &
                                             & Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Km,     &
                                             & Kmtemp)
                                   dif = 0.
                                   IF ( ncost.LT.Pcost ) dif = ABS(Pcost-ncost)
                                   IF ( dif.GT.mxdifc ) mxdifc = dif
                                   Pcost = ncost
                                   Whichd(newnod) = newsub
                                   DO sub = 1 , Ndom
                                      Km(sub) = Kmtemp(sub)
                                   ENDDO
                                   IF ( .NOT.SIMPLE )                                       &
                                      & CALL UPDERI(ncost,newsub,newnod,oldsub,Nparts,      &
                                      & Npart3,Npart4,Ndom2,Nnod2,R,R2,Rtr,Rtrpar,Rtrpa3,   &
                                      & Rtrpa4,Rtrsub,Prodm2,Fina,Cola,Midpa,A,Ncola,Nnod,  &
                                      & Ndom,Whichd,Km,Kmtemp,Chopar,Chopa3,Chopa4,Power)
                                ENDIF
                    !            write(*,*)'pcost=',pcost
                             ENDDO
                          ENDDO
                    !
                          nloacp = LOG(EXCEPI)
                    !        INITIC= - MXDIFC/NLOACP
                          Initic = Pcost
                          !WRITE (*,*) 'INITIC=' , Initic
                          Gotc = .TRUE.
                          IF ( ABS(Initic).LT.0.00001 ) Gotc = .FALSE.
                    !         STOP
                          END
                    !*==FICOSK.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                     
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE FICOSK(Ncost,Pcost,Newsub,Oldsub,Newnod,Fina,Cola,     &
                                          & Midpa,A,Ncola,Nnod,Ndom,Whichd,Tempd,Km,Kmtemp)
                          IMPLICIT NONE
                    !*--FICOSK1963
                    ! find the cost function associated with configuration TEMPD.
                    ! using KM from previous configuration.
                    !
                          INTEGER Ncola , Nnod , Ndom
                          INTEGER Whichd(Nnod) , Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          REAL Km(Ndom) , Kmtemp(Ndom)
                          INTEGER Tempd(Nnod)
                    !
                          REAL Ncost , Pcost
                    !           real KM(MAXDOM),KMTEMP(MAXDOM)
                          REAL moxro1 , moxro2
                    !           INTEGER TEMPD(MAXNOD),SUB
                          INTEGER sub
                          INTEGER Newsub , Oldsub , Newnod
                    !
                          INTEGER count
                    !           COMMON /TEMPD/ TEMPD
                    !
                    !           COMMON /KM/ KM,KMTEMP
                    !
                    ! Find NCOST from KM and PCOST and NEWNOD,NEWSUB
                    !            IF(PCOST.LT.1.0E+08) THEN
                          DO sub = 1 , Ndom
                             Kmtemp(sub) = Km(sub)
                          ENDDO
                    !            ENDIF
                    !
                     
                          moxro1 = 0.
                          moxro2 = 0.
                          DO count = Fina(Newnod) , Fina(Newnod+1) - 1
                             IF ( Whichd(Cola(count)).EQ.Newsub ) moxro1 = moxro1 + A(count)
                             IF ( Whichd(Cola(count)).EQ.Oldsub ) moxro2 = moxro2 + A(count)
                          ENDDO
                    ! NB A(MIDPA(COUNT))=0.
                    !
                          Kmtemp(Newsub) = Km(Newsub) + 2.*moxro1
                          Kmtemp(Oldsub) = Km(Oldsub) - 2.*moxro2
                     
                    !
                          Ncost = Kmtemp(1)
                          DO sub = 2 , Ndom
                             Ncost = Ncost*Kmtemp(sub)
                          ENDDO
                          END
                    !*==MESH.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE MESH(Beta,Wnod,Fina,Cola,Midpa,A,Ncola,Nnod)
                          IMPLICIT NONE
                    !*--MESH2021
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , Ncola , Nnod
                    !*** End of declarations inserted by SPAG
                    !
                          REAL Beta , Wnod(Nnod)
                          INTEGER count
                          INTEGER Midpa(Nnod) , Cola(Ncola) , Fina(Nnod+1)
                          REAL A(Ncola)
                    !
                          CALL CLRRL(Nnod,Wnod,1.0)
                    !
                          DO i = 1 , Nnod
                             DO count = Fina(i) , Fina(i+1) - 1
                                A(count) = Beta
                             ENDDO
                             A(Midpa(i)) = 0.
                          ENDDO
                    ! Now scale the matrix.
                          DO i = 1 , Nnod
                             DO count = Fina(i) , Fina(i+1) - 1
                                A(count) = A(count)/(Wnod(Cola(count))*Wnod(i))
                             ENDDO
                          ENDDO
                          END SUBROUTINE MESH
                    !*==USEDIV.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !      idum = 1
                    !      do 10 i = 1, 30
                    !        z = ran1(idum)
                    !10    write(*,*) idum, z, z*1000000
                    !      end
                    !
                    !
                    !
                    !
                    ! ******************************************************
                    ! ******************************************************
                    ! ****** DECOMPOSE USEING MULTI-LEVEL NEURAL NET *******
                    ! ******************************************************
                    ! ******************************************************
                    ! ******************************************************
                     
                     
                     
                    !
                    !
                          SUBROUTINE USEDIV(Rmem,Nrmem,Fina,Cola,A,Ncola,Nonods,Whichd,     &
                                          & Renum,Imem,Nimem,X,Y,Ndom,Havmat,Splevs,Nsplt,  &
                                          & Mxnspl,Optim, havwnod)
                          IMPLICIT NONE
                    !*--USEDIV2074
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ichoic , Ncola , Ndom , Nimem , Nonods , Nrmem ,      &
                                & Nsplt , nsubal, havwnod
                    !*** End of declarations inserted by SPAG
                    ! This sub allows the user to input information about
                          INTEGER Havmat , Optim
                          REAL Rmem(Nrmem) , A(Ncola*Havmat)
                          REAL X(Nonods) , Y(Nonods)
                          INTEGER Fina(Nonods+1) , Cola(Ncola) , Whichd(Nonods)
                          INTEGER Renum(Nonods) , Imem(Nimem)
                          INTEGER Mxnspl , MXNTRE
                    !      PARAMETER(MXNSPL=40,MXNTRE=1000)
                          PARAMETER (MXNTRE=1000)
                    ! the partition wanted.
                          INTEGER Splevs(Mxnspl) , mullev
                          REAL subala(MXNTRE)
                          REAL alpha , lodbal , beta , toler
                          INTEGER nchain
                          LOGICAL defaul , topcon , sidcon
                          LOGICAL exact
                          INTEGER hypdim , proacr , prodow
                    ! MULLEV=no of multi-grid levels.
                    ! SPLEVS(1..NSPLT) contains the dissection information.
                          !WRITE (*,*) 'INSIDE USEDIV'
                          ichoic = 1
                          mullev = 4
                    !        MULLEV=1
                    !
                          GOTO 100
                    !
                          !WRITE (*,*) '**********************************************'
                          !WRITE (*,*) '+ THIS PROGRAM WILL NOW SPLIT THE MESH'
                          !WRITE (*,*) '+ RORDER THE EQUATIONS'
                          !WRITE (*,*) '+ MAP THE SUBDOMAINS TO A PARALLEL COMPUTER'
                          !WRITE (*,*) '  ARCHITECTURE'
                          !WRITE (*,*) '*** BUT IT NEEDS SOME INFORMATION TO DO THIS *'
                          !WRITE (*,*) '**********************************************'
                          !WRITE (*,*) ' '
                          !WRITE (*,*) 'ENTER THE NUMBER OF RECURSIVE GRAPH CUTS:'
                        !  READ * , Nsplt
                          DO i = 1 , Nsplt
                             !WRITE (*,*) 'FOR RECURSION =' , i , ' ENTER THE '
                             !WRITE (*,*) 'NUMBER OF PARTITIONS:'
                            ! READ * , Splevs(i)
                             IF ( i.EQ.1 ) THEN
                                Ndom = Splevs(i)
                             ELSE
                                Ndom = Ndom*Splevs(i)
                             ENDIF
                          ENDDO
                    !
                          !WRITE (*,*) ' '
                          !WRITE (*,*) 'FOR THE GRAPH CUT OPTIMIZATION :'
                          !WRITE (*,*) 'PARTITIONING THE GRID ON SMALLER GRIDS'
                          !WRITE (*,*) 'CAN HELP THE OPTIMIZATION'
                          !WRITE (*,*) 'ENTER NUMBER OF MULTI-GRID LEVELS 1,..,5'
                         ! READ * , mullev
                         ! WRITE (*,*) 'USE DEFAULT  oprimization PARAMETERS(1=YES'
                         ! WRITE (*,*) 'OR 0 OTHERWISE'
                         ! READ * , ichoic
                    !
                    !
                     100  DO i = 1 , Nsplt
                    !
                             IF ( i.EQ.1 ) THEN
                                Ndom = Splevs(i)
                             ELSE
                                Ndom = Ndom*Splevs(i)
                             ENDIF
                    !
                          ENDDO
                    !
                          IF ( ichoic.EQ.1 ) THEN
                             lodbal = 1.
                             beta = 0.9
                    !          BETA=0.8
                             toler = 0.0001
                    !          NCHAIN=1000
                             nchain = 700
                          ELSE
                             !WRITE (*,*) 'LODBAL=1. is the default .gt.1 then more'
                             !WRITE (*,*) 'importance is placed on load balancing.'
                             !WRITE (*,*) 'BETA=0.9 is the default but this controles'
                             !WRITE (*,*) 'how close to the critical temp the optimization'
                             !WRITE (*,*) 'is performed WHEN BETA=0.5 - HALF CRYTICAL TEMP'
                             !WRITE (*,*) 'IS USED.'
                             !WRITE (*,*) 'TOLER =the solution tolerence 0.0001is suggested'
                             !WRITE (*,*) 'NCHAIN =maximum no of its 3000 is suggested'
                             !WRITE (*,*) 'ENTER LODBAL:'
                            ! READ * , lodbal
                             !WRITE (*,*) 'ENTER BETA:'
                           !  READ * , beta
                             !WRITE (*,*) 'ENTER TOLER:'
                            ! READ * , toler
                             !WRITE (*,*) 'ENTER NCHAIN:'
                             !READ * , nchain
                          ENDIF
                    ! ALPHA is not eventually used.
                          alpha = 1.
                    !
                          !WRITE (*,*) 'ONCE WE HAVE A GRAPH PARTITION WE MUST'
                          !WRITE (*,*) 'MAP IT ONTO PROCESSORS CONNECTED'
                          !WRITE (*,*) 'WITH A PARTICULAR TAPOLOGY'
                          !WRITE (*,*) ' '
                          !WRITE (*,*) 'THE DEFAULT MAPPING WORKS WELL IN SOME CASES'
                          !WRITE (*,*) 'DO YOU WANT A DEFAULT MAPPING: 1, O-OTHERWISE'
                    !        READ *,ICHOIC
                          ichoic = 1
                          IF ( ichoic.EQ.1 ) THEN
                             defaul = .TRUE.
                          ELSE
                             defaul = .FALSE.
                             !WRITE (*,*) '2 ARCHITECTURES ARE AVAILABLE MESH CONNECTED'
                             !WRITE (*,*) 'SIMILAR TO A N X M F.D grid or a hypercube.'
                    !
                             !WRITE (*,*) ' '
                             !WRITE (*,*) 'HYPERCUBE DIMENSION S.T. =2^(no of domains)'
                             !WRITE (*,*) 'ENTER THE HYPERCUBE DIMENSIONS: 0 FOR MESH'
                           !  READ * , hypdim
                             IF ( hypdim.EQ.0 ) THEN
                                !WRITE (*,*) ' '
                                !WRITE (*,*) 'ENTER THE PARTICULARS OF THE MESH ARCHITECTURE'
                                !WRITE (*,*) 'SUPPOSING THE MESH HAS DIM: PRODOW X PROACR'
                                !WRITE (*,*) 'THE PROCESSORS WILL BE NUMBERED'
                                !WRITE (*,*) '1,2,...,PROACR'
                                !WRITE (*,*) '.......,2*PROACR'
                                !WRITE (*,*) '.................'
                                !WRITE (*,*) '.......,PRODOW*PROACR'
                                !WRITE (*,*) 'ENTER PROACR'
                               ! READ * , proacr
                                !WRITE (*,*) 'ENTER PRODOW'
                                !READ * , prodow
                                !WRITE (*,*) ' '
                                !WRITE (*,*) 'IS THE MESH WRAPPED ROUND FROM THE TOP(1=YES'
                           !     READ * , ichoic
                                topcon = .FALSE.
                                IF ( ichoic.EQ.1 ) topcon = .TRUE.
                                !WRITE (*,*) 'MESH WRAPPED ROUND FROM THE SIDES ?(1=YES'
                           !     READ * , ichoic
                                sidcon = .FALSE.
                                IF ( ichoic.EQ.1 ) sidcon = .TRUE.
                             ENDIF
                          ENDIF
                    !
                          nsubal = MXNTRE
                    ! For reordering equations....
                    ! For the subdomain to proc mapping.......
                          CALL PREPAR(Splevs,Nsplt,mullev,Rmem,Nrmem,X,Y,Fina,Cola,A,Ncola, &
                                    & Nonods,Ndom,Whichd,subala,nsubal,exact,alpha,lodbal,  &
                                    & beta,toler,nchain,Renum,defaul,hypdim,topcon,sidcon,  &
                                    & proacr,prodow,Imem,Nimem,Havmat,havwnod)
                     
                          END
                    !*==PREPAR.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    ! For reordering equations....
                    ! For the subdomain to proc mapping.......
                          SUBROUTINE PREPAR(Splevs,Nsplt,Mullev,Rmem,Nrmem,X,Y,Fina,Cola,A, &
                                          & Ncola,Nonods,Ndom,Whichd,Subala,Nsubal,Exact,   &
                                          & Alpha,Lodbal,Beta,Toler,Nchain,Renum,Defaul,    &
                                          & Hypdim,Topcon,Sidcon,Proacr,Prodow,Imem,Nimem,  &
                                          & Havmat,havwnod)
                          IMPLICIT NONE
                    !*--PREPAR2241
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ii , imem2 , inod1 , inod2 , isub , Nchain , Nimem ,  &
                                & nimem2 , Nrmem , nrmem2 , Nsubal
                    !*** End of declarations inserted by SPAG
                    !
                    ! THIS SUB DIVIDS UP THE DOMAIN INTO SUBDOMAINS
                    ! & ALLOCATES SUBDOMAINS TO PROCESSORS
                    ! & MINIMIZES THE BANDWIDTH ALSO INCREASES CONNECTIVITY
                    ! FOR AN ITERATIVE SOLUTION.
                    ! AFTER CALLING THIS ROUTINE SUBDOMAIN J SHOULD BE
                    ! ATTACHED TO PROC J
                    ! %%%%%%%%%% WHICHD(OLD NOD)=SUBDOMAIN OF %%%%%%%%%%%%%
                    ! %%%%%%%%%% RENUM(OLD NODE)=NEW NODE NO  %%%%%%%%%%%%%
                          INTEGER Havmat,havwnod
                          INTEGER maxnla , mmxtot , Mullev
                          INTEGER Splevs(Nsplt)
                          INTEGER Nsplt
                          REAL Subala(Nsubal)
                          REAL Alpha , Lodbal , Beta , Toler
                          REAL X(Nonods) , Y(Nonods)
                    ! MXNTRE=max no of entries in TREE (suggest 1000
                    ! so that max no of sub-domains is about 500).
                    !
                          INTEGER lcola , lfina
                    !
                          REAL Rmem(Nrmem)
                    !
                          REAL A(Ncola*Havmat)
                          LOGICAL Exact
                    ! This is for REORGL.....
                          INTEGER Ndom , Nonods , nnod , Ncola , mxcols
                          INTEGER Fina(Nonods+1) , Cola(Ncola)
                          INTEGER Whichd(Nonods) , Renum(Nonods)
                    ! If DEFAUL then map using rordering routine.
                    ! COLSUB contains the subdomain to subdomain communication matrix.
                    ! MXCOLS= maximum value of NCOLSU
                    !
                          INTEGER ptimem
                    ! For the subdomain to proc mapping.......
                          LOGICAL Defaul , Topcon , Sidcon
                          INTEGER Hypdim , Proacr , Prodow , Imem(Nimem)
                          INTEGER lwichd , map , finsub , colsub , blasub
                          INTEGER q , qtemp
                          INTEGER ptrmem , la , wnod , lwnod , rmem2
                          INTEGER lx , ly , maxnq
                    !
                          nnod = Nonods
                    !
                    ! SPLIT THE DOMAIN INTO SUBDOMAINS
                    !         MMXTOT=2*NNOD
                    !         MAXNLA=2*NCOLA
                          mmxtot = MAX(1000,INT(1.75*nnod))
                          maxnla = MAX(1000,INT(1.5*Ncola))
                          mxcols = Ndom*Ndom
                    ! INTEGERS....
                          ptimem = 1
                          lwichd = ptimem
                          ptimem = ptimem + mmxtot
                          map = ptimem
                          ptimem = ptimem + Nonods
                          lfina = ptimem
                          ptimem = ptimem + mmxtot + Mullev
                          lcola = ptimem
                          ptimem = ptimem + maxnla
                          q = ptimem
                          ptimem = ptimem + Nonods
                    ! give MAP & QTEMP same storage space.
                          qtemp = map
                     
                    ! REALS....
                          ptrmem = 1
                          la = ptrmem
                          ptrmem = ptrmem + maxnla*Havmat
                          wnod = ptrmem
                          ptrmem = ptrmem + Nonods
                          lwnod = ptrmem
                          ptrmem = ptrmem + mmxtot
                          lx = ptrmem
                          ptrmem = ptrmem + mmxtot
                          ly = ptrmem
                          ptrmem = ptrmem + mmxtot
                          rmem2 = ptrmem
                          nrmem2 = Nrmem - rmem2 + 1
                    !
                    !      CALL RECBIS(Splevs,Nsplt,Mullev,Rmem(rmem2),nrmem2,Fina,Cola,A,   &
                          CALL RECBIS(Splevs,Nsplt,Mullev,Fina,Cola,A,   &
                                    & Ncola,Nonods,mmxtot,Ndom,Whichd,Imem(lfina),          &
                                    & Imem(lcola),Rmem(la),maxnla,Nsubal,Imem(lwichd),      &
                                    & Imem(map),Rmem(wnod),Rmem(lwnod),Imem(q),Imem(qtemp), &
                                    & Subala,Exact,Alpha,Lodbal,Beta,Toler,Nchain,X,Y,      &
                                    & Rmem(lx),Rmem(ly),Havmat, havwnod)
                    ! count no of nodes in each subdomain
                          !WRITE (*,*) 'after RECBIS ndom,nonods:' , Ndom , Nonods
                          DO isub = 1 , Ndom
                             ii = 0
                             DO i = 1 , Nonods
                                IF ( Whichd(i).EQ.isub ) ii = ii + 1
                             ENDDO
                             !WRITE (*,*) 'no of nodes in sub=' , isub , ' is =' , ii
                          ENDDO
                    !
                    !
                          ptimem = 1
                          inod1 = ptimem
                          maxnq = Nonods + 2000
                          ptimem = ptimem + maxnq
                          inod2 = ptimem
                          ptimem = ptimem + Nonods
                    !
                          finsub = ptimem
                          ptimem = ptimem + Ndom + 1
                          colsub = ptimem
                          ptimem = ptimem + mxcols
                          blasub = ptimem
                          ptimem = ptimem + Ndom
                          imem2 = ptimem
                          nimem2 = Nimem - imem2 + 1
                    ! REORDER EQUATIONS -INCLUDING THE SUBDOMAIN TO PROCESSOR MAPPING.
                    ! RENUM(OLD NODE)=NEW NODE NO.
                    !     &           Q,BLANK,BLASUB,
                    ! For the subdomain to proc mapping.......
                          CALL REORG2(Fina,Cola,Ncola,Nonods,Ndom,Whichd,Renum,Imem(finsub),&
                                    & Imem(colsub),mxcols,Imem(inod1),Imem(inod2),          &
                                    & Imem(blasub),maxnq,Defaul,Hypdim,Topcon,Sidcon,Proacr,&
                                    & Prodow,Imem(imem2),nimem2)
                          !WRITE (*,*) 'OLDNOD,RENUM(OLDNOD):' , 1 , Renum(1)
                          !WRITE (*,*) 'NDOM,DEFAUL' , Ndom , Defaul
                          END
                    !*==FORMA.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    ! **************END OF MAIN ********************************
                    !
                    !
                    !
                    !
                          SUBROUTINE FORMA(Cgrid,Maxtot,Totnod,Nonods,Nodlev,Ptcola,Nlevel, &
                                         & Fina,Cola,A,Maxna,Na,Color,Q,Qtemp,List,X,Y,     &
                                         & Havmat)
                          IMPLICIT NONE
                    !*--FORMA2379
                    !*** Start of declarations inserted by SPAG
                          INTEGER inca , Maxna , maxna2 , ncolo , ncolor , nnod , nod
                    !*** End of declarations inserted by SPAG
                    ! COLOR & CGRID can contain the same storage space.
                    ! Q & LIST can contain the same storage space.
                    ! This subroutine forms the matrix A from the
                    ! finnest grid information contained in the matrix A.
                    ! CGRID(Fine grid node)=0 if it is not the cause grid node
                    ! = corresponding cause grid node number, otherwise,
                    ! this number varies between 1 and NSHORT.
                    ! NONODS= number of nodes on the finest grid.
                          INTEGER Havmat
                          INTEGER ONE
                          PARAMETER (ONE=1)
                          INTEGER Nonods
                          INTEGER Totnod , Na , Nlevel , Maxtot
                          INTEGER Cgrid(Maxtot)
                          INTEGER Nodlev(Nlevel+1) , Ptcola(Nlevel+1)
                          INTEGER Fina(Maxtot+Nlevel) , Cola(Maxna)
                          INTEGER Color(Maxtot) , Q(Nonods) , Qtemp(Nonods) , List(Nonods)
                     
                          REAL A(Maxna*Havmat)
                          REAL X(Maxtot) , Y(Maxtot)
                    !
                          INTEGER level
                          INTEGER fnods , cnods , nca , mxnca , fncola
                          LOGICAL zero
                          LOGICAL quick
                    !
                          !WRITE (*,*) 'maxtot=' , Maxtot
                          zero = .TRUE.
                          quick = .TRUE.
                    !
                          Nodlev(1) = 1
                          Nodlev(2) = Nonods + 1
                          Ptcola(1) = 1
                          Ptcola(2) = Fina(Nonods+1)
                          Na = Ptcola(2) - 1
                    !      print *,'forma nlevel=',nlevel
                          DO level = 2 , Nlevel
                    !         print *,'level,nlevel:',level,nlevel
                    ! Colour nodes on level LEVEL-1
                             nnod = Nodlev(level) - Nodlev(level-1)
                             maxna2 = Ptcola(level) - Ptcola(level-1)
                    !         print *,'level,nnod,maxna2:',level,nnod,maxna2
                    !
                    !          IF(LEVEL.EQ.-level) THEN
                    !            CALL DRAXYZ(X(NODLEV(LEVEL-1)),Y(NODLEV(LEVEL-1)),
                    !     &              FINA(NODLEV(LEVEL-1)+LEVEL-2),
                    !     &                 COLA(PTCOLA(LEVEL-1)),MAXNA2,NNOD)
                    !           ENDIF
                    !
                    !         print *,'before color2' 
                             CALL COLOR2(Color(Nodlev(level-1)),ncolor,Q,Qtemp,nnod,        &
                                       & Fina(Nodlev(level-1)+level-2),Cola(Ptcola(level-1))&
                                       & ,maxna2,zero,quick)
                    !         print *,'after color2'
                    !
                    !
                    ! Work out CGRID & NCOLO & NODLEV(LEVEL+1).
                             ncolo = 0
                             DO nod = Nodlev(level-1) , Nodlev(level) - 1
                                IF ( Color(nod).EQ.ONE ) THEN
                                   ncolo = ncolo + 1
                                   Cgrid(nod) = ncolo
                                ELSE
                                   Cgrid(nod) = 0
                                ENDIF
                             ENDDO
                             Nodlev(level+1) = Nodlev(level) + ncolo
                    !          print *,'ncolo:',ncolo
                    !
                    ! Work out A for level LEVEL.
                             fnods = Nodlev(level) - Nodlev(level-1)
                             cnods = Nodlev(level+1) - Nodlev(level)
                             fncola = Ptcola(level) - Ptcola(level-1)
                             mxnca = Maxna - Ptcola(level) + 1
                             !WRITE (*,*) '999777 LEVEL=' , level
                    !         print *,'havmat=',havmat
                             IF ( Havmat.EQ.1 ) THEN
                                CALL LOCALA(A(Ptcola(level)),A(Ptcola(level-1)),fnods,cnods,&
                                          & Cgrid(Nodlev(level-1)),Cola(Ptcola(level)),     &
                                          & Cola(Ptcola(level-1)),                          &
                                          & Fina(Nodlev(level)+level-1),                    &
                                          & Fina(Nodlev(level-1)+level-2),nca,mxnca,fncola, &
                                          & List,Nonods,X(Nodlev(level-1)),                 &
                                          & Y(Nodlev(level-1)),X(Nodlev(level)),            &
                                          & Y(Nodlev(level)),Havmat)
                             ELSE
                    !              print *,'level,Nodlev(level):',level,Nodlev(level)
                    !              print *,'fnods,cnods:',fnods,cnods
                                CALL LOCALA(A,A,fnods,cnods,Cgrid(Nodlev(level-1)),         &
                                          & Cola(Ptcola(level)),Cola(Ptcola(level-1)),      &
                                          & Fina(Nodlev(level)+level-1),                    &
                                          & Fina(Nodlev(level-1)+level-2),nca,mxnca,fncola, &
                                          & List,Nonods,X(Nodlev(level-1)),                 &
                                          & Y(Nodlev(level-1)),X(Nodlev(level)),            &
                                          & Y(Nodlev(level)),Havmat)
                             ENDIF
                    !          print *,'finished locala'
                    !
                    !           write(*,*)'JUST AFTER LOCALA call checka'
                    !       CALL CHECKA(A(PTCOLA(LEVEL)),
                    !     &            FINA(NODLEV(LEVEL)+LEVEL-1),
                    !     &            COLA(PTCOLA(LEVEL)),NCA,cnods )
                    !
                             Na = Na + nca
                    !       print *,'1'
                             Ptcola(level+1) = Ptcola(level) + nca
                    !       print *,'2'
                             inca = Fina(Nodlev(level)+cnods+level-1)                       &
                                  & - Fina(Nodlev(level)+level-1)
                    !       print *,'3'
                             !WRITE (*,*) 'NCA,INCA:' , nca , inca
                    !
                    !
                          ENDDO
                    !       print *,'4'
                    !
                          Totnod = Nodlev(Nlevel+1) - 1
                    !       print *,'5'
                          IF ( Totnod.GT.Maxtot ) THEN
                             !WRITE (*,*) 'MAXTOT.LT.TOTNOD; Totnod,Maxtot:',Totnod,Maxtot
                             print*, 'nlevel,Totnod,Maxtot:',nlevel,Totnod,Maxtot
                             STOP 1121
                          ENDIF
                    !       print *,'6'
                    !
                          END SUBROUTINE FORMA
                    !*==LOCALA.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE LOCALA(Ca,Fa,Fnods,Cnods,Cgrid,Ccola,Fcola,Cfina,Ffina,&
                                          & Nca,Mxnca,Fncola,List,Mxlist,Fx,Fy,Cx,Cy,Havmat)
                          IMPLICIT NONE
                    !*--LOCALA2500
                    !*** Start of declarations inserted by SPAG
                          integer c2nod
                          INTEGER i , iinod , inod , nlist , nod
                    !*** End of declarations inserted by SPAG
                          logical non_uniform_weights
                          parameter(non_uniform_weights=.true.) 
                          INTEGER Havmat
                          INTEGER Fnods , Cnods , Nca , Mxnca , Fncola
                          INTEGER Cgrid(Fnods) , Ccola(Mxnca) , Fcola(Fncola)
                          INTEGER Cfina(Cnods+1) , Ffina(Fnods+1)
                          INTEGER ccount , count , count2 , cnod
                          INTEGER Mxlist , List(Mxlist)
                          REAL Fx(Fnods) , Fy(Fnods) , Cx(Cnods) , Cy(Cnods)
                          REAL Fa(Fncola*Havmat) , Ca(Mxnca*Havmat)
                          LOGICAL yes
                          real weight, cdiag
                          integer nweight, ccol,fcol, fcol1,fcol2, fcount,fcount2,fnod
                          integer, allocatable :: c2f(:) 
                    ! This sub finds the matrix on the causer mesh
                    ! from the matrix on the finner mesh.
                    ! Work out A for level LEVEL.
                          ccount = 0
                          DO nod = 1 , Fnods
                             cnod = Cgrid(nod)
                             IF ( cnod.NE.0 ) THEN
                                Cx(cnod) = Fx(nod)
                                Cy(cnod) = Fy(nod)
                                nlist = 0
                                Cfina(cnod) = ccount + 1
                                DO count = Ffina(nod) , Ffina(nod+1) - 1
                                   inod = Fcola(count)
                                   DO count2 = Ffina(inod) , Ffina(inod+1) - 1
                                      iinod = Fcola(count2)
                                      c2nod = Cgrid(iinod)
                                      IF ( c2nod.NE.0 ) THEN
                    ! Is C2NOD in list of cause grid nodes surrounding cause node CNOD.
                                         yes = .TRUE.
                                         DO i = 1 , nlist
                                            IF ( c2nod.EQ.List(i) ) yes = .FALSE.
                                         ENDDO
                                         IF ( yes ) THEN
                                            nlist = nlist + 1
                                            List(nlist) = c2nod
                                         ENDIF
                                      ENDIF
                                   ENDDO
                                ENDDO
                    ! Put list in assending order
                    ! - now called GEM_IBUBLE to avoid clash with fluidity's version
                    ! - (in case the two become different somehow...)
                                CALL GEM_IBUBLE(List,nlist)
                                DO i = 1 , nlist
                                   ccount = ccount + 1
                                   Ccola(ccount) = List(i)
                                ENDDO
                                Cfina(cnod+1) = ccount + 1
                             ENDIF
                          ENDDO
                          Nca = ccount
                    ! 
                    ! Now find the cause A (-CA) from the fine A (-FA).
                          IF ( Havmat.EQ.1 ) THEN
                             if(non_uniform_weights) then ! obtains ca from fa - course grid graph weights from fine. 
                    !             print *,'here112'
                    !             stop 12
                                allocate(c2f(cnods)) 
                                do fnod = 1 , fnods
                                   cnod = cgrid(fnod)
                                   if ( cnod.ne.0 ) then
                                     c2f(cnod) = fnod
                                   endif
                                end do
                                do cnod = 1 , cnods
                                   fnod = c2f(cnod) 
                                   do ccount=cfina(cnod), cfina(cnod+1)-1
                                      ccol=ccola(ccount)
                                      fcol=c2f(ccol) 
                                      weight=0.0
                                      nweight=0
                    ! --------------- form the weight for this edge...
                                      do fcount=ffina(fnod),ffina(fnod+1)-1
                                         fcol1=fcola(fcount) 
                                         if(fcol1.ne.fnod) then ! off digaonals only
                                            do fcount2=ffina(fcol),ffina(fcol+1)-1
                                               fcol2=fcola(fcount2) 
                                               if(fcol1==fcol2) then
                                                  weight=weight + 0.5*( fa(fcount) + fa(fcount2) )
                                                  nweight=nweight+1
                    !                              print *,'cnod, nweight,weight, fa(fcount), fa(fcount2):', &
                    !                                       cnod, nweight,weight, fa(fcount), fa(fcount2)
                                               endif
                                            end do
                                         endif ! if(fcol1.ne.fnod) then
                                      end do
                                      ca(ccount) = weight/real( max(1,nweight) ) ! make sure we dont divid by 0 
                    ! ---------------
                                   end do ! do ccount=cfina(cnod), cfina(cnod+1)-1
                    ! form the diagonal of the course graph...
                                   cdiag=0.0 
                                   do fcount=ffina(fnod), ffina(fnod+1)-1
                                      fcol=fcola(fcount)
                                      if(fnod==fcol) cdiag = fa(fcount)
                                   end do
                                   do ccount=cfina(cnod), cfina(cnod+1)-1
                                      ccol=ccola(ccount)
                                      if(ccol==cnod) ca(ccount) = cdiag
                                   end do
                                end do ! do cnod = 1 , cnods
                    !             print *,'nca,ca(1:nca):',nca,ca(1:nca)
                    !             print *,'fncola,fa(1:fncola):',fncola,fa(1:fncola)
                    !             stop 1112
                             else ! if(non_uniform_weights) then
                                DO count = 1 , Nca
                                   Ca(count) = 1.
                                ENDDO
                                DO cnod = 1 , Cnods
                                   DO count = Cfina(cnod) , Cfina(cnod+1) - 1
                                      IF ( Ccola(count).EQ.cnod ) Ca(count) = 0.
                                   ENDDO
                                ENDDO
                                IF ( Nca.GT.Mxnca ) THEN
                                   !WRITE (*,*) 'NOT ENOUGH MEMORY SENT DOWN'
                                   !WRITE (*,*) 'INSIDE LOCALA'
                                   STOP
                                ENDIF
                             endif ! if(non_uniform_weights) then else
                          ENDIF ! IF ( Havmat.EQ.1 ) THEN
                          END
                    !*==GEM_IBUBLE.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    ! - now called GEM_IBUBLE, to avoid clash with fluidity's version
                    ! - (will the two ever become different? -well, never mind...)
                    !
                          SUBROUTINE GEM_IBUBLE(List,Nlist)
                          IMPLICIT NONE
                    !*--GEM_IBUBLE2582
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ii , j , Nlist
                    !*** End of declarations inserted by SPAG
                          INTEGER List(Nlist)
                          DO i = 1 , Nlist
                             DO j = 2 , Nlist
                                IF ( List(j-1).GT.List(j) ) THEN
                    ! SWOP
                                   ii = List(j-1)
                                   List(j-1) = List(j)
                                   List(j) = ii
                                ENDIF
                             ENDDO
                          ENDDO
                          END
                    !*==NEUR.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE NEUR(Whichd,Cgrid,V,B,Tscale,Nodlev,Ptcola,Totnod,     &
                                        & Nonods,Onsubd,Fina,Cola,A,Na,Nlevel,Alpha,Lodbal, &
                                        & Beta,Toler,Nchain,Havmat,EXACT, havwnod, wnod)
                          IMPLICIT NONE
                    !*--NEUR2606
                    !*** Start of declarations inserted by SPAG
                          INTEGER icstar , ifini2 , ifleve , ifstar , iileve , ilevel ,     &
                                & istar2 , istart , Na , ncola , Nlevel , nonod2
                          REAL rmean
                          LOGICAL EXACT
                    !*** End of declarations inserted by SPAG
                          INTEGER Havmat, havwnod
                          REAL Beta , Toler
                          INTEGER Onsubd , Nonods , Totnod
                          INTEGER Nchain
                          REAL V(Totnod*Onsubd)
                          REAL B(Nonods*Onsubd)
                          REAL Lodbal , beta2 , Alpha
                          REAL A(Na*Havmat) , Tscale(Nonods)
                          real wnod(totnod) 
                          INTEGER i , fnods , cnods, ifstart, icstart
                          INTEGER Cola(Na) , Fina(Totnod+Nlevel)
                          INTEGER Whichd(Totnod) , Cgrid(Totnod)
                          INTEGER Nodlev(Nlevel+1) , Ptcola(Nlevel+1)
                          LOGICAL satur , mixup
                          INTEGER IREPEAT,NREPEAT
                          PARAMETER(NREPEAT=100) 
                          logical miss_out_levels_whichd, balanced, backup_plan
                          parameter(miss_out_levels_whichd=.true.) ! We dont need whichd for the different levels
                          parameter( backup_plan=.true. )  ! try the backup plan...
                    ! WHICHD(NOD) can overwrite CGRID to save space.
                    ! WHICHD(NOD) contains the subdomain that node NOD is in.
                    ! NONODS=number of nodes on the finnest grid level.
                    ! TOTNOD=total number of nodes on all grid levels.
                    ! if exact balance the no of nodes in each subdomain. 
                    ! only works for uniform WNOD 
                        !  WRITE (*,*) 'INSIDE NEUR ONSUBD,totnod,nlevel:' , Onsubd ,        &
                        !            & Totnod , Nlevel
                    !      print *,'--wnod(1:nonods):',wnod(1:nonods)
                    
                          IF(TOTNOD.EQ.0) RETURN ! NOTHING TO DO AS EVERYTHING HAS ZERO LENGTH
                    !
                    
                          IF(HAVWNOD.NE.0) then
                             DO ilevel = 1 , nlevel-1
                                iileve = ilevel + 1
                                fnods = Nodlev(iileve) - Nodlev(iileve-1)
                                cnods = Nodlev(iileve+1) - Nodlev(iileve)
                                istart = Nodlev(iileve-1)
                                ncola = Ptcola(iileve) - Ptcola(iileve-1)
                                ifstart = Nodlev(iileve-1)
                                icstart = Nodlev(iileve)
                                ifleve = iileve - 1
                                CALL MAP_SIMPL(WNOD(ifstart),WNOD(icstart),fnods,cnods,Cgrid(istart), &
                                               Fina(Nodlev(ifleve)+ifleve-1),Cola(Ptcola(ifleve)),ncola)
                    !            if(ilevel==nlevel-1) then
                    !               print *,'nonods,icstart,fnods,cnods:',nonods,icstart,fnods,cnods
                    !               PRINT *,'WNOD(icstart:icstart+cnods-1):',WNOD(icstart:icstart+cnods-1)
                    !               stop 292
                    !            endif
                             END DO
                          ENDIF ! IF(HAVWNOD.NE.0) then
                    !
                    ! NB TOTNOD is the total number of cause and fine grid nodes.
                    !
                    !
                          DO ilevel = Nlevel , 1 , -1
                    ! LEVEL 1 is the fine mesh.
                    !
                             beta2 = Beta
                    !
                    !
                           DO IREPEAT=1,NREPEAT
                             IF ( ilevel.NE.Nlevel ) THEN
                                mixup = .FALSE.
                                iileve = ilevel + 1
                                fnods = Nodlev(iileve) - Nodlev(iileve-1)
                                cnods = Nodlev(iileve+1) - Nodlev(iileve)
                                ifstar = (Nodlev(iileve-1)-1)*Onsubd + 1
                                icstar = (Nodlev(iileve)-1)*Onsubd + 1
                                istart = Nodlev(iileve-1)
                                ifleve = iileve - 1
                                ncola = Ptcola(iileve) - Ptcola(iileve-1)
                    !
                                CALL MAP(V(ifstar),V(icstar),fnods,cnods,Onsubd,            &
                                       & Fina(Nodlev(ifleve)+ifleve-1),Cola(Ptcola(ifleve)),&
                                       & Cgrid(istart),ncola)
                             ELSE
                                mixup = .TRUE.
                             ENDIF
                    !
                             nonod2 = Nodlev(ilevel+1) - Nodlev(ilevel)
                             istart = Nodlev(ilevel)
                             istar2 = (Nodlev(ilevel)-1)*Onsubd + 1
                             ifini2 = (Nodlev(ilevel+1)-1)*Onsubd
                             ncola = Ptcola(ilevel+1) - Ptcola(ilevel)
                    !
                             !WRITE (*,*) '**** ILEVEL=' , ilevel
                    !
                             !WRITE (*,*) 'HAVMAT=' , Havmat
                             IF ( Havmat.EQ.1 ) THEN
                                CALL NEURAL(V(istar2),B,Tscale,mixup,nonod2,Onsubd,         &
                                          & Fina(Nodlev(ilevel)+ilevel-1),                  &
                                          & Cola(Ptcola(ilevel)),A(Ptcola(ilevel)),ncola,   &
                                          & Lodbal,beta2,Toler,Nchain,Havmat, havwnod,wnod(istart))
                             ELSE
                              !print *,'istar2,Totnod,Onsubd,NONODS=',istar2,Totnod,Onsubd,NONODS
                                CALL NEURAL(V(istar2),B,Tscale,mixup,nonod2,Onsubd,         &
                                          & Fina(Nodlev(ilevel)+ilevel-1),                  &
                                          & Cola(Ptcola(ilevel)),A,ncola,Lodbal,beta2,Toler,&
                                          & Nchain,Havmat, havwnod,wnod(istart))
                             ENDIF
                    
                    !
                    ! Test the validity of solution V ****************
                             rmean = 0.
                             DO i = istar2 , ifini2
                                rmean = rmean + MAX(V(i),1.-V(i))
                             ENDDO
                             rmean = rmean/max(REAL(ifini2-istar2),  1.0e-9)
                             satur = .TRUE.
                             IF ( rmean.LT.0.7 ) satur = .FALSE.
                             !WRITE (*,*) 'THE SOLUTION SATURATION :RMEAN=' , rmean
                             !!print *,'v:',v
                             !WRITE (*,*) 'SATUR=' , satur
                    !
                             IF ( .NOT.satur ) THEN
                                beta2 = beta2*0.8
                             ELSE 
                                EXIT ! DONT REPEAT ANY MORE
                             ENDIF
                           END DO ! DO IREPEAT=1,NREPEAT
                    !
                    ! *************************************************
                    !
                             mixup = .FALSE.
                    !
                          ENDDO
                    !
                    !
                          !WRITE (*,*) 'INSIDE NEUR HERE 4'
                    !
                    ! MAKE SURE ALL NODES ARE SATURATED ***************.
                    ! WORK OUT WHICHD *********************************.
                          if(miss_out_levels_whichd) then ! We dont need whichd for the different levels
                    !         print *,'£££ making exact nonods:',nonods
                             CALL FIWICD(V(1),Whichd(1),nonods,Onsubd,exact,havwnod,wnod(1),balanced)
                             if(backup_plan) then ! try the backup plan...
                             if(exact) then ! make sure its exact...
                                if(.not.balanced) then ! then form the balance in another way
                                if((onsubd==2).and.(nonods>2)) then
                    ! remove or add nodes until its exact to within one- alternative backup...
                    !               print *,'going into alt_balance_exact'
                                   call alt_balance_exact(whichd,nonods,fina,cola,ncola,havwnod,wnod) 
                                endif
                                endif 
                             endif ! if(exact) then
                             endif ! if(backup_plan) then 
                          else
                             DO ilevel = Nlevel , 1 , -1
                    !            print *,'ilevel,nlevel,cnods:',ilevel,nlevel,cnods
                                cnods = Nodlev(ilevel+1) - Nodlev(ilevel)
                                icstar = (Nodlev(ilevel)-1)*Onsubd + 1
                                istart = Nodlev(ilevel)
                                CALL FIWICD(V(icstar),Whichd(istart),cnods,Onsubd,exact,havwnod,wnod(istart),balanced)
                             ENDDO
                          endif
                    ! *************************************************.
                          !WRITE (*,*) 'GOING OUT OF NEUR ONSUBD:' , Onsubd
                          RETURN
                          END
                    !*==CHECKA.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          subroutine alt_balance_exact(whichd,nonods,fina,cola,ncola,havwnod,wnod_in) 
                    ! Remove or add nodes until its exact to within one- alternative backup...
                          integer, INTENT(IN) :: nonods, ncola, havwnod
                          integer, INTENT(IN) :: fina(nonods+1), cola(ncola)
                          real, INTENT(IN) :: wnod_in(nonods) 
                          integer, INTENT(inout) :: whichd(nonods)
                    ! local variables...
                          real w_sub_count, w_sub_count_aim, toler
                          integer nod,its,count,col, count2,col2, nod_keep, valancy_keep, valancy
                          logical more,less,changed
                    
                          real, allocatable :: wnod(:)
                    
                          allocate(wnod(nonods))
                          if(havwnod.ne.0) then
                             wnod(:)=wnod_in(:)
                          else
                             wnod(:)=1.0
                          endif
                    
                          toler=0.25*minval( wnod(1:nonods) ) 
                          w_sub_count=0.0
                          do nod=1,nonods
                             if(whichd(nod)==1) then
                                w_sub_count=w_sub_count+wnod(nod) 
                             else 
                                whichd(nod)=2 
                             endif
                          end do
                          if((w_sub_count<toler).or.(abs(w_sub_count -sum( wnod(1:nonods)) )<toler)) then
                             whichd(:)=2
                             nod=1
                             whichd(nod)=1  
                             w_sub_count = wnod(nod) 
                          endif
                          w_sub_count_aim = sum( wnod(1:nonods) )/2.0  
                    !      if(abs(w_sub_count - w_sub_count_aim )<minval( wnod(1:nonods) )+toler) then ! found the best partition
                    !      if(abs(w_sub_count - w_sub_count_aim )<toler) then ! found the best partition
                          if(abs(w_sub_count - (2.*w_sub_count_aim-w_sub_count) )<minval( wnod(1:nonods) )+toler) then ! found the best partition
                             less=.true.
                             more=.true.
                          else 
                             less=.false.
                             more=.false.
                          endif
                    
                          do its=1,nonods
                             changed=.false.
                             do nod=1,nonods
                    
                                if(whichd(nod)==1) then
                                   if(w_sub_count<w_sub_count_aim-toler) then
                                      less=.true.
                                      if(.not.more) then
                                         nod_keep=0
                                         valancy_keep=0
                                         do count=fina(nod),fina(nod+1)-1
                                            col=cola(count) 
                                            if(whichd(col)==2) then
                                               valancy=0
                                               do count2=fina(col),fina(col+1)-1
                                                  col2=cola(count2)
                                                  if(whichd(col2)==1) then
                                                     valancy=valancy+1
                                                  endif
                                               end do
                                               if(valancy>valancy_keep) then
                                                  valancy_keep=valancy
                                                  nod_keep=col
                                               endif
                                            endif ! if(whichd(col)==2) then
                                         end do ! do count=fina(nod),fina(nod+1)-1
                    
                                         col=nod_keep
                                         if(col>0) then
                                            if(whichd(col)==2) then
                                               changed=.true.
                                               w_sub_count=w_sub_count+wnod(col)
                                               whichd(col)=1
                                            endif ! if(whichd(col)==2) then
                                         endif ! if(col>0) then
                    
                                      endif ! if(.not.more) then
                                   endif ! if(sub_count<sub_count_aim-toler) then
                                endif ! if(whichd(nod)==1) then
                    ! 
                                if(whichd(nod)==2) then
                                   if(w_sub_count>w_sub_count_aim+toler) then
                                      more=.true.
                                      if(.not.less) then
                                         nod_keep=0
                                         valancy_keep=0
                                         do count=fina(nod),fina(nod+1)-1
                                            col=cola(count) 
                                            if(whichd(col)==1) then
                                               valancy=0
                                               do count2=fina(col),fina(col+1)-1
                                                  col2=cola(count2)
                                                  if(whichd(col2)==2) then
                                                     valancy=valancy+1
                                                  endif
                                               end do
                                               if(valancy>valancy_keep) then
                                                  valancy_keep=valancy
                                                  nod_keep=col
                                               endif
                                            endif ! if(whichd(col)==1) then
                                         end do ! do count=fina(nod),fina(nod+1)-1
                    
                                         col=nod_keep
                                         if(col>0) then
                                            if(whichd(col)==1) then
                                               changed=.true.
                                               w_sub_count=w_sub_count-wnod(col)
                                               whichd(col)=2
                                            endif ! if(whichd(col)==2) then
                                         endif ! if(col>0) then
                    
                                      endif ! if(.not.less) then
                                   endif ! if(sub_count<sub_count_aim+toler) then
                                endif ! if(whichd(nod)==2) then
                    ! 
                                if(more.and.less) exit
                    
                             end do ! do nod=1,nonods
                             if(more.and.less) exit
                             if(w_sub_count>w_sub_count_aim-toler) then
                                if(w_sub_count<w_sub_count_aim+toler) then
                                   exit
                                endif
                             endif
                    
                             if(.not.changed) then
                                do nod=1,nonods
                                   if(whichd(nod)==2) then
                                      if(w_sub_count<w_sub_count_aim-toler) then
                                         less=.true.
                                         if(.not.more) then
                                            whichd(nod)=1
                                            w_sub_count=w_sub_count+wnod(nod)
                                            changed=.true.
                                         endif
                                      endif ! if(w_sub_count<w_sub_count_aim) then
                                   else
                                      if(w_sub_count>w_sub_count_aim+toler) then
                                         more=.true.
                                         if(.not.less) then
                                            whichd(nod)=2
                                            w_sub_count=w_sub_count-wnod(nod)
                                            changed=.true.
                                         endif
                                      endif ! if(w_sub_count>w_sub_count_aim) then
                                   endif
                                   if(changed) exit
                                end do ! do nod=1,nonods
                             endif ! if(.not.changed) then
                    
                             if(more.and.less) exit
                          end do ! do its=1,nonods
                    
                          count=0
                          do nod=1,nonods
                             if(whichd(nod)==1) count=count+1
                          end do
                    
                    !      print *,'whichd(1:min(100,nonods)):',whichd(1:min(100,nonods))
                    !!      print *,'wnod(1:min(100,nonods)):',wnod(1:min(100,nonods))
                    !      print *,'nonods, w_sub_count, w_sub_count_aim:',nonods, w_sub_count, w_sub_count_aim
                    !      print *,'no of subdomain 1 nodes, nonods:',count,nonods
                    !      stop 24
                          return 
                          end subroutine alt_balance_exact
                    !
                    !
                    !
                    !
                          SUBROUTINE CHECKA(A,Fina,Cola,Ncola,Nonods)
                          IMPLICIT NONE
                    !*--CHECKA2724
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , icol , j
                    !*** End of declarations inserted by SPAG
                    ! This sub checks to see if A is O.K.
                          INTEGER Ncola , Nonods , Fina(Nonods+1) , Cola(Ncola)
                          INTEGER count
                          REAL A(Ncola)
                          IF ( Ncola.LT.Fina(Nonods+1)-1 ) THEN
                             !WRITE (*,*) 'INSIDE CHECKA'
                             !WRITE (*,*) 'PROBLEM WITH BOUNDS'
                             STOP
                          ENDIF
                          DO i = 1 , Nonods
                             DO count = Fina(i) , Fina(i+1) - 1
                                icol = Cola(count)
                                IF ( icol.NE.i ) THEN
                                   IF ( A(count).LT.0.00001 ) THEN
                                      !WRITE (*,*) 'PROBLEM WITH A:'
                                      !WRITE (*,*) 'COUNT,I,ICOL:' , count , i , icol
                                      !WRITE (*,*) 'A(COUNT):' , A(count)
                                      !WRITE (*,*) 'FINA(I+1)-FINA(I):' , Fina(i+1) - Fina(i)
                                      !WRITE (*,*) 'A(J),J=FINA(I),FINA(I+1)-1' ,            &
                                      !          & (A(j),j=Fina(i),Fina(i+1)-1)
                                      STOP
                                   ENDIF
                                ENDIF
                             ENDDO
                          ENDDO
                          END
                    !*==FIWICD.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE FIWICD(V,Whichd,Nonods,Onsubd,exact,havwnod,wnod,balanced)
                          IMPLICIT NONE
                    !*--FIWICD2761
                    !*** Start of declarations inserted by SPAG
                    !*** End of declarations inserted by SPAG
                    ! This sub finds whichd from the neuron values V.
                    ! if exact calculate which subdomain every node belong too to exactly balance the load as far as possible. 
                          INTEGER Nonods , Onsubd , Whichd(Nonods) , havwnod
                          REAL V(Nonods*Onsubd) , wnod(nonods)
                          logical balanced
                          logical exact,bal
                    ! local variables
                          INTEGER i , i1, ii , isub, n_nods_bal
                          INTEGER sub , maxsub
                          REAL maxv
                          maxsub=0
                    !          stop 22
                          DO i = 1 , Nonods
                             maxv = 0.
                             DO sub = 1 , Onsubd
                                IF ( V((sub-1)*Nonods+i).GT.maxv ) THEN
                                   maxv = V((sub-1)*Nonods+i)
                                   maxsub = sub
                                ENDIF
                    !             V((SUB-1)*NONODS+I)=0.
                             ENDDO
                    !          V((MAXSUB-1)*NONODS+I)=1.
                             if(maxsub==0) stop 8221
                             Whichd(i) = maxsub
                          ENDDO
                    
                          if(exact) then ! try to make balance the number of nodes. 
                             whichd=0
                             balanced=.true.
                             DO isub = 1 , Onsubd
                                call critical_bal_size(isub,v((isub-1)*nonods+1),onsubd,nonods,whichd,havwnod,wnod,bal) ! only consider subdomains that have not been filled in. 
                    !            print *,'isub, nonods, sum(v((isub-1)*nonods+1:isub*nonods)):',isub, nonods,  sum(v((isub-1)*nonods+1:isub*nonods))
                                if(.not.bal) balanced=.false. 
                             end do
                          endif
                    
                    ! count no of nodes in each subdomain
                          !WRITE (*,*) 'onsubd,nonods:' , Onsubd , Nonods
                          i1=0
                          II=0
                          DO isub = 1 , Onsubd
                             ii = 0
                             DO i = 1 , Nonods
                                IF ( Whichd(i).EQ.isub ) ii = ii + 1
                             ENDDO
                             i1=i1+ii
                    !         WRITE (*,*) 'no of nodes in sub=' , isub , ' is =' , ii
                          ENDDO
                          if(onsubd==-2) then
                             if(nonods<2000) then
                                if(ii==0) stop 28
                                if(abs(i1-2*ii)>30) then
                                   DO i = 1 , -Nonods
                                      DO sub = 1 , Onsubd
                                         print *,'sub,i,V((sub-1)*Nonods+i):',sub,i,V((sub-1)*Nonods+i)
                                      end do
                                   end do
                                   stop 2911
                                endif
                             endif
                          endif
                          RETURN
                          END SUBROUTINE FIWICD
                    !*==MAP.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE critical_bal_size(isub,v,onsubd,nonods,whichd,havwnod,wnod,balanced) ! only consider subdomains that have not been filled in.
                    ! calculate which subdomain every node belong too to exactly balance the load as far as possible. 
                          implicit none
                          integer isub,onsubd,nonods,havwnod
                          real wnod(nonods) 
                          real v(nonods)
                          integer whichd(nonods)
                          logical balanced
                    ! local variables...
                          integer nits
                          parameter(nits=100) 
                          integer its,nod
                          real n_nods_bal
                          real low_crit_bal,high_crit_bal
                          real crit_bal,rwsum,rcount,tol_near_one
                    
                          if(isub==onsubd) then
                             balanced=.true.
                             do nod=1,nonods
                                if(whichd(nod)==0) whichd(nod)=isub
                             end do
                             return ! simple end to make sure we have all the nodes attached to subdomains. 
                          endif
                    
                          if(havwnod.ne.0) then
                             rwsum = sum(wnod) 
                          else
                             rwsum = real(nonods)
                          endif
                    
                          n_nods_bal=rwsum/real(onsubd)  
                    
                          tol_near_one = 0.99* rwsum/real(nonods) 
                    
                          low_crit_bal=0.0
                          high_crit_bal=1.0    
                    
                          crit_bal=1.0/real(onsubd)
                    
                          balanced=.false. 
                    
                          do its=1,nits
                    
                             rcount=0.0
                             do nod=1,nonods
                                if(whichd(nod)==0) then
                                   if(havwnod.ne.0) then
                                      if(v(nod).gt.crit_bal) rcount=rcount+wnod(nod) 
                                   else
                                      if(v(nod).gt.crit_bal) rcount=rcount+1.0
                                   endif
                                endif
                             end do
                             if(rcount.gt.n_nods_bal) then
                                low_crit_bal=crit_bal
                             else
                                high_crit_bal=crit_bal
                             endif
                             !print *,'its,low_crit_bal,high_crit_bal,isub,count,n_nods_bal:', &
                             !         its,low_crit_bal,high_crit_bal,isub,count,n_nods_bal
                    
                    !         if( (count > n_nods_bal-1.000001).and.(count < n_nods_bal+1.000001) ) exit 
                             if( (rcount > n_nods_bal-tol_near_one).and.(rcount < n_nods_bal+tol_near_one) ) then
                                balanced=.true. 
                                exit 
                             endif
                    !         if( (count > n_nods_bal-0.99).and.(count < n_nods_bal+0.99) ) exit 
                    !         if( (count > n_nods_bal-0.1).and.(count < n_nods_bal+0.1) ) exit 
                             crit_bal=0.5*(low_crit_bal + high_crit_bal) 
                          end do ! do its=1,nits
                    
                          rcount=0.0
                          do nod=1,nonods
                             if(whichd(nod)==0) then
                                if(v(nod).gt.crit_bal) then
                                   rcount=rcount+1.0
                                   whichd(nod)=isub
                                end if
                             endif
                          end do
                    !      print *,'rcount,nonods,nonods-rcount:',rcount,nonods,nonods-rcount
                    !      stop 282
                    
                          !print *,'final isub,nod of nodes,n_nods_bal:',isub,count,n_nods_bal
                    !      !print *,'-v:',v
                          
                          return
                          end 
                    !
                    !
                    !
                    !
                          SUBROUTINE MAP_SIMPL(Vl,Vs,Nonods,Nshort,Cgrid, &
                                               FINAF,COLAF,NCOLAF)
                          IMPLICIT NONE
                    !*--MAP2797
                    !*** Start of declarations inserted by SPAG
                          INTEGER Nonods, Nshort, NCOLAF
                          LOGICAL SIMPLE_INTERP
                          PARAMETER(SIMPLE_INTERP=.FALSE.)
                    !*** End of declarations inserted by SPAG
                          INTEGER Onsubd
                          INTEGER Cgrid(Nonods) 
                          REAL Vl(Nonods) , Vs(Nshort)
                          integer FINAF(NONODS+1),COLAF(NCOLAF)
                    ! CGRID(Fine grid node)=0 if it is not the cause grid node
                    ! = corresponding cause grid node number, otherwise,
                    ! this number varies between 1 and NSHORT.
                    ! Lcal variables...
                          INTEGER COUNT,ICOUNT,J, ndcgri , nod 
                          REAL RSUM
                    
                          DO nod = 1 , Nonods
                    !
                             ndcgri = Cgrid(nod)
                    !         IF ( ndcgri.NE.0 ) Vl(NOD) = Vs(ndcgri)
                             IF ( ndcgri.NE.0 )  THEN
                                IF(SIMPLE_INTERP) THEN
                                   Vs(ndcgri) = Vl(NOD)
                                ELSE
                                   RSUM=0.0
                                   ICOUNT=0
                                   DO COUNT=FINAF(NOD),FINAF(NOD+1)-1
                                      J=COLAF(COUNT)
                                      RSUM=RSUM + Vl(J)
                                      ICOUNT=ICOUNT+1
                                   END DO
                                   ICOUNT=ICOUNT+1
                                   RSUM=RSUM + Vl(NOD)
                                   Vs(ndcgri) = RSUM/REAL(ICOUNT)
                                ENDIF ! ENDOF IF THEN ELSE IF(SIMPLE_INTERP) THEN
                             ENDIF
                          ENDDO
                          END SUBROUTINE MAP_SIMPL
                    !
                    !
                    !      
                    !
                          SUBROUTINE MAP(Vl,Vs,Nonods,Nshort,Onsubd,Fina,Cola,Cgrid,Ncola)
                          IMPLICIT NONE
                    !*--MAP2797
                    !*** Start of declarations inserted by SPAG
                          INTEGER icol , isub , Ncola , ndcgri , nod , Nonods , Nshort
                          REAL rsum
                    !*** End of declarations inserted by SPAG
                          INTEGER Onsubd
                          INTEGER Cgrid(Nonods) , Fina(Nonods+1) , Cola(Ncola)
                          REAL Vl(Nonods*Onsubd) , Vs(Nshort*Onsubd)
                    ! CGRID(Fine grid node)=0 if it is not the cause grid node
                    ! = corresponding cause grid node number, otherwise,
                    ! this number varies between 1 and NSHORT.
                          logical adjust_small
                          real rsum_min
                          real toler
                          parameter(adjust_small=.true., toler=1.0e-9) 
                          INTEGER count
                    
                          DO isub = 1 , Onsubd
                             DO nod = 1 , Nonods
                                Vl(nod+(isub-1)*Nonods) = 0.
                             ENDDO
                          ENDDO
                    !
                          DO nod = 1 , Nonods
                    !
                             ndcgri = Cgrid(nod)
                             IF ( ndcgri.NE.0 ) THEN
                                DO count = Fina(nod) , Fina(nod+1) - 1
                                   icol = Cola(count)
                                   DO isub = 1 , Onsubd
                                      Vl(icol+(isub-1)*Nonods) = Vl(icol+(isub-1)*Nonods)   &
                                       & + Vs(ndcgri+(isub-1)*Nshort)
                                   ENDDO
                                ENDDO
                             ENDIF
                    !
                          ENDDO
                    !
                          vl=max(vl,toler) ! we need to be safe it seems
                    !
                    !
                    ! Now normalise VL
                          rsum_min=10.0
                          DO nod = 1 , Nonods
                             rsum = 0.
                             DO isub = 1 , Onsubd
                                rsum = rsum + Vl(nod+(isub-1)*Nonods)
                             ENDDO
                             rsum_min = min(rsum_min, rsum) 
                    !          IF(rSUM.LT.0.000001) THEN
                    !            write(*,*)'rSUM,NOD:',rSUM,NOD
                    !            write(*,*)'ABOUT TO DIVIDE BY ZERO'
                    !            STOP
                    !          ENDIF
                             DO isub = 1 , Onsubd
                                Vl(nod+(isub-1)*Nonods) = Vl(nod+(isub-1)*Nonods)/rsum
                             ENDDO
                          ENDDO
                          
                          if(adjust_small) then
                          if(nonods.le.onsubd) then
                             call random_number(vl)
                    !         !print *,'vl:',vl
                             vl = 1./real(onsubd)  + 0.01*(0.5-vl/real(onsubd))
                             vl=max(vl,toler) ! being safe
                    !         !print *,'-vl:',vl
                    !         stop 2011
                             DO nod = 1 , Nonods
                                rsum = 0.
                                DO isub = 1 , Onsubd
                                   
                                   rsum = rsum + Vl(nod+(isub-1)*Nonods)
                                ENDDO
                                DO isub = 1 , Onsubd
                                   Vl(nod+(isub-1)*Nonods) = Vl(nod+(isub-1)*Nonods)/rsum
                                ENDDO
                             ENDDO
                          endif
                          endif
                    
                          !print *,'*********nonods,vl:',nonods,vl
                          END
                    !*==NEURAL.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE NEURAL(V,B,Tscale,Mixup,Nonods,Onsubd,Fina,Cola,A,     &
                                          & Ncola,Lodbal,Beta,Toler,Nchain,Havmat, havwnod,wnod)
                          IMPLICIT NONE
                    !*--NEURAL2855
                    !*** Start of declarations inserted by SPAG
                          INTEGER ichain , iichain , inits , iseed , kk , Ncola , NINITS, havwnod
                          REAL r , rninle
                    !*** End of declarations inserted by SPAG
                          INTEGER Havmat
                          REAL Beta , SUGEST , TOLINT , Toler
                          INTEGER Onsubd , Nonods
                          INTEGER Nchain , MXNDOM
                          real toler_small
                          LOGICAL MISS_OUT_2NODS
                          PARAMETER (MXNDOM=32,MISS_OUT_2NODS=.TRUE.) ! Specify domain decomp if 2 nodes or less
                          PARAMETER (SUGEST=0.1, NINITS=1, toler_small=1.e-15)
                    !        PARAMETER(TOLINT=0.0001,TOLER=0.001)
                    !        PARAMETER(TOLINT=0.0001,TOLER=0.0001)
                          PARAMETER (TOLINT=0.0001)
                          REAL V(Nonods*Onsubd)
                          REAL B(Nonods*Onsubd) , Tscale(Nonods)
                          real wnod(nonods)
                          REAL A(Ncola*Havmat)
                          REAL sumv(MXNDOM) , stoexp(MXNDOM) , rsum
                          REAL Lodbal
                          REAL ttvv , f
                          REAL alpha
                          REAL RAN1 , rran , maxdif, maxgl, wsum
                          INTEGER sub , nodsub , i , j, colaco
                          INTEGER Cola(Ncola) , Fina(Nonods+1)
                          INTEGER count,SUB1,SUB2
                          LOGICAL Mixup
                          REAL, DIMENSION(:), ALLOCATABLE :: wwnod ! the node weights defined internally. 
                    ! LODBAL=1. is the default .gt.1 then more importance
                    ! is placed on load balancing.
                    ! BETA=0.9 is the default but this number controles
                    ! how close to the critical temp the optimization is performed
                    ! WHEN BETA=0.5 - HALF CRYTICAL TEMP IS USED.
                    ! TOLER =the solution tolerence 0.0001 is suggested.
                    ! NCHAIN =maximum no of iterations 3000 is suggested.
                    !
                    ! If MIXUP then start with a random solution else use one already
                    ! in V.
                    ! WHICHD(FNOD) initially contains the number of cause grid
                    ! nodes that fine grid node FNOD takes its value from (IS SURROUNDED BY).
                    ! But eventually contains the subdomain that node FNOD is in.
                    !
                    ! Initialise.
                    ! Randomly initialise only on causest grid *******************
                          !WRITE (*,*) 'inside neural'
                    !      print *,'havwnod,havmat,nonods,ncola,a:',havwnod,havmat,nonods,ncola,a
                    !       print *,'before amending v: sum(V(1:Nonods*Onsubd)),nonods,onsubd:', &
                    !                                   sum(V(1:Nonods*Onsubd)),nonods,onsubd
                          IF(MISS_OUT_2NODS) THEN ! Specify domain decomp if 2 nodes or less
                             IF(NONODS.LE.2) THEN
                                if(nonods.ge.1) then
                                   sub1=1
                                   sub2=2
                                   V=0.0
                                   i = 1 
                                   V((sub1-1)*Nonods+i) = 1. 
                                   V((sub2-1)*Nonods+i) = 0. 
                                   DO i = 2 , Nonods
                                      V((sub1-1)*Nonods+i) = 0. 
                                      V((sub2-1)*Nonods+i) = 1. 
                                   ENDDO
                                endif
                                RETURN
                             ENDIF
                          ENDIF
                    
                          IF ( Mixup ) THEN
                             iseed = 1
                             DO sub = 1 , Onsubd
                                DO i = 1 , Nonods
                                   V((sub-1)*Nonods+i) = 1./REAL(Onsubd)
                                ENDDO
                                DO i = 1 , Nonods
                                   rran = RAN1(iseed)
                                   IF ( rran.GE.1 ) rran = 0.999999
                    !
                                   V((sub-1)*Nonods+i) = rran*SUGEST + 1./REAL(Onsubd)      &
                                                       & - 0.5*SUGEST
                    !
                                ENDDO
                             ENDDO
                          ENDIF
                          !WRITE (*,*) 'inside neural HERE1'
                    !
                          !WRITE (*,*) 'fina(1):' , Fina(1)
                          !WRITE (*,*) 'fina(NONODS+1):' , Fina(Nonods+1)
                          !WRITE (*,*) 'ncola:' , Ncola
                          !WRITE (*,*) 'NONODS:' , Nonods
                          !WRITE (*,*) 'BETA,LODBAL,NCHAIN:' , Beta , Lodbal , Nchain
                    
                          allocate(wwnod(nonods))
                    ! 
                          if(havwnod.ne.0) then
                             wwnod=wnod
                          else
                             wwnod=1.0
                          endif
                    !
                          wsum=sum(wwnod)
                    !
                    ! Work out ALPHA.
                          ttvv = 0.
                          IF ( Havwnod.EQ.2 ) THEN
                             do i=1,nonods
                                DO count = Fina(i) , Fina(i+1) - 1
                                   j = cola(count)
                                   ttvv = ttvv + 0.5*(wwnod(i) + wwnod(j))
                                ENDDO
                    !            ttvv = ttvv - wwnod(i)  ! take away diagonal
                             end do
                          ELSE IF ( Havmat.EQ.1 ) THEN
                             do i=1,nonods
                                DO count = Fina(i) , Fina(i+1) - 1
                                   ttvv = ttvv + A(count)
                    !               print *,'i,a(count):',i, a(count)
                                ENDDO
                             end do
                          ELSE
                             do i=1,nonods
                                DO count = Fina(i) , Fina(i+1) - 1
                                   ttvv = ttvv + 1.
                                ENDDO
                    !            ttvv = ttvv - 1.  ! take away diagonal
                             end do
                          ENDIF
                    !      alpha = Lodbal*REAL(Onsubd)*ttvv/(REAL(Nonods)**2)
                          alpha = Lodbal*REAL(Onsubd)*ttvv/ max( (wsum**2), toler_small )
                    !      WRITE (*,*) 'havwnod,alpha:' , havwnod,alpha
                    !      WRITE (*,*) 'wwnod:',wwnod
                    !      stop 2921
                    !        ALPHA=100.
                    !
                    !
                    ! Work out the source B() for all the neurons.
                          DO sub = 1 , Onsubd
                             rninle = wsum/REAL(Onsubd)
                             DO i = 1 , Nonods
                                ttvv = 0.
                                IF ( Havwnod.EQ.2 ) THEN
                                   DO count = Fina(i) , Fina(i+1) - 1
                                      j = cola(count)
                                      ttvv = ttvv + 0.5*(wwnod(i)+wwnod(j))
                                   ENDDO
                    !               ttvv = ttvv - wwnod(i) ! take away diagonal
                                ELSE IF ( Havmat.EQ.1 ) THEN
                                   DO count = Fina(i) , Fina(i+1) - 1
                                      ttvv = ttvv + A(count)
                    !               print *,'i,a(count):',i, a(count)
                                   ENDDO
                                ELSE
                                   DO count = Fina(i) , Fina(i+1) - 1
                                      ttvv = ttvv + 1.
                                   ENDDO
                    !               ttvv = ttvv - 1. ! take away diagonal
                                ENDIF
                                B(i+(sub-1)*Nonods) = 0.5*(ttvv-alpha*wwnod(i)*rninle)
                             ENDDO
                          ENDDO
                    !
                    !
                    ! Work out TSCALE for all the nodes.
                          DO i = 1 , Nonods
                             ttvv = 0.
                             
                             IF ( Havwnod.EQ.2 ) THEN
                                DO count = Fina(i) , Fina(i+1) - 1
                                  j = cola(count)
                                  ttvv = ttvv + 0.5*(wwnod(i)+wwnod(j))
                                ENDDO
                    !            ttvv = ttvv - wwnod(i) ! take away diagonal
                             ELSE IF ( Havmat.EQ.1 ) THEN
                                DO count = Fina(i) , Fina(i+1) - 1
                                   ttvv = ttvv + A(count)
                    !               print *,'i,a(count):',i, a(count)
                                ENDDO
                             ELSE
                                DO count = Fina(i) , Fina(i+1) - 1
                                   ttvv = ttvv + 1.
                                ENDDO
                    !            ttvv = ttvv - 1. ! subtract out the digonal value
                             ENDIF
                             Tscale(i) = max( Beta*ttvv/REAL(Onsubd) , toler_small ) ! does not depend on load balancing
                    !          if(ttvv.lt.0.00001) then
                    !            write(*,*)'problem with tscale(i),i:',tscale(i),i
                    !            write(*,*)'FINA(I+1)-FINA(I):',FINA(I+1)-FINA(I)
                    !            DO 1865 COUNT=FINA(I),FINA(I+1)-1
                    !              write(*,*)'count,A(COUNT):',count,A(COUNT)
                    !              write(*,*)'COLA(COUNT):',COLA(COUNT)
                    !1865         CONTINUE
                    !            stop
                    !          endif
                          ENDDO
                    !
                    !
                    !
                    !
                    ! NOW START ITERATION
                          iichain = Nchain
                    !       IF(ILEVEL.EQ.NLEVEL) IICHAIN=500
                          DO ichain = 1 , Nchain
                    !        DO 210 ICHAIN=1,IICHAIN
                    ! work out SUMV(SUB)
                             DO sub = 1 , Onsubd
                                rsum = 0.
                                DO i = 1 , Nonods
                                   rsum = rsum + V((sub-1)*Nonods+i)*wwnod(i)
                                ENDDO
                                sumv(sub) = rsum
                             ENDDO
                    !        write(*,*)'inside neural HERE5'
                    !
                             maxgl = 0.
                             DO i = 1 , Nonods
                    ! TOTNOD is the total number of cause and fine grid nodes.
                    !
                                DO inits = 1 , NINITS
                                   rsum = 0.
                                      DO sub = 1 , Onsubd
                                         nodsub = (sub-1)*Nonods + i
                                         ttvv = 0.
                                         if( Havwnod.EQ.2 ) THEN
                                            DO count = Fina(i) , Fina(i+1) - 1
                                               j=Cola(count)
                                               colaco = j + (sub-1)*Nonods
                                               ttvv = ttvv + 0.5*(wwnod(i)+wwnod(j))*V(colaco)
                                            ENDDO
                                            colaco = i + (sub-1)*Nonods
                    !                        ttvv = ttvv - wwnod(i)*V(colaco) ! dont include the diagonal
                                         else if ( Havmat.EQ.1 ) THEN
                                            DO count = Fina(i) , Fina(i+1) - 1
                                               colaco = Cola(count) + (sub-1)*Nonods
                                               ttvv = ttvv + A(count)*V(colaco)
                    !               print *,'i,a(count),V(colaco):',i, a(count),V(colaco)
                                            ENDDO
                                         else
                                            DO count = Fina(i) , Fina(i+1) - 1
                                               colaco = Cola(count) + (sub-1)*Nonods
                                               ttvv = ttvv + V(colaco)
                                            ENDDO
                                            colaco = i + (sub-1)*Nonods
                    !                       ttvv = ttvv - V(colaco) ! dont include the diagonal
                                         endif
                    !
                    ! C is the source from the surrounding other layers
                    ! in multi-grid approach.
                    ! B is the source for each neuron.
                                         f = -ttvv + alpha*wwnod(i)*sumv(sub) + B(nodsub)
                    !                     stoexp(sub) = EXP(-f/Tscale(i))
                                         stoexp(sub) = EXP( max(-50.0,  min(50.0, -f/Tscale(i)) )  )
                                         rsum = rsum + stoexp(sub)
                                      ENDDO
                    !
                    ! Update part that attempts to balance the number of nodes.
                                   maxdif = 0.
                                   DO sub = 1 , Onsubd
                                      nodsub = (sub-1)*Nonods + i
                                      sumv(sub) = sumv(sub) - V(nodsub)*wwnod(i)
                                      !if(rsum==0.0) 
                                      !!print *,'rsum=',rsum
                                      r = stoexp(sub)/max(toler_small, rsum) 
                                      maxdif = MAX(maxdif,ABS(r-V(nodsub)))
                                      maxgl = MAX(maxdif,maxgl)
                                      V(nodsub) = r
                                      sumv(sub) = sumv(sub) + V(nodsub)*wwnod(i)
                                   ENDDO
                    !
                                   IF( NINITS.NE.1) THEN
                                      IF ( maxdif.LT.TOLINT ) GOTO 50
                                   END IF
                                ENDDO
                    !         write(*,*)'ichain,ilevel,I,INITS:',ichain,ilevel,I,INITS
                    !
                     50      ENDDO
                    !
                     
                    !         write(*,*)'ichain,maxgl,TOLER,sumv(1),sumv(2):',
                    !     &            ichain,maxgl,TOLER,sumv(1),sumv(2)
                             kk = ichain
                             IF ( maxgl.LT.Toler ) GOTO 100
                    !
                          ENDDO
                    !
                     100  continue! WRITE (*,*) 'NO OF ITERATIONS=' , kk
                          END
                    !*==MULPV.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE MULPV(Nlong,Nshort,Xcount,X,Vec,Fina,Cola,Ncola)
                          IMPLICIT NONE
                    !*--MULPV3074
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , icount
                    !*** End of declarations inserted by SPAG
                          INTEGER Nlong , Nshort , Ncola , cnod , colj
                          INTEGER Fina(Nlong+1) , Cola(Ncola)
                          INTEGER Xcount(Nlong)
                    !         integer COLOR(NLONG)
                          REAL X(Nlong) , Vec(Nshort)
                    ! This subroutine performs X=P*vec multiplication where
                    ! P is the prolongation operator.
                    ! P is not explicitly formed.
                    ! COLOR contains the colouring on the finner grid level.
                    ! XCOUNT(FNOD) contains the number of cause grid
                    ! nodes that fine grid node FNOD takes its value from (IS SURROUNDED BY).
                          DO i = 1 , Nlong
                             X(i) = 0.
                    !           XCOUNT(I)=0
                          ENDDO
                    !
                          cnod = 0
                          DO i = 1 , Nlong
                    !           IF(COLOR(I).EQ.1) THEN
                             IF ( Xcount(i).EQ.1 ) THEN
                                cnod = cnod + 1
                                DO icount = Fina(i) , Fina(i+1) - 1
                                   colj = Cola(icount)
                    !               XCOUNT(COLJ)=XCOUNT(COLJ)+1
                                   X(colj) = X(colj) + Vec(cnod)
                                ENDDO
                             ENDIF
                          ENDDO
                    !
                          DO i = 1 , Nlong
                             X(i) = X(i)/REAL(Xcount(i))
                          ENDDO
                          END
                    !*==MULPTV.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE MULPTV(Nlong,Nshort,Xcount,X,Vec,Fina,Cola,Ncola)
                          IMPLICIT NONE
                    !*--MULPTV3118
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , icount
                          REAL r
                    !*** End of declarations inserted by SPAG
                    ! This subroutine performs X=P^T*vec multiplication where
                    ! P^T is the RESTRICTION operator.
                    ! P is not explicitly formed.
                    ! COLOR contains the colouring on the finner grid level.
                    ! XCOUNT(FNOD) contains the number of cause grid
                    ! nodes that fine grid node FNOD takes its value from (IS SURROUNDED BY).
                          INTEGER Nlong , Nshort , Ncola , cnod , colj
                          INTEGER Fina(Nlong+1) , Cola(Ncola)
                          INTEGER Xcount(Nlong)
                          REAL X(Nshort) , Vec(Nlong)
                    !
                          cnod = 0
                          DO i = 1 , Nlong
                             IF ( Xcount(i).EQ.1 ) THEN
                                cnod = cnod + 1
                                r = 0.
                                DO icount = Fina(i) , Fina(i+1) - 1
                                   colj = Cola(icount)
                                   r = r + Vec(colj)/REAL(Xcount(colj))
                                ENDDO
                                X(cnod) = r
                             ENDIF
                          ENDDO
                          END
                    !*==GETMES.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE GETMES(Cola,Fina,Aa,Nonods,Nodacr,Nodown,Maxna)
                          IMPLICIT NONE
                    !*--GETMES3156
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iacr , jdow , Maxna
                          REAL SCALE
                    !*** End of declarations inserted by SPAG
                          INTEGER Nodacr , Nodown , Nonods
                          PARAMETER (SCALE=1.)
                    !        PARAMETER(ONSUBD=2)
                    !        PARAMETER(NODACR=16,NODOWN=16,NONODS=NODACR*NODOWN)
                          REAL Aa(Maxna) , rp
                    !        REAL XCOR(NONODS),YCOR(NONODS),DSQRT(NONODS)
                          INTEGER Cola(Maxna) , Fina(Nonods+1)
                          INTEGER row , count
                    !        COMMON /MIDPA/ MIDPA,COLA,FINA,AA
                    !        COMMON /XYCOR/ XCOR,YCOR,MXX,MXY
                          row = 0
                          count = 0
                    !        MXX=REAL(NODACR-1)
                    !        MXY=REAL(NODOWN-1)
                          DO i = 1 , Maxna
                             Aa(i) = 0.
                          ENDDO
                    !
                    !
                          DO jdow = 1 , Nodown
                             DO iacr = 1 , Nodacr
                                row = row + 1
                    !
                    !            XCOR(ROW)=REAL(IACR)-1.
                    !            YCOR(ROW)=REAL(JDOW)-1.
                    !
                                Fina(row) = count + 1
                                rp = 0
                    !
                                IF ( jdow.NE.1 ) THEN
                                   count = count + 1
                                   Cola(count) = row - Nodacr
                                   Aa(count) = -SCALE
                                   rp = rp + 1.
                                ENDIF
                    !
                                IF ( iacr.NE.1 ) THEN
                                   count = count + 1
                                   Cola(count) = row - 1
                                   Aa(count) = -SCALE
                                   rp = rp + 1.
                                ENDIF
                    !
                                count = count + 1
                                Cola(count) = row
                    !                MIDPA(ROW)=COUNT
                    !
                                IF ( iacr.NE.Nodacr ) THEN
                                   count = count + 1
                                   Cola(count) = row + 1
                                   Aa(count) = -SCALE
                                   rp = rp + 1.
                                ENDIF
                    !
                                IF ( jdow.NE.Nodown ) THEN
                                   count = count + 1
                                   Cola(count) = row + Nodacr
                                   Aa(count) = -SCALE
                                   rp = rp + 1.
                                ENDIF
                    !
                    !                AA(MIDPA(ROW))=SP*RP
                    !
                             ENDDO
                          ENDDO
                          Fina(Nonods+1) = count + 1
                    ! apply boundary condition.
                    !            AA(FINA(1))=INFINY
                          DO count = 1 , Fina(Nonods+1) - 1
                             Aa(count) = -Aa(count)
                          ENDDO
                    !
                    !         DO 35 I=1,NONODS
                    !           XCOR(I)=XCOR(I)/MXX
                    !           YCOR(I)=YCOR(I)/MXY
                    !35       CONTINUE
                    !          MXX=1.
                    !          MXY=1.
                          END
                    !*==OUTPUT.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                          SUBROUTINE OUTPUT(Whichd,Nodacr,Nodown,Nonods,Totnod,Onsubd,V,    &
                                          & Mored,Fgrid,Cgrid,Nodlev,Nlevel)
                          IMPLICIT NONE
                    !*--OUTPUT3249
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ilevel , ilevel2 , Nlevel
                    !*** End of declarations inserted by SPAG
                          INTEGER Onsubd , Nodacr , Nodown , Nonods , Totnod
                          INTEGER jdow , iacr , Whichd(Totnod) , fnod
                          INTEGER Mored(Totnod) , Cgrid(Totnod) , Fgrid(Totnod)
                          INTEGER Nodlev(Nlevel+1)
                          REAL V(Onsubd*Totnod)
                    !
                          !WRITE (*,*) 'nodacr,nodown,nonods:' , Nodacr , Nodown , Nonods
                          !WRITE (*,*) 'onsubd,totnod' , Onsubd , Totnod
                          !WRITE (*,*) ' '
                          DO jdow = 1 , Nodown
                    !            write(6,'(40(1X,I3))')
                    !            write(6,'(60(0X,I2))')
                    !            write(*,*)
                         !    WRITE (6,'(60(I2))') (Whichd((jdow-1)*Nodacr+iacr),iacr=1,     &
                          !                      & Nodacr)
                          ENDDO
                    !          write(*,*)(V(I),I=1,ONSUBD*TOTNOD)
                    !
                    ! We will put the decomposition in MORED.
                          DO i = 1 , Nonods
                             Mored(i) = Whichd(i)
                          ENDDO
                    !
                    ! !print the other levels
                          DO ilevel = 2 , Nlevel
                             DO i = 1 , Nonods
                                Mored(i) = 0
                             ENDDO
                             DO i = Nodlev(ilevel) , Nodlev(ilevel+1) - 1
                                fnod = Fgrid(i)
                                DO ilevel2 = 3 , ilevel
                                   fnod = Fgrid(fnod)
                                ENDDO
                    ! FNOD is the finest grid node.
                                Mored(fnod) = Whichd(i)
                             ENDDO
                    !
                          !   WRITE (*,*) 'PARTITION FOR LEVEL:' , ilevel
                             DO jdow = 1 , Nodown
                           !     WRITE (6,'(40(1X,I2))') (Mored((jdow-1)*Nodacr+iacr),iacr=1,&
                            !                          & Nodacr)
                             ENDDO
                          ENDDO
                          END
                    !*==RAN1.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    !
                    !
                    !      idum = 1
                    !      do 10 i = 1, 30
                    !        z = ran1(idum)
                    !10    write(*,*) idum, z, z*1000000
                    !      end
                    !
                    !
                          FUNCTION RAN1(Idum)
                          IMPLICIT NONE
                    !*--RAN13313
                    !*** Start of declarations inserted by SPAG
                          INTEGER IA1 , IA2 , IA3 , IC1 , IC2 , IC3 , Idum , iff , ix1 ,    &
                                & ix2 , ix3 , j , M1 , M2 , M3
                          REAL r , RAN1 , RM1 , RM2
                    !*** End of declarations inserted by SPAG
                          DIMENSION r(97)
                          PARAMETER (M1=259200,IA1=7141,IC1=54773,RM1=3.8580247E-6)
                          PARAMETER (M2=134456,IA2=8121,IC2=28411,RM2=7.4373773E-6)
                          PARAMETER (M3=243000,IA3=4561,IC3=51349)
                          logical new_ran
                          parameter(new_ran=.true.)
                          DATA iff/0/
                          real rh1
                    
                          if(new_ran) then
                             call random_number(rh1)
                             ran1=rh1
                    !        !print *,'ran1:',ran1
                             return
                          endif
                    
                          IF ( Idum.LT.0 .OR. iff.EQ.0 ) THEN
                             iff = 1
                             ix1 = MOD(IC1-Idum,M1)
                             ix1 = MOD(IA1*ix1+IC1,M1)
                             ix2 = MOD(ix1,M2)
                             ix1 = MOD(IA1*ix1+IC1,M1)
                             ix3 = MOD(ix1,M3)
                             DO j = 1 , 97
                                ix1 = MOD(IA1*ix1+IC1,M1)
                                ix2 = MOD(IA2*ix2+IC2,M2)
                                r(j) = (FLOAT(ix1)+FLOAT(ix2)*RM2)*RM1
                             ENDDO
                             Idum = 1
                          ENDIF
                          ix1 = MOD(IA1*ix1+IC1,M1)
                          ix2 = MOD(IA2*ix2+IC2,M2)
                          ix3 = MOD(IA3*ix3+IC3,M3)
                          j = 1 + (97*ix3)/M3
                    !      IF ( j.GT.97 .OR. j.LT.1 ) PAUSE
                          IF ( j.GT.97 .OR. j.LT.1 ) then
                             !print *,'j,idum=',j,idum
                             STOP 27
                          endif
                          RAN1 = r(j)
                          r(j) = (FLOAT(ix1)+FLOAT(ix2)*RM2)*RM1
                          END
                    !*==REORG2.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                    ! **********************************************************
                    ! **** THIS PART RE-ORDERS THE EQUATIONS *******************
                    ! **********************************************************
                    !
                    !
                    ! For the subdomain to proc mapping.......
                          SUBROUTINE REORG2(Fina,Cola,Ncola,Nonods,Ndom,Whichd,Renum,Finsub,&
                                          & Colsub,Mxcols,Q,Blank,Blasub,Maxnq,Defaul,      &
                                          & Hypdim,Topcon,Sidcon,Proacr,Prodow,Imem,Nimem)
                          IMPLICIT NONE
                    !*--REORG23361
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iedist , iiqn , imem2 , insub , Nimem , nimem2 ,      &
                                & nintnd
                    !*** End of declarations inserted by SPAG
                    !
                          INTEGER Maxnq , Ndom , Nonods , Ncola , Mxcols
                          INTEGER Fina(Nonods+1) , Cola(Ncola)
                          INTEGER Whichd(Nonods) , Renum(Nonods)
                          INTEGER Colsub(Mxcols) , Finsub(Ndom+1)
                    ! If DEFAUL then map using rordering routine.
                    ! COLSUB contains the subdomain to subdomain communication matrix.
                    ! MXCOLS= maximum value of NCOLSU
                          INTEGER Q(Maxnq) , Blank(Nonods) , Blasub(Ndom)
                    !
                          INTEGER sub , sub2 , ncolsu , newsub , stasub
                          INTEGER count , count2
                          LOGICAL found , zero
                    ! For the subdomain to proc mapping.......
                          LOGICAL Defaul , Topcon , Sidcon
                          INTEGER Hypdim , Proacr , Prodow , Imem(Nimem)
                    ! This sub reorders the equations for entire global system of
                    ! equations.
                    ! RENUM(OLDNOD no)=new nod no.
                     
                          IF ( Ndom.LE.1 ) THEN
                    ! for entire system.
                             zero = .TRUE.
                             DO i = 1 , Nonods
                                Blank(i) = 1
                             ENDDO
                             iiqn = MAX(500,Nonods/2)
                             CALL REORD2(Blank,Fina,Cola,Nonods,Ncola,Renum,Q(500),         &
                                       & Q(Nonods/2+501),iiqn,zero)
                          ENDIF
                    !
                          IF ( Ndom.GT.1 ) THEN
                    ! REORDER THE SUBDOMAINS ****************
                             nintnd = 0
                             IF ( nintnd.EQ.0 ) THEN
                    ! This is for BFBGS
                    ! find pointer for subdomains, then reorder subdomains.
                                count2 = 0
                                DO sub = 1 , Ndom
                                   Blasub(sub) = 1
                                   Finsub(sub) = count2 + 1
                                   DO i = 1 , Nonods
                    ! IX will be BLANK   IX(I)=0
                                      Blank(i) = 0
                                      IF ( Whichd(i).EQ.sub ) Blank(i) = 1
                                   ENDDO
                                   DO i = 1 , Nonods
                    ! IL will be Q                 IL(I)=0
                                      Q(i) = 0
                                      DO count = Fina(i) , Fina(i+1) - 1
                                         Q(i) = Q(i) + Blank(Cola(count))
                                      ENDDO
                                   ENDDO
                    ! see which subdomains to connect it with.
                                   DO i = 1 , Nonods
                                      IF ( Q(i).GE.1 ) THEN
                                         sub2 = Whichd(i)
                    ! Look to see if we have sub2 connected to subdomain SUB already.
                                         found = .FALSE.
                                         DO count = Finsub(sub) , count2
                                            IF ( Colsub(count).EQ.sub2 ) found = .TRUE.
                                         ENDDO
                    ! Put into pointers?
                                         IF ( .NOT.found ) THEN
                                            count2 = count2 + 1
                                            Colsub(count2) = sub2
                                         ENDIF
                                      ENDIF
                                   ENDDO
                                ENDDO
                                Finsub(Ndom+1) = count2 + 1
                                ncolsu = count2
                    !             CALL SAVSUB(NDOM,NCOLSU,FINSUB,COLSUB)
                    ! Re-order subdomains.
                    ! RESUB(OLDSUB)=NEWSUB
                                IF ( Defaul ) THEN
                                   zero = .TRUE.
                                   iiqn = MAX(500,Nonods/2)
                    !     &      Q,Q(NONODS/2 +1),IIQN,ZERO)
                                   CALL REORD2(Blasub,Finsub,Colsub,Ndom,ncolsu,Renum,Q(500)&
                                             & ,Q(Nonods/2+501),iiqn,zero)
                                ELSE
                                   imem2 = Ndom*Ndom + 1
                                   iedist = 1
                                   nimem2 = Nimem - imem2 + 1
                                   CALL MAPROC(Hypdim,Topcon,Sidcon,Proacr,Prodow,          &
                                             & Imem(imem2),nimem2,Finsub,Colsub,Imem(iedist)&
                                             & ,Ndom,Ndom,ncolsu,Blasub,Renum)
                    !     &                 NCOLDO,WICNOD,WICPRO)
                                ENDIF
                                DO i = 1 , Nonods
                                   newsub = Renum(Whichd(i))
                                   Whichd(i) = newsub
                                ENDDO
                             ENDIF
                    ! FINISHED REORDERING SUBDOMAINS ********
                    ! ***************************************
                    !
                    ! reorder equations within each subdomain.
                             zero = .TRUE.
                             insub = 0
                             DO sub = 1 , Ndom
                                stasub = insub
                                DO i = 1 , Nonods
                                   Blank(i) = 0
                                   IF ( Whichd(i).EQ.sub ) THEN
                                      Blank(i) = 1
                                      insub = insub + 1
                                   ENDIF
                                ENDDO
                                iiqn = MAX(500,Nonods/2)
                                CALL REORD2(Blank,Fina,Cola,Nonods,Ncola,Renum,Q(500),      &
                                          & Q(Nonods/2+501),iiqn,zero)
                                zero = .FALSE.
                             ENDDO
                    !
                             IF ( nintnd.GT.1 ) THEN
                    ! now reorder interface nodes.
                                insub = 0
                                DO sub = -Ndom , -1 , 1
                                   stasub = insub
                                   found = .FALSE.
                                   DO i = 1 , Nonods
                                      Blank(i) = 0
                                      IF ( Whichd(i).EQ.sub ) THEN
                                         Blank(i) = 1
                                         insub = insub + 1
                                         found = .TRUE.
                                      ENDIF
                                   ENDDO
                                   IF ( found ) THEN
                                      iiqn = MAX(500,Nonods/2)
                                      CALL REORD2(Blank,Fina,Cola,Nonods,Ncola,Renum,Q(500),&
                                                & Q(Nonods/2+501),iiqn,zero)
                                   ENDIF
                                   zero = .FALSE.
                                ENDDO
                             ENDIF
                          ENDIF
                          END
                    !*==SAVSUB.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                          SUBROUTINE SAVSUB(Ndom,Ncolsu,Finsub,Colsub)
                          IMPLICIT NONE
                    !*--SAVSUB3510
                    !*** Start of declarations inserted by SPAG
                          INTEGER i
                    !*** End of declarations inserted by SPAG
                          INTEGER Ndom , Ncolsu
                          INTEGER Finsub(Ndom+1) , Colsub(Ncolsu)
                     
                         ! OPEN (2,FILE='rubish',STATUS='UNKNOWN')
                          !WRITE (2,*) Ndom
                          !WRITE (2,*) Ncolsu
                          !WRITE (2,*) (Finsub(i),i=1,Ndom+1)
                          !WRITE (2,*) (Colsub(i),i=1,Ncolsu)
                         ! CLOSE (2)
                          END
                    !*==REORD2.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE REORD2(Blank,Fina,Cola,Nonods,Ncola,Renum2,Q,Qtemp,    &
                                          & Iiqn,Zero)
                          IMPLICIT NONE
                    !*--REORD23532
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iav , icol , ifront , ii , iii , Iiqn , imxbwd ,      &
                                & ival , j , nod , nodq , nq , nqtemp
                    !*** End of declarations inserted by SPAG
                    ! This subroutine mimimizes the bandwidth for a direct solution
                    ! and maximizes the connectivity for an iterative solution.
                    ! IT works by forming fronts, the nodes contained in which
                    ! are renumbered.
                    ! The nodes with the minimum mean of the surrounding
                    ! numbered nodes, the front nods can be taken as
                    ! negative or egnored.
                    ! RENUM2(OLDNOD no)=new nod no.
                    ! It will begin renumbering from the maximum entry in RENUM2.
                          LOGICAL QUICK
                          PARAMETER (QUICK=.TRUE.)
                    !
                          INTEGER Nonods , Ncola
                          INTEGER Q(Iiqn) , Qtemp(Iiqn)
                          INTEGER Blank(Nonods) , Fina(Nonods+1)
                          INTEGER Cola(Ncola)
                          INTEGER Renum2(Nonods)
                    !
                          REAL minodn , mean , froval
                          INTEGER mxval , nval , mxnod , mxrenu
                          INTEGER minval , minnod
                          INTEGER nodgot , count , row
                    ! Q,QTEMP contains the work spase.
                          INTEGER LARGE
                          PARAMETER (LARGE=10000000)
                          LOGICAL found , Zero
                    ! This sub reorders the equations so an iterative OR DIRECT solver
                    ! can solve the equations efficiently.
                    ! When BLANK(I)=0 node I is egnored (or renumbered).
                    ! When BLANK(I)=1 node I is not egnored(or renumbered).
                    ! if ZERO then
                          IF ( Zero ) THEN
                             DO i = 1 , Nonods
                                Renum2(i) = 0
                             ENDDO
                          ENDIF
                    !
                    ! Find MXRENU = max node number in RENUM2
                     100  mxrenu = 0
                          DO i = 1 , Nonods
                             mxrenu = MAX(Renum2(i),mxrenu)
                          ENDDO
                    !
                          nod = mxrenu + 1
                    !
                          minval = LARGE
                          DO i = 1 , Nonods
                             IF ( Blank(i).NE.0 ) THEN
                                IF ( Renum2(i).EQ.0 ) THEN
                                   nval = 0
                                   DO count = Fina(i) , Fina(i+1) - 1
                                      icol = Cola(count)
                                      IF ( Blank(icol).NE.0 ) THEN
                                         IF ( Renum2(icol).EQ.0 ) nval = nval + 1
                                      ENDIF
                                   ENDDO
                                   IF ( nval.LT.minval ) THEN
                                      minval = nval
                                      minnod = i
                                   ENDIF
                                ENDIF
                             ENDIF
                          ENDDO
                    !
                    !         RENUM(NOD)=MXNOD
                          Renum2(minnod) = nod
                    !
                     
                          nq = 1
                          Q(1) = minnod
                          DO ifront = 1 , 100000
                    ! Find another front Q.
                    ! find all the nodes(put in Q) that QTEMP is
                    ! connected to that are not numbered.
                    ! and not already in Q.
                             DO i = 1 , nq
                                Qtemp(i) = Q(i)
                             ENDDO
                             nqtemp = nq
                             nq = 0
                             DO i = 1 , nqtemp
                                row = Qtemp(i)
                                DO count = Fina(row) , Fina(row+1) - 1
                                   icol = Cola(count)
                    ! see if already in Q.
                                   IF ( Blank(icol).NE.0 ) THEN
                                      IF ( Renum2(icol).EQ.0 ) THEN
                                         found = .FALSE.
                                         DO ii = 1 , nq
                                            IF ( icol.EQ.Q(ii) ) found = .TRUE.
                                         ENDDO
                                         IF ( .NOT.found ) THEN
                                            nq = nq + 1
                                            Q(nq) = icol
                                         ENDIF
                                      ENDIF
                                   ENDIF
                                ENDDO
                             ENDDO
                    ! GIVE NOD NOS TO Q
                             IF ( (ifront.EQ.1) .AND. (nq.GT.2) ) THEN
                    ! Creat a spacial ordering. *************
                    ! Find node in Q with max valancy
                                mxval = -1
                                DO j = 1 , nq
                                   i = Q(j)
                                   IF ( Blank(i).NE.0 ) THEN
                                      IF ( Renum2(i).EQ.0 ) THEN
                                         nval = 0
                                         DO count = Fina(i) , Fina(i+1) - 1
                                            icol = Cola(count)
                                            IF ( Blank(icol).NE.0 ) THEN
                                               IF ( Renum2(icol).EQ.0 ) nval = nval + 1
                                            ENDIF
                                         ENDDO
                                         IF ( nval.GT.mxval ) THEN
                                            mxval = nval
                                            mxnod = i
                                         ENDIF
                                      ENDIF
                                   ENDIF
                                ENDDO
                    !
                                iav = INT(REAL(nq)/2.+0.6)
                    ! Put to -1 for loops 910,920.
                                Renum2(mxnod) = -1
                                iii = 0
                                DO i = 1 , nq
                                   IF ( iii.LT.iav-1 ) THEN
                                      IF ( Renum2(Q(i)).EQ.0 ) THEN
                                         iii = iii + 1
                                         nod = nod + 1
                                         Renum2(Q(i)) = -nod
                                      ENDIF
                                   ENDIF
                                ENDDO
                                nod = nod + 1
                                Renum2(mxnod) = -nod
                                DO i = 1 , nq
                                   IF ( Renum2(Q(i)).EQ.0 ) THEN
                                      nod = nod + 1
                                      Renum2(Q(i)) = -nod
                                   ENDIF
                                ENDDO
                    ! ***************************************
                             ELSE
                                DO j = 1 , nq
                                   IF ( .NOT.QUICK ) THEN
                                      minodn = LARGE
                                      DO i = 1 , nq
                    ! find node not NUMBERED connected to the minimum of the
                    ! MEAN of the surrounding nodes.
                    ! ALSO TAKE INTO ACCOUNT THE VALANCY.
                                         nodq = Q(i)
                                         IF ( Blank(nodq).NE.0 ) THEN
                                            IF ( Renum2(nodq).EQ.0 ) THEN
                                               ival = 0
                                               mean = 0.
                                               froval = 0.
                                               DO count = Fina(nodq) , Fina(nodq+1) - 1
                                                  icol = Cola(count)
                                                  IF ( Blank(icol).EQ.1 ) THEN
                    !                     IF(RENUM2(ICOL).NE.0) THEN
                                                     IF ( Renum2(icol).GT.0 ) THEN
                                                        ival = ival + 1
                                                        mean = mean + Renum2(icol)
                    ! Front nodes count as a zero.
                                                     ENDIF
                                                     IF ( Renum2(icol).LT.0 )               &
                                                        & froval = froval + 1.
                                                  ENDIF
                                               ENDDO
                                               IF ( ival.NE.0 ) THEN
                                                  mean = mean/REAL(ival) - 0.01*froval
                                                  IF ( mean.LT.minodn ) THEN
                                                     minodn = mean
                                                     nodgot = nodq
                                                  ENDIF
                                               ENDIF
                                            ENDIF
                                         ENDIF
                                      ENDDO
                                   ELSE
                                      nodgot = Q(j)
                                   ENDIF
                    !
                                   nod = nod + 1
                                   Renum2(nodgot) = -nod
                                ENDDO
                    !
                             ENDIF
                    !
                             DO i = 1 , nq
                                Renum2(Q(i)) = -Renum2(Q(i))
                             ENDDO
                             IF ( nq.EQ.0 ) THEN
                    ! See if we have numbered all the nodes, if not
                    ! then goto 9770 else goto 9700
                                found = .FALSE.
                                DO i = 1 , Nonods
                                   IF ( Blank(i).EQ.1 ) THEN
                                      IF ( Renum2(i).EQ.0 ) found = .TRUE.
                                   ENDIF
                                ENDDO
                                IF ( found ) GOTO 100
                                IF ( .NOT.found ) GOTO 200
                             ENDIF
                          ENDDO
                    !
                    ! find maximum bandwidth.
                     200  imxbwd = 0
                          DO i = 1 , Nonods
                             IF ( Blank(i).NE.0 ) THEN
                                ii = Renum2(i)
                                DO count = Fina(i) , Fina(i+1) - 1
                                   icol = Cola(count)
                                   IF ( Blank(icol).NE.0 )                                  &
                                      & imxbwd = MAX(imxbwd,ABS(ii-Renum2(icol)))
                                ENDDO
                             ENDIF
                          ENDDO
                     
                          END
                    !*==READOM.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                     
                    !
                    !
                    ! **********************************************************
                    ! **** THIS PART MAPS THE SUBDOMAINS TO PROCESSORS *********
                    ! **********************************************************
                    !
                    !
                    !
                          SUBROUTINE READOM(Ndom,Ncolsu,Finsub,Colsub)
                          IMPLICIT NONE
                    !*--READOM3772
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iincol , indom
                    !*** End of declarations inserted by SPAG
                          INTEGER Ndom , Ncolsu
                          INTEGER Finsub(Ndom+1) , Colsub(Ncolsu)
                     
                        !  OPEN (2,FILE='rubish',STATUS='UNKNOWN')
                     !     READ (2,*) indom
                    !      IF ( indom.NE.Ndom ) THEN
                      !       WRITE (*,*) 'THERE IS AN ERROR'
                             STOP
                    !      ENDIF
                       !   READ (2,*) iincol
                        !  READ (2,*) (Finsub(i),i=1,indom+1)
                         ! READ (2,*) (Colsub(i),i=1,iincol)
                        !  CLOSE (2)
                         ! WRITE (*,*) 'no of edges of domain to domain connectivity=' ,     &
                         !           & iincol/2
                          END
                    !*==MAPROC.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE MAPROC(Hypdim,Topcon,Sidcon,Proacr,Prodow,Imem,Nimem,  &
                                          & Findom,Coldom,Edist,Ndom,Nprocs,Ncoldo,Wicnod,  &
                                          & Wicpro)
                          IMPLICIT NONE
                    !*--MAPROC3801
                    !*** Start of declarations inserted by SPAG
                          INTEGER Ncoldo , Ndom , Nimem , Nprocs
                    !*** End of declarations inserted by SPAG
                    ! This sub finds the PROCESSOR TO SUBDOMAIN MAPPING.
                    ! NB nonods=nprocs.
                    ! If HYPDIM=0 assume not a hypercube but a net.
                    ! TOPCON & SIDCON are for the net.
                    ! PROACR,PRODOW are the dimensions of the net.
                    ! If TOPCON then the top row of nodes are connected to the bottom.
                    ! If SIDCON then the r.h.s column of nodes are connected to the l.h.s
                    ! IF(hypdim.gt.0) NCOLA=no of edges of hypercube * 2. = nprocs*log(base 2)(nprocs).
                    ! log(base 2)(nprocs)=HYPDIM.
                    ! WICPRO(SUBDOM NO)=PROCESSOR NUMBER
                    ! WICNOD(PROC NO)=SUBDOMAIN NUMBER.
                          INTEGER Hypdim , Proacr , Prodow
                          LOGICAL Topcon , Sidcon
                          INTEGER Findom(Ndom+1) , Coldom(Ncoldo)
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER Imem(Nimem)
                          INTEGER Wicnod(Nprocs) , Wicpro(Ndom)
                    ! Define the processor connectivity, put in EDIST matrix.
                          CALL GLBPRO(Hypdim,Topcon,Sidcon,Proacr,Prodow,Nprocs,Edist,Imem, &
                                    & Nimem)
                    !
                          IF ( Nimem.LT.Ndom*Ndom ) THEN
                          !   WRITE (*,*) 'NOT ENOUGH MEM IN MAPROC'
                             STOP
                          ENDIF
                    ! solve mapping problem.
                          CALL MAPPRO(Imem,Findom,Coldom,Edist,Ndom,Nprocs,Ncoldo,Wicnod,   &
                                    & Wicpro)
                     
                          END
                    !*==GLBPRO.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE GLBPRO(Hypdim,Topcon,Sidcon,Proacr,Prodow,Nprocs,      &
                                          & Fulmat,Imem,Nimem)
                          IMPLICIT NONE
                    !*--GLBPRO3843
                    !*** Start of declarations inserted by SPAG
                          INTEGER need , Nimem , nz
                    !*** End of declarations inserted by SPAG
                    ! This sub finds the global inter processor communication matrix.
                    ! NB nonods=nprocs.
                    ! If HYPDIM=0 assume not a hypercube but a net.
                    ! TOPCON & SIDCON are for the net.
                    ! PROACR,PRODOW are the dimensions of the net.
                    ! If TOPCON then the top row of nodes are connected to the bottom.
                    ! If SIDCON then the r.h.s column of nodes are
                    ! connected to the l.h.s
                          INTEGER Hypdim , Proacr , Prodow , Nprocs
                          INTEGER Fulmat(Nprocs*Nprocs) , Imem(Nimem)
                    ! NIMEM=MAX(NPROCS*HYPDIM,4*NPROCS)*2 +(NPROCS+1)*2
                          INTEGER ncola , fina , cola , fina2 , cola2 , front , lfront
                          LOGICAL Topcon , Sidcon
                    !
                    ! IF(hypdim.gt.0) NCOLA=no of edges of hypercube * 2. = nprocs*log(base 2)(nprocs).
                    ! log(base 2)(nprocs)=HYPDIM.
                    !           !WRITE(*,*)'inside glbpro'
                          ncola = MAX(Nprocs*Hypdim,4*Nprocs)
                          IF ( Hypdim.GT.0 ) ncola = Nprocs*Hypdim
                    ! ALlocate space
                          fina = 1
                          cola = fina + Nprocs + 1
                          fina2 = cola + ncola
                          cola2 = fina2 + Nprocs + 1
                          need = fina2 + Nprocs + ncola
                          IF ( need.GT.Nimem ) THEN
                             !WRITE (*,*) 'NOT ENOUGH MEMORY STOPED IN GLBPRO'
                             STOP
                          ENDIF
                    !
                          IF ( Hypdim.GT.0 ) THEN
                             CALL HYPPTR(Hypdim,Nprocs,Imem(fina),Imem(cola),Imem(fina2),   &
                                       & Imem(cola2),ncola,nz)
                          ELSE
                    !            write(*,*)NCOLA,NPROCS,PRODOW,PROACR,
                    !     &                     TOPCON,SIDCON,fina,cola,nimem
                             CALL DEFDOM(Imem(fina),Imem(cola),ncola,Nprocs,Prodow,Proacr,  &
                                       & Topcon,Sidcon,nz)
                          ENDIF
                    !
                          front = fina2
                          lfront = front + Nprocs
                    !           write(*,*)'befor getful'
                          CALL GETFUL(Fulmat,Imem(fina),Imem(cola),Nprocs,ncola,Imem(front),&
                                    & Imem(lfront),Nprocs)
                    !           write(*,*)'after getful'
                          END
                    !*==GETFUL.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE GETFUL(Fulmat,Fina,Cola,Nonods,Ncola,Front,Lfront,     &
                                          & Mxnfro)
                          IMPLICIT NONE
                    !*--GETFUL3902
                    !*** Start of declarations inserted by SPAG
                          INTEGER ifr , inod , j , jnod , Ncola , nod , Nonods
                    !*** End of declarations inserted by SPAG
                          INTEGER MXNFRT
                          PARAMETER (MXNFRT=100000)
                          INTEGER Mxnfro
                          INTEGER count , Front(Mxnfro) , Lfront(Mxnfro)
                          INTEGER nfront , lnfron , idist
                          INTEGER Fina(Nonods+1) , Cola(Ncola)
                          INTEGER Fulmat(Nonods*Nonods)
                    ! MXNFRO=max number of nodes in a front, it can not exceed the
                    ! maximum distance between two nodes.
                    ! MXNFRT=max number of fronts.
                    ! This sub finds a full matrix from the matrix in FINA,COLA.
                    ! It works using fronts.  It assums that a node does not point to its self.
                          DO inod = 1 , Nonods
                    ! Work out the INOD'th row of the dense matrix.
                             DO j = 1 , Nonods
                                Fulmat((inod-1)*Nonods+j) = 0
                             ENDDO
                             Fulmat((inod-1)*Nonods+inod) = -1
                    ! Initialize front
                             nfront = 1
                             Front(nfront) = inod
                    !
                             DO idist = 1 , MXNFRT
                                lnfron = nfront
                                DO ifr = 1 , nfront
                                   Lfront(ifr) = Front(ifr)
                                ENDDO
                    !
                                nfront = 0
                                DO ifr = 1 , lnfron
                    ! LFRONT contains the previous front.
                                   jnod = Lfront(ifr)
                                   DO count = Fina(jnod) , Fina(jnod+1) - 1
                                      nod = Cola(count)
                                      IF ( Fulmat((inod-1)*Nonods+nod).EQ.0 ) THEN
                                         nfront = nfront + 1
                                         Front(nfront) = nod
                                         Fulmat((inod-1)*Nonods+nod) = idist
                                      ENDIF
                                   ENDDO
                                ENDDO
                                IF ( nfront.EQ.0 ) GOTO 50
                             ENDDO
                    !
                     50      Fulmat((inod-1)*Nonods+inod) = 0
                          ENDDO
                    !
                    !         write(*,*)'FULMAT:'
                    !         DO 19 JNOD=1,NONODS
                    !           jnod=1
                    !          do 19 i=1,9
                    !           write(*,*)(FULMAT((JNOD-1)*NONODS+ (i-1)*9+j),j=1,9)
                    !19       CONTINUE
                    !         STOP
                          END
                    !*==DEFDOM.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE DEFDOM(Findom,Coldom,Ncoldo,Nonods,Nodown,Nodacr,      &
                                          & Topcon,Sidcon,Nz)
                          IMPLICIT NONE
                    !*--DEFDOM3968
                    !*** Start of declarations inserted by SPAG
                          INTEGER iacr , jdow , Ncoldo , Nodacr , Nodown , Nonods , Nz
                    !*** End of declarations inserted by SPAG
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo) , row , count
                          LOGICAL Topcon , Sidcon
                    ! This subroutine finds the pointers for cray T3D or domain connectivity.
                    ! If TOPCON then the top row of nodes are connected to the bottom.
                    ! If SIDCON then the r.h.s column of nodes are connected to the l.h.s
                    ! column of nodes.
                    !
                    !         write(*,*)'inside defdom'
                    !         write(*,*)'NCOLDO,NONODS,NODOWN,NODACR,TOPCON,SIDCON:'
                    !         write(*,*)NCOLDO,NONODS,NODOWN,NODACR,TOPCON,SIDCON
                          count = 0
                          row = 0
                          DO jdow = 1 , Nodown
                             DO iacr = 1 , Nodacr
                                row = row + 1
                                Findom(row) = count + 1
                    !
                                IF ( jdow.NE.1 ) THEN
                                   count = count + 1
                                   Coldom(count) = row - Nodacr
                                ENDIF
                                IF ( (jdow.EQ.1) .AND. Topcon ) THEN
                                   count = count + 1
                                   Coldom(count) = Nonods - Nodacr + iacr
                                ENDIF
                    !
                                IF ( iacr.NE.1 ) THEN
                                   count = count + 1
                                   Coldom(count) = row - 1
                                ENDIF
                                IF ( (iacr.EQ.1) .AND. Sidcon ) THEN
                                   count = count + 1
                                   Coldom(count) = row + Nodacr - 1
                                ENDIF
                    ! miss out the middle node.
                    !                COUNT=COUNT+1
                    !                COLDOM(COUNT)=ROW
                    !                MIDPA(ROW)=COUNT
                    !
                                IF ( iacr.NE.Nodacr ) THEN
                                   count = count + 1
                                   Coldom(count) = row + 1
                                ENDIF
                                IF ( (iacr.EQ.Nodacr) .AND. Sidcon ) THEN
                                   count = count + 1
                                   Coldom(count) = row - Nodacr + 1
                                ENDIF
                    !
                                IF ( jdow.NE.Nodown ) THEN
                                   count = count + 1
                                   Coldom(count) = row + Nodacr
                                ENDIF
                                IF ( (jdow.EQ.Nodown) .AND. Topcon ) THEN
                                   count = count + 1
                                   Coldom(count) = row - (Nonods-Nodacr)
                                ENDIF
                    !
                             ENDDO
                          ENDDO
                          Findom(Nonods+1) = count + 1
                          Nz = count
                    !         write(*,*)'going out of defdom'
                          END
                    !*==DEFPRO.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE DEFPRO(Edist,Nprocs,Nacr,Ndow)
                          IMPLICIT NONE
                    !*--DEFPRO4041
                    !*** Start of declarations inserted by SPAG
                          INTEGER ii , ij , iproc , ji , jj , jproc , Nacr , Ndow , Nprocs
                    !*** End of declarations inserted by SPAG
                          INTEGER Edist(Nprocs*Nprocs)
                          DO ji = 1 , Ndow
                             DO ii = 1 , Nacr
                                iproc = (ji-1)*Nacr + ii
                                DO jj = 1 , Ndow
                                   DO ij = 1 , Nacr
                                      jproc = (jj-1)*Nacr + ij
                                      Edist((iproc-1)*Nprocs+jproc) = ABS(ji-jj)            &
                                       & + ABS(ii-ij)
                                   ENDDO
                                ENDDO
                             ENDDO
                          ENDDO
                          END
                    !*==HYPPTR.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE HYPPTR(Hypdim,Nprocs,Finpro,Colpro,Finloc,Colloc,      &
                                          & Ncolpr,Nz)
                          IMPLICIT NONE
                    !*--HYPPTR4066
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ilev , Ncolpr , nploc , npro , Nprocs , Nz
                    !*** End of declarations inserted by SPAG
                          INTEGER count , Hypdim
                          INTEGER Finpro(Nprocs+1) , Colpro(Ncolpr)
                          INTEGER Finloc(Nprocs+1) , Colloc(Ncolpr)
                    ! This sub finds the pointers for the HYPERCUBE
                    ! HYPDIM=dimensions of the hypercube NB NPROCS=2^HYPDIM.
                    ! The connectivity is contained in the pointers FINPRO,COLPRO,NZ
                    ! NZ=length of COLPRO.
                    !          write(*,*)'inside hypptr'
                          npro = 2
                          Finpro(1) = 1
                          Finpro(2) = 2
                          Finpro(3) = 3
                          Colpro(1) = 2
                          Colpro(2) = 1
                          Ncolpr = 2
                    !
                          DO ilev = 2 , Hypdim
                             nploc = npro
                             DO i = 1 , npro
                                Finloc(i) = Finpro(i)
                                DO count = Finpro(i) , Finpro(i+1) - 1
                                   Colloc(count) = Colpro(count)
                                ENDDO
                             ENDDO
                             Finloc(npro+1) = Finpro(npro+1)
                     
                             npro = 2*nploc
                             CALL NEXTLE(Finpro,Colpro,Ncolpr,npro,Finloc,Colloc,Ncolpr,    &
                                       & nploc,Nz)
                          ENDDO
                    !
                          IF ( npro.NE.Nprocs ) THEN
                             !WRITE (*,*) 'PROBLEM WITH THE HYPERCUBE'
                             STOP
                          ENDIF
                    !          write(*,*)'going out of hypptr'
                    !          stop
                          END
                    !*==NEXTLE.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE NEXTLE(Finpro,Colpro,Ncolpr,Nprocs,Finloc,Colloc,      &
                                          & Ncollo,Nploc,Nz)
                          IMPLICIT NONE
                    !*--NEXTLE4115
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , ii , Ncollo , Ncolpr , Nploc , Nprocs , Nz
                    !*** End of declarations inserted by SPAG
                          INTEGER count , count2
                          INTEGER Finpro(Nprocs+1) , Colpro(Ncolpr)
                          INTEGER Finloc(Nploc+1) , Colloc(Ncollo)
                    ! This sub is called recursively to build up the links on the HYPERCUBE.
                          count2 = 0
                          DO i = 1 , Nploc
                             Finpro(i) = count2 + 1
                             DO count = Finloc(i) , Finloc(i+1) - 1
                                count2 = count2 + 1
                                Colpro(count2) = Colloc(count)
                             ENDDO
                             count2 = count2 + 1
                             Colpro(count2) = i + Nploc
                          ENDDO
                    !
                          DO ii = 1 , Nploc
                             i = ii + Nploc
                             Finpro(i) = count2 + 1
                    !
                             count2 = count2 + 1
                             Colpro(count2) = ii
                             DO count = Finloc(i) , Finloc(i+1) - 1
                                count2 = count2 + 1
                                Colpro(count2) = Colloc(count) + Nploc
                             ENDDO
                          ENDDO
                          Nz = count2
                          Finpro(Nprocs+1) = count2 + 1
                          END
                    !*==MAPPRO.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE MAPPRO(Ax,Findom,Coldom,Edist,Nonods,Nprocs,Ncoldo,    &
                                          & Wicnod,Wicpro)
                          IMPLICIT NONE
                    !*--MAPPRO4155
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , icurf , its , j , nchain , Ncoldo , nexcp , NOITS ,   &
                                & Nonods , Nprocs
                    !*** End of declarations inserted by SPAG
                          REAL ALPHA , BETA
                          INTEGER CHEND
                    !         PARAMETER(NOITS=10000,ALPHA=0.995,BETA=0.01)
                          PARAMETER (NOITS=10000,ALPHA=0.98,BETA=0.01)
                          PARAMETER (CHEND=5)
                          REAL c , pcost , ncost
                          INTEGER curf , newf , lastf(CHEND) , ikeep(CHEND)
                    !         INTEGER X(NONODS*NPROCS)
                          INTEGER Ax(Nonods*Nprocs)
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo)
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER length , rnod , rproc
                          INTEGER Wicnod(Nprocs) , Wicpro(Nonods)
                          INTEGER proc , chain , mxexce
                          LOGICAL yes , same
                          length = Nonods*Nprocs
                    ! Initialize X & WICNOD,WICPRO
                    !         DO 10 I=1,LENGTH
                    !           X(I)=0
                    !10       CONTINUE
                          DO proc = 1 , Nprocs
                    !           X(PROC+(PROC-1)*NONONDS)=1
                             Wicnod(proc) = proc
                             Wicpro(proc) = proc
                          ENDDO
                    !
                          CALL FINFAX(curf,Ax,Findom,Coldom,Ncoldo,Nonods,Nprocs,Edist,     &
                                    & Wicnod)
                          !WRITE (*,*) 'befor we randomise CURF=' , curf
                    !
                          nchain = 10 + 1*Nonods*Nprocs
                    ! NCHAIN=maximum length of a markolf chain.
                          mxexce = Nonods + INT(BETA*REAL(nchain))
                    !
                    ! This sub finds the initial C.
                          CALL GETC(c,curf,nchain,mxexce,Ax,Findom,Coldom,Edist,Nonods,     &
                                  & Nprocs,Ncoldo,Wicnod,Wicpro)
                          !WRITE (*,*) 'initial curf=' , curf
                          !WRITE (*,*) 'initia C=' , c
                    !
                          DO i = 1 , CHEND
                             lastf(i) = 0
                          ENDDO
                    !
                          DO its = 1 , NOITS
                             nexcp = 0
                             DO chain = 1 , nchain
                    !             write(*,*)'CURF=',CURF
                    ! Generate a nabourhood configuration ** make sure it is different from old one.
                                CALL GENNAB(rproc,rnod,Nprocs,Nonods,Wicnod)
                    ! Find new cost of this nabourhood configuration.
                                CALL FINEWF(newf,curf,rnod,rproc,Wicnod,Wicpro,Nprocs,      &
                                          & Nonods,Edist,Findom,Coldom,Ncoldo,Ax)
                    ! See if we except this config.
                                pcost = curf
                                ncost = newf
                                CALL EXCEPT(ncost,pcost,c,yes)
                                IF ( yes ) THEN
                                   nexcp = nexcp + 1
                    ! Update everything Change X,AX.
                                   CALL UPXAX(rnod,rproc,Wicnod,Wicpro,Nonods,Nprocs,curf,  &
                                            & newf,Ax,Edist,Findom,Coldom,Ncoldo)
                                   IF ( nexcp.GT.mxexce ) GOTO 50
                                ENDIF
                             ENDDO
                     50      continue!    WRITE (*,*) 'ITS,CURF,NEXCP,CHAIN:' , its , curf , nexcp ,     &
                          !             & chain
                    !
                             c = ALPHA*c
                    !
                             IF ( its.GT.30 ) THEN
                    ! Put CURF into LASTF and shift LASTF down.
                                DO i = 1 , CHEND
                                   ikeep(i) = lastf(i)
                                ENDDO
                                lastf(CHEND) = curf
                                DO i = 1 , CHEND - 1
                                   lastf(i) = ikeep(i+1)
                                ENDDO
                    ! See if the SAME
                                same = .TRUE.
                                DO i = 1 , CHEND
                                   DO j = 1 , CHEND
                                      IF ( lastf(i).NE.lastf(j) ) same = .FALSE.
                                   ENDDO
                                ENDDO
                    !
                    ! Check for convergence Ie) see if all the entries in LASTF are the SAME.
                                IF ( same ) GOTO 100
                             ENDIF
                    !
                          ENDDO
                    !
                    ! ********************* OUTPUT THE RESULTS **********************
                    !
                     100  CALL FINFAX(icurf,Ax,Findom,Coldom,Ncoldo,Nonods,Nprocs,Edist,    &
                                    & Wicnod)
                          IF ( icurf.NE.curf ) THEN
                           !  WRITE (*,*) '********* THERE WAS A PROBLEM: ICURF,CURF' ,      &
                            !           & icurf , curf
                             curf = icurf
                          ENDIF
                    !
                          !WRITE (*,*) 'IN THE END CURF=' , curf
                          DO i = 1 , -Nonods
                             !WRITE (*,*) 'NOD, WICPRO(NOD):' , i , Wicpro(i)
                          ENDDO
                          DO i = 1 , -Nprocs
                             !WRITE (*,*) 'PROC, WICNOD(PROC):' , i , Wicnod(i)
                          ENDDO
                          END
                    !*==GETC.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE GETC(C,Curf,Nchain,Mxexce,Ax,Findom,Coldom,Edist,      &
                                        & Nonods,Nprocs,Ncoldo,Wicnod,Wicpro)
                          IMPLICIT NONE
                    !*--GETC4278
                    !*** Start of declarations inserted by SPAG
                          INTEGER Nchain , Ncoldo , ncost , Nonods , Nprocs , ntry
                          REAL pcost , rrlog
                    !*** End of declarations inserted by SPAG
                          REAL C , mean
                          INTEGER Curf , newf
                    !         INTEGER X(NONODS*NPROCS)
                          INTEGER Ax(Nonods*Nprocs)
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo)
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER rnod , rproc
                          INTEGER Wicnod(Nprocs) , Wicpro(Nonods)
                          INTEGER chain , Mxexce , count
                    ! This subroutine finds the initial value of the temperature like parameter C
                    !         NTRY=MXEXCE
                          ntry = Nchain
                          mean = 0.
                          count = 0
                          DO chain = 1 , ntry
                    ! Generate a nabourhood configuration ** make sure it is different from old one.
                             CALL GENNAB(rproc,rnod,Nprocs,Nonods,Wicnod)
                    ! Find new cost of this nabourhood configuration.
                             CALL FINEWF(newf,Curf,rnod,rproc,Wicnod,Wicpro,Nprocs,Nonods,  &
                                       & Edist,Findom,Coldom,Ncoldo,Ax)
                    ! See if we except this config.
                             pcost = Curf
                             ncost = newf
                             IF ( newf.GT.Curf ) THEN
                                mean = mean + REAL(newf-Curf)
                                count = count + 1
                             ENDIF
                    ! Update everything Change X,AX.
                             CALL UPXAX(rnod,rproc,Wicnod,Wicpro,Nonods,Nprocs,Curf,newf,Ax,&
                                      & Edist,Findom,Coldom,Ncoldo)
                          ENDDO
                    !           write(*,*)'got to here'
                          mean = mean/REAL(count)
                          rrlog = LOG(1./0.8)
                          C = mean/rrlog
                    !           write(*,*)'C=',C,' RRLOG=',RRLOG
                    !           STOP
                          END
                    !*==FINFAX.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                     
                    !
                    !
                    !
                          SUBROUTINE FINFAX(Curf,Ax,Findom,Coldom,Ncoldo,Nonods,Nprocs,     &
                                          & Edist,Wicnod)
                          IMPLICIT NONE
                    !*--FINFAX4329
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iproc , jproc , Ncoldo , Nonods , Nprocs
                    !*** End of declarations inserted by SPAG
                          INTEGER Curf , Ax(Nonods*Nprocs)
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo)
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER edis , count , col
                          INTEGER Wicnod(Nprocs)
                    ! This sub finds the functional CURF and the vector AX
                    ! NB FINDOM & COLDOM do not include the middle value.
                          DO i = 1 , Nonods*Nprocs
                             Ax(i) = 0
                          ENDDO
                          DO iproc = 1 , Nprocs
                             DO jproc = 1 , Nprocs
                                edis = Edist((iproc-1)*Nprocs+jproc)
                    !
                                i = Wicnod(jproc)
                                DO count = Findom(i) , Findom(i+1) - 1
                                   col = Coldom(count)
                                   Ax(col+(iproc-1)*Nonods) = Ax(col+(iproc-1)*Nonods)      &
                                    & + edis
                                ENDDO
                    !
                             ENDDO
                          ENDDO
                    !
                    ! Work out CURF
                          Curf = 0
                          DO iproc = 1 , Nprocs
                             i = Wicnod(iproc)
                             Curf = Curf + Ax(i+(iproc-1)*Nonods)
                          ENDDO
                          END
                    !*==GENNAB.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE GENNAB(Rproc,Rnod,Nprocs,Nonods,Wicnod)
                          IMPLICIT NONE
                    !*--GENNAB4370
                    !*** Start of declarations inserted by SPAG
                          INTEGER iarg
                          REAL RAN1
                    !*** End of declarations inserted by SPAG
                          INTEGER Rproc , Rnod , Nprocs , Nonods , Wicnod(Nprocs)
                          INTEGER iran
                          REAL rran
                    !
                     100  iarg = 3
                          rran = RAN1(iarg)
                          IF ( rran.GE.1 ) rran = 0.999999
                          iran = INT(rran*REAL(Nprocs*Nonods)+1.)
                    !
                          Rproc = INT((iran-1)/Nonods) + 1
                          Rnod = iran - (Rproc-1)*Nonods
                          IF ( Wicnod(Rproc).EQ.Rnod ) GOTO 100
                          END
                    !*==FINEWF.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE FINEWF(Newf,Curf,Rnod,Rproc,Wicnod,Wicpro,Nprocs,      &
                                          & Nonods,Edist,Findom,Coldom,Ncoldo,Ax)
                          IMPLICIT NONE
                    !*--FINEWF4395
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , Ncoldo , Nonods , Nprocs
                    !*** End of declarations inserted by SPAG
                    ! Find new cost of this nabourhood configuration.
                    ! WICNOD(PROC) returns the domain or 'nod' that processor proc contains.
                    ! WICPRO(NOD) returns the processor that domain NOD is on.
                          INTEGER Newf , Curf , Rnod , Rproc , Wicnod(Nprocs) ,             &
                                & Wicpro(Nonods) , e1
                          INTEGER count , col , knod , kproc , exf
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo)
                          INTEGER Ax(Nonods*Nprocs)
                          LOGICAL rr , rk , kr , kk
                    !
                          knod = Wicnod(Rproc)
                          kproc = Wicpro(Rnod)
                    !
                          exf = 0
                          exf = exf + Ax(Rnod+(Rproc-1)*Nonods)
                          exf = exf - Ax(knod+(Rproc-1)*Nonods)
                          exf = exf - Ax(Rnod+(kproc-1)*Nonods)
                          exf = exf + Ax(knod+(kproc-1)*Nonods)
                    !
                          exf = 2*exf
                    !
                    ! Now for r^T A r.
                          rr = .FALSE.
                          rk = .FALSE.
                          kr = .FALSE.
                          kk = .FALSE.
                          i = Rnod
                          DO count = Findom(i) , Findom(i+1) - 1
                             col = Coldom(count)
                             IF ( col.EQ.Rnod ) rr = .TRUE.
                             IF ( col.EQ.knod ) rk = .TRUE.
                          ENDDO
                          i = knod
                          DO count = Findom(i) , Findom(i+1) - 1
                             col = Coldom(count)
                             IF ( col.EQ.Rnod ) kr = .TRUE.
                             IF ( col.EQ.knod ) kk = .TRUE.
                          ENDDO
                    !
                          e1 = Edist((Rproc-1)*Nprocs+kproc)
                    ! The first entry
                          IF ( rr ) exf = exf - e1
                          IF ( rk ) exf = exf + e1
                    ! The 2ND entry
                          IF ( kr ) exf = exf - (-e1)
                          IF ( kk ) exf = exf - (e1)
                    ! The 3RD entry
                          IF ( rr ) exf = exf - (e1)
                          IF ( rk ) exf = exf - (-e1)
                    ! The 4TH entry
                          IF ( kr ) exf = exf + e1
                          IF ( kk ) exf = exf - e1
                    !
                          Newf = Curf + exf
                          END
                    !*==UPXAX.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE UPXAX(Rnod,Rproc,Wicnod,Wicpro,Nonods,Nprocs,Curf,Newf,&
                                         & Ax,Edist,Findom,Coldom,Ncoldo)
                          IMPLICIT NONE
                    !*--UPXAX4462
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , iproc , Ncoldo , Nonods , Nprocs
                    !*** End of declarations inserted by SPAG
                          INTEGER Rnod , Rproc , knod , kproc
                          INTEGER Wicnod(Nprocs) , Wicpro(Nonods)
                          INTEGER Ax(Nprocs*Nonods)
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER count , col , Curf , Newf , eir , eik
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo)
                    ! Update AX as well
                    ! WICNOD(PROC) returns the domain or 'nod' that processor proc contains.
                    ! WICPRO(NOD) returns the processor that domain NOD is on.
                    !
                          knod = Wicnod(Rproc)
                          kproc = Wicpro(Rnod)
                    !
                          Curf = Newf
                    !
                          i = Rnod
                          DO count = Findom(i) , Findom(i+1) - 1
                             DO iproc = 1 , Nprocs
                                eir = Edist((Rproc-1)*Nprocs+iproc)
                                eik = Edist((kproc-1)*Nprocs+iproc)
                                col = Coldom(count) + (iproc-1)*Nonods
                                Ax(col) = Ax(col) + eir - eik
                             ENDDO
                          ENDDO
                    !
                          i = knod
                          DO count = Findom(i) , Findom(i+1) - 1
                             DO iproc = 1 , Nprocs
                                eir = Edist((Rproc-1)*Nprocs+iproc)
                                eik = Edist((kproc-1)*Nprocs+iproc)
                                col = Coldom(count) + (iproc-1)*Nonods
                                Ax(col) = Ax(col) + eik - eir
                             ENDDO
                          ENDDO
                    !
                    !         I=RNOD+(RPROC-1)*NONODS
                    !         X(I)=X(I)+1
                    !         I=KNOD+(RPROC-1)*NONODS
                    !         X(I)=X(I)-1
                    !         I=RNOD+(KPROC-1)*NONODS
                    !         X(I)=X(I)-1
                    !         I=KNOD+(KPROC-1)*NONODS
                    !         X(I)=X(I)+1
                    !
                          Wicnod(Rproc) = Rnod
                          Wicpro(Rnod) = Rproc
                          Wicnod(kproc) = knod
                          Wicpro(knod) = kproc
                          END
                    !*==UPXAX2.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                    !
                          SUBROUTINE UPXAX2(Rnod,Rproc,Wicnod,Wicpro,Nonods,Nprocs,Curf,    &
                                          & Newf,Ax,Edist,Findom,Coldom,Ncoldo)
                          IMPLICIT NONE
                    !*--UPXAX24523
                    !*** Start of declarations inserted by SPAG
                          INTEGER i , idisp , iproc , Ncoldo , Nonods , Nprocs
                    !*** End of declarations inserted by SPAG
                          INTEGER Rnod , Rproc , knod , kproc
                          INTEGER Wicnod(Nprocs) , Wicpro(Nonods)
                          INTEGER Ax(Nprocs*Nonods)
                          INTEGER Edist(Nprocs*Nprocs)
                          INTEGER count , col , Curf , Newf , eir , eik
                          INTEGER Findom(Nonods+1) , Coldom(Ncoldo)
                    ! Update AX as well
                    ! WICNOD(PROC) returns the domain or 'nod' that processor proc contains.
                    ! WICPRO(NOD) returns the processor that domain NOD is on.
                    !
                          knod = Wicnod(Rproc)
                          kproc = Wicpro(Rnod)
                    !
                          Curf = Newf
                    !
                          DO iproc = 1 , Nprocs
                             eir = Edist((iproc-1)*Nprocs+Rproc)
                             eik = Edist((iproc-1)*Nprocs+kproc)
                             idisp = (iproc-1)*Nonods
                             i = Rnod
                             DO count = Findom(i) , Findom(i+1) - 1
                                col = Coldom(count) + idisp
                                Ax(col) = Ax(col) + eir - eik
                             ENDDO
                             i = knod
                             DO count = Findom(i) , Findom(i+1) - 1
                                col = Coldom(count) + idisp
                                Ax(col) = Ax(col) + eik - eir
                             ENDDO
                          ENDDO
                    !
                    !         I=RNOD+(RPROC-1)*NONODS
                    !         X(I)=X(I)+1
                    !         I=KNOD+(RPROC-1)*NONODS
                    !         X(I)=X(I)-1
                    !         I=RNOD+(KPROC-1)*NONODS
                    !         X(I)=X(I)-1
                    !         I=KNOD+(KPROC-1)*NONODS
                    !         X(I)=X(I)+1
                    !
                          Wicnod(Rproc) = Rnod
                          Wicpro(Rnod) = Rproc
                          Wicnod(kproc) = knod
                          Wicpro(knod) = kproc
                          END
                    !*==EXCEPT.spg  processed by SPAG 6.72Dc at 17:05 on 27 Apr 2019
                    !
                    !
                    !
                          SUBROUTINE EXCEPT(Pcost,Ncost,C,Yes)
                          IMPLICIT NONE
                    !*--EXCEPT4578
                    !*** Start of declarations inserted by SPAG
                          REAL RAN1
                    !*** End of declarations inserted by SPAG
                    !
                          REAL C , Pcost , Ncost , aprob , ran
                          LOGICAL Yes
                          IF ( Ncost.GE.Pcost ) THEN
                             Yes = .TRUE.
                             aprob = 9999.
                          ELSEIF ( ABS(C).LT.0.00000000000000001 ) THEN
                             Yes = .FALSE.
                             aprob = -9991.
                          ELSE
                             IF ( (Pcost-Ncost)/C.LT.40 ) THEN
                                aprob = 1/EXP((Pcost-Ncost)/C)
                             ELSE
                                aprob = 0.
                             ENDIF
                             IF ( aprob.GE.1 ) Yes = .TRUE.
                             IF ( aprob.LT.1 ) THEN
                                ran = RAN1(3)
                    !                write(*,*)'RAN=',RAN,' APROB=',APROB
                    !     &               ,' pcost=',PCOST,' NCOST=',NCOST
                    ! RAN is between 0 and 1.
                                Yes = .FALSE.
                                IF ( ran.LT.aprob ) Yes = .TRUE.
                             ENDIF
                          ENDIF
                    !          write(*,*)' APROB=',APROB
                          END
                    !
                    !
                    
                    
                          SUBROUTINE COLOR2( WHICHC,NCOLOR,Q,QTEMP,NNOD, &
                         &     FINA,COLA,NA,ZERO,QUICK)
                    !      use FLDebug
                          IMPLICIT NONE
                    !     
                    !     - This subroutine colours the stencil (FINA,COLA) and puts the results in WHICHC()
                    !     - The pointers are FINA,COLA
                    !     - The number of nodes is NNOD.
                    !     - NCOLOR = no of colours needed. 
                    !     - WHICHC  contains the colouring. 
                    !     - Q,QTEMP are working arrays.
                    !     - if not ZERO then some of the nodes have already been coloured. 
                          LOGICAL QUICK
                    !     PARAMETER(QUICK=.TRUE.)
                    !     
                          INTEGER NCOLOR,NNOD,NA
                          INTEGER Q(NNOD), QTEMP(NNOD), WHICHC(NNOD)
                          INTEGER FINA(NNOD+1),COLA(NA)
                          LOGICAL ZERO
                    !
                          INTEGER VAL, COUNT, COL, QCOLOR, ROW
                          INTEGER MINVAL,MAXCON,MAXCOL, COLOR_CHOOS
                          LOGICAL DONE,FOUND,QUICKEST
                          INTEGER I,INCOLO,NODE,ICOUNT,NQ,ITS,J,NODQ,NUM,NQTEMP,ICOL,II,JKEEP
                    !
                    !
                          IF(ZERO) THEN
                            DO I=1,NNOD
                              WHICHC(I)=0
                            END DO
                          ENDIF
                          INCOLO=0
                    
                          QUICKEST=.false.!QUICK
                          IF(QUICKEST) THEN ! There is a small bug in this sub so written code around it. 
                            NCOLOR = MAXVAL(WHICHC(1:NNOD))
                            DO I = 1, NNOD
                               IF(WHICHC(I)==0) THEN ! Color node I
                    
                                  COLOR_CHOOS=0
                                  DO QCOLOR=NCOLOR,1,-1
                                     FOUND=.FALSE.
                                     DO COUNT = FINA(I),FINA(I+1)-1
                                        J=COLA(COUNT) 
                                        IF(WHICHC(J)==QCOLOR) FOUND=.TRUE.
                                     END DO
                                     IF(.NOT.FOUND) COLOR_CHOOS=QCOLOR
                                  END DO ! DO QCOLOR=NCOLOR,1,-1
                                  IF(COLOR_CHOOS==0) THEN
                                     NCOLOR=NCOLOR+1
                                     WHICHC(I)=NCOLOR
                                  ELSE
                                     WHICHC(I)=COLOR_CHOOS
                                  ENDIF
                    
                               ENDIF
                            END DO ! DO I = 1, NNOD
                            RETURN
                          ENDIF
                    !
                    ! - find node with min valency that is not already coloured.
                    !
                    !2100  CONTINUE
                          NQ = 0
                          DO WHILE ( NQ .EQ. 0 ) 
                    !
                          MINVAL = 100000
                          NODE=0
                          ICOUNT=0
                          DO I = 1, NNOD
                           IF(WHICHC(I).EQ.0) THEN
                             ICOUNT=ICOUNT+1
                             VAL = FINA(I+1) - FINA(I)
                             IF( VAL .LT. MINVAL ) THEN
                                MINVAL = VAL
                                NODE   = I
                             END IF
                            END IF
                          END DO  ! DO I = 1, NNOD
                    !     ewrite(3,*)'node,minval,nnod:',node,minval,nnod, 
                    !    & ' NDS NOT COLED=',ICOUNT
                    !
                          IF(NODE.EQ.0) THEN
                    !       ewrite(3,*)'HAVE COLOURED ALL THE NODES'
                             NQ=-1
                          ELSE ! IF(NODE.EQ.0) THEN
                    !        GOTO 9700
                    !      ENDIF
                             NQ   = 1
                    !
                             Q(1) = NODE
                    !
                             DO ITS = 1, 100000
                    !        ewrite(3,*)'front no, nq,NDS COLD:',its,nq,INCOLO
                    !        ewrite(3,*)'q:',(q(iijj),iijj=1,nq)
                    !
                    ! - colour Q
                                QCOLOR=0
                                DO J = 1, NQ
                                  MAXCON = -1
                                  IF(.NOT.QUICK) THEN
                                   DO I = 1, NQ
                    ! - find node not coloured connected to max number of coloured nodes. 
                                      NODQ = Q(I)
                                      IF( WHICHC(NODQ) .EQ. 0 ) THEN
                                         NUM  = 0
                                         DO COUNT = FINA(NODQ),FINA(NODQ+1)-1
                                            IF( WHICHC(COLA(COUNT)) .NE. 0 ) NUM = NUM+1
                                         END DO ! DO COUNT = FINA(NODQ),FINA(NODQ+1)-1
                    !
                                         IF( NUM .GT. MAXCON ) THEN
                                            MAXCON = NUM
                                            QCOLOR = NODQ
                                         END IF
                                      END IF
                                   END DO ! DO I = 1, NQ
                                 ELSE
                                   QCOLOR=Q(J)
                                 ENDIF
                                 IF(QCOLOR==0) THEN
                                    PRINT *,'ITS,QUICK,J,NODE,NQ,NNOD=',ITS,QUICK,J,NODE,NQ,NNOD
                                    PRINT *,'Q(J):',Q(J)
                                    STOP 2894
                                 ENDIF
                    !
                    ! - Colour node QCOLOR
                    ! - find MAXCOL = max color number surrounding node.  
                                 MAXCOL = 0
                                 DO COUNT = FINA(QCOLOR),FINA(QCOLOR+1)-1
                                    MAXCOL = MAX( WHICHC( COLA(COUNT) ), MAXCOL )
                                 END DO ! DO COUNT = FINA(QCOLOR),FINA(QCOLOR+1)-1
                    !
                                 DONE = .FALSE.
                                 DO COL = 1, MAXCOL
                    !
                    ! - look for color 
                                   IF( .NOT. DONE ) THEN
                                      FOUND = .FALSE.
                                      DO COUNT = FINA(QCOLOR),FINA(QCOLOR+1)-1
                                       IF( COL .EQ. WHICHC(COLA(COUNT)) ) FOUND=.TRUE.
                                      END DO ! DO COUNT = FINA(QCOLOR),FINA(QCOLOR+1)-1
                    !
                                      IF( .NOT. FOUND ) THEN
                                         DONE           = .TRUE.
                                         WHICHC(QCOLOR) = COL
                                      END IF
                                   END IF
                                 END DO ! DO COL = 1, MAXCOL
                    !
                                 IF( .NOT. DONE ) WHICHC(QCOLOR) = MAXCOL + 1
                               END DO ! DO J = 1, NQ
                               INCOLO=INCOLO+NQ
                    !
                    ! - find Q
                               DO I = 1, NQ
                                  QTEMP(I) = Q(I)
                               END DO ! DO I = 1, NQ
                    !
                               NQTEMP = NQ
                    !
                    ! - find all the nodes that QTEMP is connected 
                    ! to that are not coloured.
                    ! - and not already in Q. 
                    !
                               NQ = 0
                               DO I = 1, NQTEMP
                                  ROW = QTEMP(I)
                                  DO COUNT = FINA(ROW), FINA(ROW+1)-1
                                     ICOL = COLA(COUNT)
                    !
                    ! - see if already in Q.
                                     IF( WHICHC(ICOL) .EQ. 0 ) THEN
                                        FOUND = .FALSE.
                                        DO II = 1, NQ
                                           IF( ICOL .EQ. Q(II) ) FOUND = .TRUE.
                                        END DO ! DO II = 1, NQ
                                        IF( .NOT. FOUND ) THEN
                                           NQ    = NQ + 1
                                           Q(NQ) = ICOL
                                        END IF
                                     END IF
                                  END DO ! DO COUNT = FINA(ROW), FINA(ROW+1)-1
                               END DO ! DO I = 1, NQTEMP
                    !
                    !         IF( NQ .EQ. 0 ) GO TO 2100
                               IF( NQ .EQ. 0 ) EXIT ! exit its loop 
                    !
                            END DO ! DO ITS = 1, 100000
                    !
                          ENDIF ! IF(NODE.EQ.0) THEN ELSE
                    
                          
                          END DO ! DO WHILE ( NQ .EQ. 0 )
                    !
                    ! 9700  CONTINUE
                    !
                    ! - Now find NCOLOR
                    !
                            NCOLOR = 0
                            DO I = 1, NNOD
                               NCOLOR = MAX( NCOLOR, WHICHC(I) )
                            END DO ! DO I = 1, NNOD
                    !        ewrite(3,*) '   MAXIMUM NO. OF NODAL COLOURS IS : ', NCOLOR
                            RETURN
                            END SUBROUTINE COLOR2
                    !
                    !
                    !
                    !
                        SUBROUTINE CLRRL( N, A, CONST )
                    !     ------------------------------
                    ! - this subroutine clears a real array
                    !
                    !   -------------------------------
                    ! - date last modified : 03/05/1998
                    !   -------------------------------
                    !
                          IMPLICIT NONE
                    !
                          INTEGER N, I
                    !
                          REAL    A(N), CONST
                    !
                          DO I = 1, N
                    !
                             A(I) = CONST
                    !
                          END DO
                    !
                          RETURN
                          END SUBROUTINE CLRRL
                    ! 
                    ! 
                    ! 
                    ! 
                    ! In phython use:
                    ! renum2=reorde(fina,cola,nonods,ncola) 
                          SUBROUTINE REORDE(RENUM2,FINA,COLA,NONODS,NCOLA)
                          IMPLICIT NONE
                    !     This subroutine mimimizes the bandwidth for a direct solution 
                    !     and maximizes the connectivity for an iterative solution. 
                    !     IT works by forming fronts, the nodes contained in which 
                    !     are renumbered. 
                    !     The nodes with the minimum mean of the surrounding 
                    !     numbered nodes, the front nods can be taken as 
                    !     negative or egnored. 
                    !     RENUM2(OLDNOD no)=new nod no. 
                    !     It will begin renumbering from the maximum entry in RENUM2.
                    !     
                          INTEGER, INTENT(IN) :: NONODS,NCOLA
                          INTEGER, INTENT(OUT) :: RENUM2(NONODS)
                          INTEGER, INTENT(IN) :: FINA(NONODS+1)
                          INTEGER, INTENT(IN) :: COLA(NCOLA)
                    ! Local variables...
                    !     
                          INTEGER MXVAL,NVAL,MXNOD,MXRENU
                          INTEGER MINVAL,MINNOD
                          INTEGER NODGOT,COUNT,ROW,IIQN
                    !     Q,QTEMP contains the work spase. 
                          INTEGER LARGE
                          PARAMETER(LARGE=10000000)
                          LOGICAL FOUND
                          INTEGER I,NOD,ICOL,NQ,IFRONT,NQTEMP,II,J,IAV,III
                          INTEGER IMXBWD
                          integer, allocatable :: Q(:),QTEMP(:), BLANK(:)
                    !     This sub reorders the equations so an iterative OR DIRECT solver 
                    !     can solve the equations efficiently. 
                    !     When BLANK(I)=0 node I is egnored (or renumbered). 
                    !     When BLANK(I)=1 node I is not egnored(or renumbered). 
                    
                          IIQN=NONODS
                          ALLOCATE(BLANK(IIQN),Q(IIQN),QTEMP(IIQN)) 
                    
                    !      IF(ZERO) THEN
                             DO I=1,NONODS
                                RENUM2(I)=0
                             END DO
                    !      ENDIF
                    !     
                     9770 CONTINUE
                    !     Find MXRENU = max node number in RENUM2
                          MXRENU=0
                          DO I=1,NONODS
                             MXRENU=MAX(RENUM2(I),MXRENU)
                          END DO
                    !      ewrite(3,*)  "MXRENU=",MXRENU
                    !     
                          NOD=MXRENU+1
                    !     
                          MINVAL=LARGE
                          MINNOD=0
                    !      ewrite(3,*)  "NOD, LARGE, NONODS = ", NOD, LARGE, NONODS
                          DO I=1,NONODS
                    !         ewrite(3,*) "node ",I
                             IF(BLANK(I).NE.0) THEN
                                IF(RENUM2(I).EQ.0) THEN
                                   NVAL=0
                    !               ewrite(3,*)  "FINA(I),FINA(I+1)-1 =" , FINA(I),FINA(I+1)-1
                                   DO COUNT=FINA(I),FINA(I+1)-1
                                      ICOL=COLA(COUNT)
                    !                  ewrite(3,*)  "ICOL = ", ICOL
                                      IF(BLANK(ICOL).NE.0) THEN 
                                         IF(RENUM2(ICOL).EQ.0) NVAL=NVAL+1
                                      ENDIF
                                   END DO
                                   IF(NVAL.LT.MINVAL) THEN
                                      MINVAL=NVAL
                                      MINNOD=I
                                   ENDIF
                    !     ewrite(3,*)  "MINVAL, MINNOD", MINVAL, MINNOD
                                ENDIF
                             ENDIF
                          END DO
                          IF(MINNOD==0) STOP 191 ! node is wrong. 
                    !     ewrite(3,*) "MINNOD = ", MINNOD
                    !     
                    !     RENUM(NOD)=MXNOD
                    !      ewrite(3,*)  MINNOD
                    !      ewrite(3,*)  NOD
                          RENUM2(MINNOD)=NOD
                    !     
                    
                          NQ=1
                          Q(1)=MINNOD
                          DO IFRONT=1,100000
                    !     Find another front Q. 
                    !     find all the nodes(put in Q) that QTEMP is 
                    !     connected to that are not numbered.
                    !     and not already in Q. 
                    !     ewrite(3,*) 'nq,ifront=',nq,ifront
                             DO I=1,NQ
                                QTEMP(I)=Q(I)
                    !     ewrite(3,*)  "I, Q(I) = ", I, Q(I)
                             END DO
                             NQTEMP=NQ
                             NQ=0
                             DO I=1,NQTEMP
                                ROW=QTEMP(I)
                    !     ewrite(3,*) "ROW = ",ROW
                                DO COUNT=FINA(ROW),FINA(ROW+1)-1
                                   ICOL=COLA(COUNT)
                    !     ewrite(3,*)  "ICOL, COUNT, BLANK(ICOL)= ",ICOL, COUNT, BLANK(ICOL)
                    !     see if already in Q.
                                   IF(BLANK(ICOL).NE.0) THEN
                                      IF(RENUM2(ICOL).EQ.0) THEN
                                         FOUND=.FALSE.
                                         DO II=1,NQ
                                            IF(ICOL.EQ.Q(II)) FOUND=.TRUE.
                                         END DO
                    !     ewrite(3,*) "FOUND = ", FOUND
                                         IF(.NOT.FOUND) THEN
                                            NQ=NQ+1
                                            Q(NQ)=ICOL
                                         ENDIF
                    !     ewrite(3,*) "NQ, Q(NQ)",NQ, Q(NQ)
                                      ENDIF
                                   ENDIF
                                END DO
                             END DO
                    !     ewrite(3,*)  "MSG1 NQ = ", NQ
                    !     GIVE NOD NOS TO Q
                             IF((IFRONT.EQ.1).AND.(NQ.GT.2)) THEN
                    !     Creat a spacial ordering. *************
                    !            ewrite(3,*)  "Creat a spacial ordering. *************"
                    !     Find node in Q with max valancy
                                MXVAL=-1
                                DO J=1,NQ
                                   I=Q(J)
                                   IF(BLANK(I).NE.0) THEN
                                      IF(RENUM2(I).EQ.0) THEN
                                         NVAL=0
                                         DO COUNT=FINA(I),FINA(I+1)-1
                                            ICOL=COLA(COUNT)
                                            IF(BLANK(ICOL).NE.0) THEN 
                                               IF(RENUM2(ICOL).EQ.0) NVAL=NVAL+1
                                            ENDIF
                                         END DO
                                         IF(NVAL.GT.MXVAL) THEN
                                            MXVAL=NVAL
                                            MXNOD=I
                                         ENDIF
                                      ENDIF
                                   ENDIF
                                END DO
                    !     
                                IAV=INT(REAL(NQ)/2. +0.6)
                    !     ewrite(3,*)  "IAV = ",IAV
                    !     Put to -1 for loops 910,920.
                                RENUM2(MXNOD)=-1
                                III=0
                                DO I=1,NQ
                                   IF(III.LT.IAV-1) THEN
                                      IF(RENUM2(Q(I)).EQ.0) THEN
                                         III=III+1
                                         NOD=NOD+1
                                         RENUM2(Q(I))=-NOD
                                      ENDIF
                                   ENDIF
                                END DO
                                NOD=NOD+1
                                RENUM2(MXNOD)=-NOD
                                DO I=1,NQ
                                   IF(RENUM2(Q(I)).EQ.0) THEN
                                      NOD=NOD+1
                                      RENUM2(Q(I))=-NOD
                                   ENDIF
                                END DO
                    !     ***************************************
                             ELSE
                                DO J=1,NQ
                                   NODGOT=Q(J)
                    !     
                                   NOD=NOD+1
                                   IF(NOD.GT.NONODS) THEN
                    !                  ewrite(-1,*) "ERROR!!!!!!! NOD, NONODS = ", NOD, NONODS
                    !                  FLAbort("Dieing")
                                       STOP 29191 ! DOES NOT WORK
                                   END IF
                                   RENUM2(NODGOT)=-NOD
                                END DO
                    !     
                             ENDIF
                    !     
                    !     ewrite(3,*) "NQ = ", NQ
                             DO I=1,NQ
                                RENUM2(Q(I))=-RENUM2(Q(I))
                             END DO
                             IF(NQ.EQ.0) THEN
                    !     See if we have numbered all the nodes, if not 
                    !     then goto 9770 else goto 9700
                                FOUND=.FALSE.
                                DO I=1,NONODS
                    !     IF(NONODS.EQ.4) ewrite(3,*)  "RENUM2(I) = ",RENUM2(I)
                                   IF(BLANK(I).EQ.1) THEN
                                      IF(RENUM2(I).EQ.0) THEN
                                         FOUND=.TRUE.
                                      ENDIF
                                   ENDIF
                                END DO
                                IF(FOUND) GOTO 9770
                                IF(.NOT.FOUND) GOTO 9700
                             END IF
                          END DO
                     9700 CONTINUE
                    !     
                    !     find maximum bandwidth. 
                          IMXBWD=0
                          DO I=1,NONODS
                             IF(BLANK(I).NE.0) THEN
                                II=RENUM2(I)
                                DO COUNT=FINA(I),FINA(I+1)-1
                                   ICOL=COLA(COUNT)
                                   IF(BLANK(ICOL).NE.0) THEN
                                      IMXBWD=MAX(IMXBWD, ABS(II-RENUM2(ICOL)) )
                                   ENDIF
                                END DO
                             ENDIF
                          END DO
                    !     ewrite(3,*) 'MAX semi-BANDWIDTH=',IMXBWD 
                    !     ewrite(3,*) 'BLANK:',BLANK
                    !     
                          RETURN
                          END SUBROUTINE REORDE  
                    ! 
                    ! 
                    ! 
                    ! 
                    
                    
                    
                    